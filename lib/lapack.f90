      !! automatically generated interface
      !! pipe a .f90 file & compile with -ffixed-form

      module lapack

      interface

      !! cbbcsd.f
      subroutine cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,
     &                   theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t,
     &                   v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,
     &                   b22d, b22e, rwork, lrwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
      real               b11d( * ), b11e( * ), b12d( * ), b12e( * ),
     &                   b21d( * ), b21e( * ), b22d( * ), b22e( * ),
     &                   phi( * ), theta( * ), rwork( * )
      complex            u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * )
      integer            maxitr
      parameter          ( maxitr = 6 )
      real               hundred, meighth, one, piover2, ten, zero
      parameter          ( hundred = 100.0e0, meighth = -0.125e0,
     &                     one = 1.0e0, piover2 = 1.57079632679489662e0,
     &                     ten = 10.0e0, zero = 0.0e0 )
      complex            negonecomplex
      parameter          ( negonecomplex = (-1.0e0,0.0e0) )
      logical            colmajor, lquery, restart11, restart12,
     &                   restart21, restart22, wantu1, wantu2, wantv1t,
     &                   wantv2t
      integer            i, imin, imax, iter, iu1cs, iu1sn, iu2cs,
     &                   iu2sn, iv1tcs, iv1tsn, iv2tcs, iv2tsn, j,
     &                   lrworkmin, lrworkopt, maxit, mini
      real               b11bulge, b12bulge, b21bulge, b22bulge, dummy,
     &                   eps, mu, nu, r, sigma11, sigma21,
     &                   temp, thetamax, thetamin, thresh, tol, tolmul,
     &                   unfl, x1, x2, y1, y2
      real               slamch
      logical            lsame
      end subroutine cbbcsd

      !! cbdsqr.f
      subroutine cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,
     &                   ldu, c, ldc, rwork, info )
      character          uplo
      integer            info, ldc, ldu, ldvt, n, ncc, ncvt, nru
      real               d( * ), e( * ), rwork( * )
      complex            c( ldc, * ), u( ldu, * ), vt( ldvt, * )
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               negone
      parameter          ( negone = -1.0e0 )
      real               hndrth
      parameter          ( hndrth = 0.01e0 )
      real               ten
      parameter          ( ten = 10.0e0 )
      real               hndrd
      parameter          ( hndrd = 100.0e0 )
      real               meigth
      parameter          ( meigth = -0.125e0 )
      integer            maxitr
      parameter          ( maxitr = 6 )
      logical            lower, rotate
      integer            i, idir, isub, iter, j, ll, lll, m, maxit, nm1,
     &                   nm12, nm13, oldll, oldm
      real               abse, abss, cosl, cosr, cs, eps, f, g, h, mu,
     &                   oldcs, oldsn, r, shift, sigmn, sigmx, sinl,
     &                   sinr, sll, smax, smin, sminl, sminoa,
     &                   sn, thresh, tol, tolmul, unfl
      logical            lsame
      real               slamch
      end subroutine cbdsqr

      !! cgbbrd.f
      subroutine cgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,
     &                   ldq, pt, ldpt, c, ldc, work, rwork, info )
      character          vect
      integer            info, kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
      real               d( * ), e( * ), rwork( * )
      complex            ab( ldab, * ), c( ldc, * ), pt( ldpt, * ),
     &                   q( ldq, * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            wantb, wantc, wantpt, wantq
      integer            i, inca, j, j1, j2, kb, kb1, kk, klm, klu1,
     &                   kun, l, minmn, ml, ml0, mu, mu0, nr, nrt
      real               abst, rc
      complex            ra, rb, rs, t
      logical            lsame
      end subroutine cgbbrd

      !! cgbcon.f
      subroutine cgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,
     &                   work, rwork, info )
      character          norm
      integer            info, kl, ku, ldab, n
      real               anorm, rcond
      integer            ipiv( * )
      real               rwork( * )
      complex            ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            lnoti, onenrm
      character          normin
      integer            ix, j, jp, kase, kase1, kd, lm
      real               ainvnm, scale, smlnum
      complex            t, zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               slamch
      complex            cdotc
      real               cabs1
      end subroutine cgbcon

      !! cgbequb.f
      subroutine cgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                    amax, info )
      integer            info, kl, ku, ldab, m, n
      real               amax, colcnd, rowcnd
      real               c( * ), r( * )
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, kd
      real               bignum, rcmax, rcmin, smlnum, radix,
     &                   logrdx
      complex            zdum
      real               slamch
      real               cabs1
      end subroutine cgbequb

      !! cgbequ.f
      subroutine cgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, info )
      integer            info, kl, ku, ldab, m, n
      real               amax, colcnd, rowcnd
      real               c( * ), r( * )
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, kd
      real               bignum, rcmax, rcmin, smlnum
      complex            zdum
      real               slamch
      real               cabs1
      end subroutine cgbequ

      !! cgbrfs.f
      subroutine cgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, rwork,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, k, kase, kk, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine cgbrfs

      !! cgbrfsx.f
      subroutine cgbrfsx( trans, equed, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, r, c, b, ldb, x, ldx, rcond,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, rwork,
     &                    info )
      character          trans, equed
      integer            info, ldab, ldafb, ldb, ldx, n, kl, ku, nrhs,
     &                   nparams, n_err_bnds
      real               rcond
      integer            ipiv( * )
      complex            ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran, ignore_cwise
      integer            j, trans_type, prec_type, ref_type, n_norms,
     &                   ithresh
      real               anorm, rcond_tmp, illrcond_thresh, err_lbnd,
     &                   cwise_wrong, rthresh, unstable_thresh
      real               slamch, clangb, cla_gbrcond_x, cla_gbrcond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine cgbrfsx

      !! cgbsv.f
      subroutine cgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      complex            ab( ldab, * ), b( ldb, * )
      end subroutine cgbsv

      !! cgbsvx.f
      subroutine cgbsvx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                   ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, rwork, info )
      character          equed, fact, trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * )
      real               berr( * ), c( * ), ferr( * ), r( * ),
     &                   rwork( * )
      complex            ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j, j1, j2
      real               amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      real               clangb, clantb, slamch
      end subroutine cgbsvx

      !! cgbsvxx.f
      subroutine cgbsvxx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                    rcond, rpvgrw, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          equed, fact, trans
      integer            info, ldab, ldafb, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            ipiv( * )
      complex            ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, i, j, kl, ku
      real               amax, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, smlnum
      logical            lsame
      real               slamch, cla_gbrpvgrw
      end subroutine cgbsvxx

      !! cgbtf2.f
      subroutine cgbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      complex            ab( ldab, * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, j, jp, ju, km, kv
      integer            icamax
      end subroutine cgbtf2

      !! cgbtrf.f
      subroutine cgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      complex            ab( ldab, * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      integer            nbmax, ldwork
      parameter          ( nbmax = 64, ldwork = nbmax+1 )
      integer            i, i2, i3, ii, ip, j, j2, j3, jb, jj, jm, jp,
     &                   ju, k2, km, kv, nb, nw
      complex            temp
      complex            work13( ldwork, nbmax ),
     &                   work31( ldwork, nbmax )
      integer            icamax, ilaenv
      end subroutine cgbtrf

      !! cgbtrs.f
      subroutine cgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      complex            ab( ldab, * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            lnoti, notran
      integer            i, j, kd, l, lm
      logical            lsame
      end subroutine cgbtrs

      !! cgebak.f
      subroutine cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,
     &                   info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      real               scale( * )
      complex            v( ldv, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            leftv, rightv
      integer            i, ii, k
      real               s
      logical            lsame
      end subroutine cgebak

      !! cgebal.f
      subroutine cgebal( job, n, a, lda, ilo, ihi, scale, info )
      character          job
      integer            ihi, ilo, info, lda, n
      real               scale( * )
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               sclfac
      parameter          ( sclfac = 2.0e+0 )
      real               factor
      parameter          ( factor = 0.95e+0 )
      logical            noconv
      integer            i, ica, iexc, ira, j, k, l, m
      real               c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1,
     &                   sfmin2
      complex            cdum
      logical            sisnan, lsame
      integer            icamax
      real               slamch, scnrm2
      end subroutine cgebal

      !! cgebd2.f
      subroutine cgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
      integer            info, lda, m, n
      real               d( * ), e( * )
      complex            a( lda, * ), taup( * ), tauq( * ), work( * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      integer            i
      complex            alpha
      end subroutine cgebd2

      !! cgebrd.f
      subroutine cgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,
     &                   info )
      integer            info, lda, lwork, m, n
      real               d( * ), e( * )
      complex            a( lda, * ), taup( * ), tauq( * ),
     &                   work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, iinfo, j, ldwrkx, ldwrky, lwkopt, minmn, nb,
     &                   nbmin, nx
      real               ws
      integer            ilaenv
      end subroutine cgebrd

      !! cgecon.f
      subroutine cgecon( norm, n, a, lda, anorm, rcond, work, rwork,
     &                   info )
      character          norm
      integer            info, lda, n
      real               anorm, rcond
      real               rwork( * )
      complex            a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            onenrm
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, scale, sl, smlnum, su
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               slamch
      real               cabs1
      end subroutine cgecon

      !! cgeequb.f
      subroutine cgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                    info )
      integer            info, lda, m, n
      real               amax, colcnd, rowcnd
      real               c( * ), r( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               bignum, rcmax, rcmin, smlnum, radix, logrdx
      complex            zdum
      real               slamch
      real               cabs1
      end subroutine cgeequb

      !! cgeequ.f
      subroutine cgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   info )
      integer            info, lda, m, n
      real               amax, colcnd, rowcnd
      real               c( * ), r( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               bignum, rcmax, rcmin, smlnum
      complex            zdum
      real               slamch
      real               cabs1
      end subroutine cgeequ

      !! cgees.f
      subroutine cgees( jobvs, sort, select, n, a, lda, sdim, w, vs,
     &                  ldvs, work, lwork, rwork, bwork, info )
      character          jobvs, sort
      integer            info, lda, ldvs, lwork, n, sdim
      logical            bwork( * )
      real               rwork( * )
      complex            a( lda, * ), vs( ldvs, * ), w( * ), work( * )
      logical            select
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, scalea, wantst, wantvs
      integer            hswork, i, ibal, icond, ierr, ieval, ihi, ilo,
     &                   itau, iwrk, maxwrk, minwrk
      real               anrm, bignum, cscale, eps, s, sep, smlnum
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      end subroutine cgees

      !! cgeesx.f
      subroutine cgeesx( jobvs, sort, select, sense, n, a, lda, sdim, w,
     &                   vs, ldvs, rconde, rcondv, work, lwork, rwork,
     &                   bwork, info )
      character          jobvs, sense, sort
      integer            info, lda, ldvs, lwork, n, sdim
      real               rconde, rcondv
      logical            bwork( * )
      real               rwork( * )
      complex            a( lda, * ), vs( ldvs, * ), w( * ), work( * )
      logical            select
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, scalea, wantsb, wantse, wantsn, wantst,
     &                   wantsv, wantvs
      integer            hswork, i, ibal, icond, ierr, ieval, ihi, ilo,
     &                   itau, iwrk, lwrk, maxwrk, minwrk
      real               anrm, bignum, cscale, eps, smlnum
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      end subroutine cgeesx

      !! cgeev.f
      subroutine cgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,
     &                  work, lwork, rwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldvl, ldvr, lwork, n
      real               rwork( * )
      complex            a( lda, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   w( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, scalea, wantvl, wantvr
      character          side
      integer            hswork, i, ibal, ierr, ihi, ilo, irwork, itau,
     &                   iwrk, k, maxwrk, minwrk, nout
      real               anrm, bignum, cscale, eps, scl, smlnum
      complex            tmp
      logical            select( 1 )
      real               dum( 1 )
      logical            lsame
      integer            ilaenv, isamax
      real               clange, scnrm2, slamch
      end subroutine cgeev

      !! cgeevx.f
      subroutine cgeevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,
     &                   ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde,
     &                   rcondv, work, lwork, rwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldvl, ldvr, lwork, n
      real               abnrm
      real               rconde( * ), rcondv( * ), rwork( * ),
     &                   scale( * )
      complex            a( lda, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   w( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, scalea, wantvl, wantvr, wntsnb, wntsne,
     &                   wntsnn, wntsnv
      character          job, side
      integer            hswork, i, icond, ierr, itau, iwrk, k, maxwrk,
     &                   minwrk, nout
      real               anrm, bignum, cscale, eps, scl, smlnum
      complex            tmp
      logical            select( 1 )
      real               dum( 1 )
      logical            lsame
      integer            ilaenv, isamax
      real               clange, scnrm2, slamch
      end subroutine cgeevx

      !! cgehd2.f
      subroutine cgehd2( n, ilo, ihi, a, lda, tau, work, info )
      integer            ihi, ilo, info, lda, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      integer            i
      complex            alpha
      end subroutine cgehd2

      !! cgehrd.f
      subroutine cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      complex            a( lda, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                     one = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iwt, j, ldwork, lwkopt, nb,
     &                   nbmin, nh, nx
      complex            ei
      integer            ilaenv
      end subroutine cgehrd

      !! cgejsv.f
      subroutine cgejsv( joba, jobu, jobv, jobr, jobt, jobp,
     &                   m, n, a, lda, sva, u, ldu, v, ldv,
     &                   cwork, lwork, rwork, lrwork, iwork, info )
      integer     info, lda, ldu, ldv, lwork, lrwork, m, n
      complex     a( lda, * ), u( ldu, * ), v( ldv, * ), cwork( lwork )
      real        sva( n ), rwork( * )
      integer     iwork( * )
      character(len=1) joba, jobp, jobr, jobt, jobu, jobv
      real        zero,         one
      parameter ( zero = 0.0e0, one = 1.0e0 )
      complex     czero,                    cone
      parameter ( czero = ( 0.0e0, 0.0e0 ), cone = ( 1.0e0, 0.0e0 ) )
      complex ctemp
      real    aapp,   aaqq,   aatmax, aatmin, big,    big1,   cond_ok,
     &        condr1, condr2, entra,  entrat, epsln,  maxprj, scalem,
     &        sconda, sfmin,  small,  temp1,  uscal1, uscal2, xsc
      integer ierr,   n1,     nr,     numrank,        p, q,   warning
      logical almort, defr,   errest, goscal, jracc,  kill,   lsvec,
     &        l2aber, l2kill, l2pert, l2rank, l2tran,
     &        noscal, rowpiv, rsvec,  transp
      real      slamch, scnrm2
      integer   isamax
      logical   lsame
      end subroutine cgejsv

      !! cgelq2.f
      subroutine cgelq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      integer            i, k
      complex            alpha
      end subroutine cgelq2

      !! cgelqf.f
      subroutine cgelqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine cgelqf

      !! cgelsd.f
      subroutine cgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,
     &                   work, lwork, rwork, iwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      real               rcond
      integer            iwork( * )
      real               rwork( * ), s( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      complex            czero
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            iascl, ibscl, ie, il, itau, itaup, itauq,
     &                   ldwork, liwork, lrwork, maxmn, maxwrk, minmn,
     &                   minwrk, mm, mnthr, nlvl, nrwork, nwork, smlsiz
      real               anrm, bignum, bnrm, eps, sfmin, smlnum
      integer            ilaenv
      real               clange, slamch
      end subroutine cgelsd

      !! cgels.f
      subroutine cgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,
     &                  info )
      character          trans
      integer            info, lda, ldb, lwork, m, n, nrhs
      complex            a( lda, * ), b( ldb, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery, tpsd
      integer            brow, i, iascl, ibscl, j, mn, nb, scllen, wsize
      real               anrm, bignum, bnrm, smlnum
      real               rwork( 1 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      end subroutine cgels

      !! cgelss.f
      subroutine cgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,
     &                   work, lwork, rwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      real               rcond
      real               rwork( * ), s( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            bl, chunk, i, iascl, ibscl, ie, il, irwork,
     &                   itau, itaup, itauq, iwork, ldwork, maxmn,
     &                   maxwrk, minmn, minwrk, mm, mnthr
      integer            lwork_cgeqrf, lwork_cunmqr, lwork_cgebrd,
     &                   lwork_cunmbr, lwork_cungbr, lwork_cunmlq,
     &                   lwork_cgelqf
      real               anrm, bignum, bnrm, eps, sfmin, smlnum, thr
      complex            dum( 1 )
      integer            ilaenv
      real               clange, slamch
      end subroutine cgelss

      !! cgelsy.f
      subroutine cgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,
     &                   work, lwork, rwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      real               rcond
      integer            jpvt( * )
      real               rwork( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      integer            imax, imin
      parameter          ( imax = 1, imin = 2 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, iascl, ibscl, ismax, ismin, j, lwkopt, mn,
     &                   nb, nb1, nb2, nb3, nb4
      real               anrm, bignum, bnrm, smax, smaxpr, smin, sminpr,
     &                   smlnum, wsize
      complex            c1, c2, s1, s2
      integer            ilaenv
      real               clange, slamch
      end subroutine cgelsy

      !! cgemqrt.f
      subroutine cgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,
     &                   c, ldc, work, info )
      character side, trans
      integer   info, k, ldv, ldc, m, n, nb, ldt
      complex   v( ldv, * ), c( ldc, * ), t( ldt, * ), work( * )
      logical            left, right, tran, notran
      integer            i, ib, ldwork, kf, q
      logical            lsame
      end subroutine cgemqrt

      !! cgeql2.f
      subroutine cgeql2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      integer            i, k
      complex            alpha
      end subroutine cgeql2

      !! cgeqlf.f
      subroutine cgeqlf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine cgeqlf

      !! cgeqp3.f
      subroutine cgeqp3( m, n, a, lda, jpvt, tau, work, lwork, rwork,
     &                   info )
      integer            info, lda, lwork, m, n
      integer            jpvt( * )
      real               rwork( * )
      complex            a( lda, * ), tau( * ), work( * )
      integer            inb, inbmin, ixover
      parameter          ( inb = 1, inbmin = 2, ixover = 3 )
      logical            lquery
      integer            fjb, iws, j, jb, lwkopt, minmn, minws, na, nb,
     &                   nbmin, nfxd, nx, sm, sminmn, sn, topbmn
      integer            ilaenv
      real               scnrm2
      end subroutine cgeqp3

      !! cgeqr2.f
      subroutine cgeqr2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      integer            i, k
      complex            alpha
      end subroutine cgeqr2

      !! cgeqr2p.f
      subroutine cgeqr2p( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      integer            i, k
      complex            alpha
      end subroutine cgeqr2p

      !! cgeqrf.f
      subroutine cgeqrf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine cgeqrf

      !! cgeqrfp.f
      subroutine cgeqrfp( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine cgeqrfp

      !! cgeqrt2.f
      subroutine cgeqrt2( m, n, a, lda, t, ldt, info )
      integer   info, lda, ldt, m, n
      complex   a( lda, * ), t( ldt, * )
      complex  one, zero
      parameter( one = (1.0,0.0), zero = (0.0,0.0) )
      integer   i, k
      complex   aii, alpha
      end subroutine cgeqrt2

      !! cgeqrt3.f
      recursive subroutine cgeqrt3( m, n, a, lda, t, ldt, info )
      integer   info, lda, m, n, ldt
      complex   a( lda, * ), t( ldt, * )
      complex   one
      parameter ( one = (1.0,0.0) )
      integer   i, i1, j, j1, n1, n2, iinfo
      end subroutine cgeqrt3

      !! cgeqrt.f
      subroutine cgeqrt( m, n, nb, a, lda, t, ldt, work, info )
      integer info, lda, ldt, m, n, nb
      complex a( lda, * ), t( ldt, * ), work( * )
      integer    i, ib, iinfo, k
      logical    use_recursive_qr
      parameter( use_recursive_qr=.true. )
      end subroutine cgeqrt

      !! cgerfs.f
      subroutine cgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, rwork, info )
      character          trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine cgerfs

      !! cgerfsx.f
      subroutine cgerfsx( trans, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          trans, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ), work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran
      integer            j, trans_type, prec_type, ref_type
      integer            n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, clange, cla_gercond_x, cla_gercond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine cgerfsx

      !! cgerq2.f
      subroutine cgerq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      integer            i, k
      complex            alpha
      end subroutine cgerq2

      !! cgerqf.f
      subroutine cgerqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine cgerqf

      !! cgesc2.f
      subroutine cgesc2( n, a, lda, rhs, ipiv, jpiv, scale )
      integer            lda, n
      real               scale
      integer            ipiv( * ), jpiv( * )
      complex            a( lda, * ), rhs( * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      integer            i, j
      real               bignum, eps, smlnum
      complex            temp
      integer            icamax
      real               slamch
      end subroutine cgesc2

      !! cgesdd.f
      subroutine cgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,
     &                   work, lwork, rwork, iwork, info )
      character          jobz
      integer            info, lda, ldu, ldvt, lwork, m, n
      integer            iwork( * )
      real               rwork( * ), s( * )
      complex            a( lda, * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      integer            lquerv
      parameter          ( lquerv = -1 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            wntqa, wntqas, wntqn, wntqo, wntqs
      integer            blk, chunk, i, ie, ierr, il, ir, iru, irvt,
     &                   iscl, itau, itaup, itauq, iu, ivt, ldwkvt,
     &                   ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk,
     &                   mnthr1, mnthr2, nrwork, nwork, wrkbl
      real               anrm, bignum, eps, smlnum
      integer            idum( 1 )
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      end subroutine cgesdd

      !! cgesvd.f
      subroutine cgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,
     &                   work, lwork, rwork, info )
      character          jobu, jobvt
      integer            info, lda, ldu, ldvt, lwork, m, n
      real               rwork( * ), s( * )
      complex            a( lda, * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, wntua, wntuas, wntun, wntuo, wntus,
     &                   wntva, wntvas, wntvn, wntvo, wntvs
      integer            blk, chunk, i, ie, ierr, ir, irwork, iscl,
     &                   itau, itaup, itauq, iu, iwork, ldwrkr, ldwrku,
     &                   maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru,
     &                   nrvt, wrkbl
      integer            lwork_cgeqrf, lwork_cungqr_n, lwork_cungqr_m,
     &                   lwork_cgebrd, lwork_cungbr_p, lwork_cungbr_q,
     &                   lwork_cgelqf, lwork_cunglq_n, lwork_cunglq_m
      real               anrm, bignum, eps, smlnum
      real               dum( 1 )
      complex            cdum( 1 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      end subroutine cgesvd

      !! cgesvdx.f
      subroutine cgesvdx( jobu, jobvt, range, m, n, a, lda, vl, vu,
     &                    il, iu, ns, s, u, ldu, vt, ldvt, work,
     &                    lwork, rwork, iwork, info )
      character          jobu, jobvt, range
      integer            il, info, iu, lda, ldu, ldvt, lwork, m, n, ns
      real               vl, vu
      integer            iwork( * )
      real               s( * ), rwork( * )
      complex            a( lda, * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      character          jobz, rngtgk
      logical            alls, inds, lquery, vals, wantu, wantvt
      integer            i, id, ie, ierr, ilqf, iltgk, iqrf, iscl,
     &                   itau, itaup, itauq, itemp, itgkz, iutgk,
     &                   j, k, maxwrk, minmn, minwrk, mnthr
      real               abstol, anrm, bignum, eps, smlnum
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, clange
      end subroutine cgesvdx

      !! cgesv.f
      subroutine cgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * )
      end subroutine cgesv

      !! cgesvj.f
      subroutine cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,
     &                   ldv, cwork, lwork, rwork, lrwork, info )
      integer            info, lda, ldv, lwork, lrwork, m, mv, n
      character(len=1)   joba, jobu, jobv
      complex            a( lda, * ),  v( ldv, * ), cwork( lwork )
      real               rwork( lrwork ), sva( n )
      real         zero,         half,         one
      parameter  ( zero = 0.0e0, half = 0.5e0, one = 1.0e0)
      complex      czero,                  cone
      parameter  ( czero = (0.0e0, 0.0e0), cone = (1.0e0, 0.0e0) )
      integer      nsweep
      parameter  ( nsweep = 30 )
      complex aapq, ompq
      real    aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big,
     &        bigtheta, cs, ctol, epsln, large, mxaapq,
     &        mxsinj, rootbig, rooteps, rootsfmin, roottol,
     &        skl, sfmin, small, sn, t, temp1, theta, thsign, tol
      integer blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &        iswrot, jbc, jgl, kbl, lkahead, mvl, n2, n34,
     &        n4, nbl, notrot, p, pskipped, q, rowskip, swband
      logical applv, goscale, lower, lsvec, noscale, rotok,
     &        rsvec, uctol, upper
      real                      scnrm2
      complex            cdotc
      integer            isamax
      real               slamch
      logical            lsame
      end subroutine cgesvj

      !! cgesvx.f
      subroutine cgesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                   equed, r, c, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, rwork, info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * )
      real               berr( * ), c( * ), ferr( * ), r( * ),
     &                   rwork( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j
      real               amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      real               clange, clantr, slamch
      end subroutine cgesvx

      !! cgesvxx.f
      subroutine cgesvxx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, r, c, b, ldb, x, ldx, rcond, rpvgrw,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, rwork,
     &                    info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, j
      real               amax, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, smlnum
      logical            lsame
      real               slamch, cla_gerpvgrw
      end subroutine cgesvxx

      !! cgetc2.f
      subroutine cgetc2( n, a, lda, ipiv, jpiv, info )
      integer            info, lda, n
      integer            ipiv( * ), jpiv( * )
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i, ip, ipv, j, jp, jpv
      real               bignum, eps, smin, smlnum, xmax
      real               slamch
      end subroutine cgetc2

      !! cgetf2.f
      subroutine cgetf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      complex            a( lda, * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      real               sfmin
      integer            i, j, jp
      real               slamch
      integer            icamax
      end subroutine cgetf2

      !! cgetrf2.f
      recursive subroutine cgetrf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      complex            a( lda, * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                     zero = ( 0.0e+0, 0.0e+0 ) )
      real               sfmin
      complex            temp
      integer            i, iinfo, n1, n2
      real               slamch
      integer            icamax
      end subroutine cgetrf2

      !! cgetrf.f
      subroutine cgetrf( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      complex            a( lda, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      integer            i, iinfo, j, jb, nb
      integer            ilaenv
      end subroutine cgetrf

      !! cgetri.f
      subroutine cgetri( n, a, lda, ipiv, work, lwork, info )
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, iws, j, jb, jj, jp, ldwork, lwkopt, nb,
     &                   nbmin, nn
      integer            ilaenv
      end subroutine cgetri

      !! cgetrs.f
      subroutine cgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          trans
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            notran
      logical            lsame
      end subroutine cgetrs

      !! cggbak.f
      subroutine cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,
     &                   ldv, info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      real               lscale( * ), rscale( * )
      complex            v( ldv, * )
      logical            leftv, rightv
      integer            i, k
      logical            lsame
      end subroutine cggbak

      !! cggbal.f
      subroutine cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,
     &                   rscale, work, info )
      character          job
      integer            ihi, ilo, info, lda, ldb, n
      real               lscale( * ), rscale( * ), work( * )
      complex            a( lda, * ), b( ldb, * )
      real               zero, half, one
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0 )
      real               three, sclfac
      parameter          ( three = 3.0e+0, sclfac = 1.0e+1 )
      complex            czero
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, icab, iflow, ip1, ir, irab, it, j, jc, jp1,
     &                   k, kount, l, lcab, lm1, lrab, lsfmax, lsfmin,
     &                   m, nr, nrp2
      real               alpha, basl, beta, cab, cmax, coef, coef2,
     &                   coef5, cor, ew, ewc, gamma, pgamma, rab, sfmax,
     &                   sfmin, sum, t, ta, tb, tc
      complex            cdum
      logical            lsame
      integer            icamax
      real               sdot, slamch
      real               cabs1
      end subroutine cggbal

      !! cgges3.f
      subroutine cgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,
     &                   ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr,
     &                   work, lwork, rwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      real               rwork( * )
      complex            a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, iright, irows, irwrk, itau, iwrk, lwkopt
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, smlnum
      integer            idum( 1 )
      real               dif( 2 )
      logical            lsame
      real               clange, slamch
      end subroutine cgges3

      !! cgges.f
      subroutine cgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,
     &                  sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work,
     &                  lwork, rwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      real               rwork( * )
      complex            a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, iright, irows, irwrk, itau, iwrk, lwkmin,
     &                   lwkopt
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, smlnum
      integer            idum( 1 )
      real               dif( 2 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      end subroutine cgges

      !! cggesx.f
      subroutine cggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,
     &                   b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr,
     &                   ldvsr, rconde, rcondv, work, lwork, rwork,
     &                   iwork, liwork, bwork, info )
      character          jobvsl, jobvsr, sense, sort
      integer            info, lda, ldb, ldvsl, ldvsr, liwork, lwork, n,
     &                   sdim
      logical            bwork( * )
      integer            iwork( * )
      real               rconde( 2 ), rcondv( 2 ), rwork( * )
      complex            a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, wantsb, wantse, wantsn, wantst, wantsv
      integer            i, icols, ierr, ihi, ijob, ijobvl, ijobvr,
     &                   ileft, ilo, iright, irows, irwrk, itau, iwrk,
     &                   liwmin, lwrk, maxwrk, minwrk
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps, pl,
     &                   pr, smlnum
      real               dif( 2 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      end subroutine cggesx

      !! cggev3.f
      subroutine cggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,
     &                   vl, ldvl, vr, ldvr, work, lwork, rwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      real               rwork( * )
      complex            a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, irwrk, itau, iwrk, jc, jr,
     &                   lwkopt
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      complex            x
      logical            ldumma( 1 )
      logical            lsame
      real               clange, slamch
      real               abs1
      end subroutine cggev3

      !! cggev.f
      subroutine cggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,
     &                  vl, ldvl, vr, ldvr, work, lwork, rwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      real               rwork( * )
      complex            a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, irwrk, itau, iwrk, jc, jr,
     &                   lwkmin, lwkopt
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      complex            x
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      real               abs1
      end subroutine cggev

      !! cggevx.f
      subroutine cggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,
     &                   alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi,
     &                   lscale, rscale, abnrm, bbnrm, rconde, rcondv,
     &                   work, lwork, rwork, iwork, bwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldb, ldvl, ldvr, lwork, n
      real               abnrm, bbnrm
      logical            bwork( * )
      integer            iwork( * )
      real               lscale( * ), rconde( * ), rcondv( * ),
     &                   rscale( * ), rwork( * )
      complex            a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl,
     &                   wantsb, wantse, wantsn, wantsv
      character          chtemp
      integer            i, icols, ierr, ijobvl, ijobvr, in, irows,
     &                   itau, iwrk, iwrk1, j, jc, jr, m, maxwrk, minwrk
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      complex            x
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      real               clange, slamch
      real               abs1
      end subroutine cggevx

      !! cggglm.f
      subroutine cggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      complex            a( lda, * ), b( ldb, * ), d( * ), work( * ),
     &                   x( * ), y( * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3,
     &                   nb4, np
      integer            ilaenv
      end subroutine cggglm

      !! cgghd3.f
      subroutine cgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, work, lwork, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n, lwork
      complex            a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * ), work( * )
      complex            cone, czero
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ),
     &                     czero = ( 0.0e+0, 0.0e+0 ) )
      logical            blk22, initq, initz, lquery, wantq, wantz
      character(len=1)   compq2, compz2
      integer            cola, i, ierr, j, j0, jcol, jj, jrow, k,
     &                   kacc22, len, lwkopt, n2nb, nb, nblst, nbmin,
     &                   nh, nnb, nx, ppw, ppwo, pw, top, topq
      real               c
      complex            c1, c2, ctemp, s, s1, s2, temp, temp1, temp2,
     &                   temp3
      logical            lsame
      integer            ilaenv
      end subroutine cgghd3

      !! cgghrd.f
      subroutine cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n
      complex            a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      complex            cone, czero
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ),
     &                   czero = ( 0.0e+0, 0.0e+0 ) )
      logical            ilq, ilz
      integer            icompq, icompz, jcol, jrow
      real               c
      complex            ctemp, s
      logical            lsame
      end subroutine cgghrd

      !! cgglse.f
      subroutine cgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      complex            a( lda, * ), b( ldb, * ), c( * ), d( * ),
     &                   work( * ), x( * )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3,
     &                   nb4, nr
      integer            ilaenv
      end subroutine cgglse

      !! cggqrf.f
      subroutine cggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      complex            a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine cggqrf

      !! cggrqf.f
      subroutine cggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      complex            a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine cggrqf

      !! cggsvd3.f
      subroutine cggsvd3( jobu, jobv, jobq, m, n, p, k, l, a, lda, b,
     &                    ldb, alpha, beta, u, ldu, v, ldv, q, ldq,
     &                    work, lwork, rwork, iwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      integer            iwork( * )
      real               alpha( * ), beta( * ), rwork( * )
      complex            a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   u( ldu, * ), v( ldv, * ), work( * )
      logical            wantq, wantu, wantv, lquery
      integer            i, ibnd, isub, j, ncycle, lwkopt
      real               anorm, bnorm, smax, temp, tola, tolb, ulp, unfl
      logical            lsame
      real               clange, slamch
      end subroutine cggsvd3

      !! cggsvp3.f
      subroutine cggsvp3( jobu, jobv, jobq, m, p, n, a, lda, b, ldb,
     &                    tola, tolb, k, l, u, ldu, v, ldv, q, ldq,
     &                    iwork, rwork, tau, work, lwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      real               tola, tolb
      integer            iwork( * )
      real               rwork( * )
      complex            a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   tau( * ), u( ldu, * ), v( ldv, * ), work( * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            forwrd, wantq, wantu, wantv, lquery
      integer            i, j, lwkopt
      complex            t
      logical            lsame
      end subroutine cggsvp3

      !! cgsvj0.f
      subroutine cgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,
     &                   sfmin, tol, nsweep, work, lwork, info )
      integer            info, lda, ldv, lwork, m, mv, n, nsweep
      real               eps, sfmin, tol
      character(len=1)   jobv
      complex            a( lda, * ), d( n ), v( ldv, * ), work( lwork )
      real               sva( n )
      real               zero, half, one
      parameter          ( zero = 0.0e0, half = 0.5e0, one = 1.0e0)
      complex      czero,                  cone
      parameter  ( czero = (0.0e0, 0.0e0), cone = (1.0e0, 0.0e0) )
      complex            aapq, ompq
      real               aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, mxaapq, mxsinj, rootbig, rooteps,
     &                   rootsfmin, roottol, small, sn, t, temp1, theta,
     &                   thsign
      integer            blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &                   iswrot, jbc, jgl, kbl, lkahead, mvl, nbl,
     &                   notrot, p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      real               scnrm2
      complex            cdotc
      integer            isamax
      logical            lsame
      end subroutine cgsvj0

      !! cgsvj1.f
      subroutine cgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,
     &                   eps, sfmin, tol, nsweep, work, lwork, info )
      real               eps, sfmin, tol
      integer            info, lda, ldv, lwork, m, mv, n, n1, nsweep
      character(len=1)   jobv
      complex            a( lda, * ), d( n ), v( ldv, * ), work( lwork )
      real               sva( n )
      real               zero, half, one
      parameter          ( zero = 0.0e0, half = 0.5e0, one = 1.0e0)
      complex            aapq, ompq
      real               aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, large, mxaapq, mxsinj, rootbig,
     &                   rooteps, rootsfmin, roottol, small, sn, t,
     &                   temp1, theta, thsign
      integer            blskip, emptsw, i, ibr, igl, ierr, ijblsk,
     &                   iswrot, jbc, jgl, kbl, mvl, notrot, nblc, nblr,
     &                   p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      real               scnrm2
      complex            cdotc
      integer            isamax
      logical            lsame
      end subroutine cgsvj1

      !! cgtcon.f
      subroutine cgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,
     &                   work, info )
      character          norm
      integer            info, n
      real               anorm, rcond
      integer            ipiv( * )
      complex            d( * ), dl( * ), du( * ), du2( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            onenrm
      integer            i, kase, kase1
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine cgtcon

      !! cgtrfs.f
      subroutine cgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, rwork,
     &                   info )
      character          trans
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            b( ldb, * ), d( * ), df( * ), dl( * ),
     &                   dlf( * ), du( * ), du2( * ), duf( * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine cgtrfs

      !! cgtsv.f
      subroutine cgtsv( n, nrhs, dl, d, du, b, ldb, info )
      integer            info, ldb, n, nrhs
      complex            b( ldb, * ), d( * ), dl( * ), du( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      integer            j, k
      complex            mult, temp, zdum
      real               cabs1
      end subroutine cgtsv

      !! cgtsvx.f
      subroutine cgtsvx( fact, trans, n, nrhs, dl, d, du, dlf, df, duf,
     &                   du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, rwork, info )
      character          fact, trans
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            b( ldb, * ), d( * ), df( * ), dl( * ),
     &                   dlf( * ), du( * ), du2( * ), duf( * ),
     &                   work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nofact, notran
      character          norm
      real               anorm
      logical            lsame
      real               clangt, slamch
      end subroutine cgtsvx

      !! cgttrf.f
      subroutine cgttrf( n, dl, d, du, du2, ipiv, info )
      integer            info, n
      integer            ipiv( * )
      complex            d( * ), dl( * ), du( * ), du2( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            i
      complex            fact, temp, zdum
      real               cabs1
      end subroutine cgttrf

      !! cgttrs.f
      subroutine cgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex            b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      logical            notran
      integer            itrans, j, jb, nb
      integer            ilaenv
      end subroutine cgttrs

      !! cgtts2.f
      subroutine cgtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
      integer            itrans, ldb, n, nrhs
      integer            ipiv( * )
      complex            b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      integer            i, j
      complex            temp
      end subroutine cgtts2

      !! chbevd.f
      subroutine chbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                   lwork, rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      real               rwork( * ), w( * )
      complex            ab( ldab, * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indwk2, indwrk, iscale,
     &                   liwmin, llrwk, llwk2, lrwmin, lwmin
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               clanhb, slamch
      end subroutine chbevd

      !! chbev.f
      subroutine chbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                  rwork, info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, n
      real               rwork( * ), w( * )
      complex            ab( ldab, * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lower, wantz
      integer            iinfo, imax, inde, indrwk, iscale
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               clanhb, slamch
      end subroutine chbev

      !! chbevx.f
      subroutine chbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,
     &                   vu, il, iu, abstol, m, w, z, ldz, work, rwork,
     &                   iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, kd, ldab, ldq, ldz, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               rwork( * ), w( * )
      complex            ab( ldab, * ), q( ldq, * ), work( * ),
     &                   z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      logical            alleig, indeig, lower, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwk, indrwk, indwrk, iscale, itmp1,
     &                   j, jj, nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      complex            ctmp1
      logical            lsame
      real               clanhb, slamch
      end subroutine chbevx

      !! chbgst.f
      subroutine chbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,
     &                   ldx, work, rwork, info )
      character          uplo, vect
      integer            info, ka, kb, ldab, ldbb, ldx, n
      real               rwork( * )
      complex            ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   x( ldx, * )
      complex            czero, cone
      real               one
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ), one = 1.0e+0 )
      logical            update, upper, wantx
      integer            i, i0, i1, i2, inca, j, j1, j1t, j2, j2t, k,
     &                   ka1, kb1, kbt, l, m, nr, nrt, nx
      real               bii
      complex            ra, ra1, t
      logical            lsame
      end subroutine chbgst

      !! chbgvd.f
      subroutine chbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,
     &                   z, ldz, work, lwork, rwork, lrwork, iwork,
     &                   liwork, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, liwork, lrwork,
     &                   lwork, n
      integer            iwork( * )
      real               rwork( * ), w( * )
      complex            ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   z( ldz, * )
      complex            cone, czero
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ),
     &                   czero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery, upper, wantz
      character          vect
      integer            iinfo, inde, indwk2, indwrk, liwmin, llrwk,
     &                   llwk2, lrwmin, lwmin
      logical            lsame
      end subroutine chbgvd

      !! chbgv.f
      subroutine chbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,
     &                  ldz, work, rwork, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, n
      real               rwork( * ), w( * )
      complex            ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   z( ldz, * )
      logical            upper, wantz
      character          vect
      integer            iinfo, inde, indwrk
      logical            lsame
      end subroutine chbgv

      !! chbgvx.f
      subroutine chbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,
     &                   ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z,
     &                   ldz, work, rwork, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, ka, kb, ldab, ldbb, ldq, ldz, m,
     &                   n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               rwork( * ), w( * )
      complex            ab( ldab, * ), bb( ldbb, * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            alleig, indeig, test, upper, valeig, wantz
      character          order, vect
      integer            i, iinfo, indd, inde, indee, indibl, indisp,
     &                   indiwk, indrwk, indwrk, itmp1, j, jj, nsplit
      real               tmp1
      logical            lsame
      end subroutine chbgvx

      !! chbtrd.f
      subroutine chbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,
     &                   work, info )
      character          uplo, vect
      integer            info, kd, ldab, ldq, n
      real               d( * ), e( * )
      complex            ab( ldab, * ), q( ldq, * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            initq, upper, wantq
      integer            i, i2, ibl, inca, incx, iqaend, iqb, iqend, j,
     &                   j1, j1end, j1inc, j2, jend, jin, jinc, k, kd1,
     &                   kdm1, kdn, l, last, lend, nq, nr, nrt
      real               abst
      complex            t, temp
      logical            lsame
      end subroutine chbtrd

      !! checon.f
      subroutine checon( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine checon

      !! checon_rook.f
      subroutine checon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                        info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine checon_rook

      !! cheequb.f
      subroutine cheequb( uplo, n, a, lda, s, scond, amax, work, info )
      integer            info, lda, n
      real               amax, scond
      character          uplo
      complex            a( lda, * ), work( * )
      real               s( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            max_iter
      parameter          ( max_iter = 100 )
      integer            i, j, iter
      real               avg, std, tol, c0, c1, c2, t, u, si, d,
     &                   base, smin, smax, smlnum, bignum, scale, sumsq
      logical            up
      complex            zdum
      real               slamch
      logical            lsame
      real               cabs1
      end subroutine cheequb

      !! cheevd.f
      subroutine cheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,
     &                   lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, lda, liwork, lrwork, lwork, n
      integer            iwork( * )
      real               rwork( * ), w( * )
      complex            a( lda, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            cone
      parameter          ( cone = ( 1.0e0, 0.0e0 ) )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indrwk, indtau, indwk2,
     &                   indwrk, iscale, liopt, liwmin, llrwk, llwork,
     &                   llwrk2, lopt, lropt, lrwmin, lwmin
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      real               clanhe, slamch
      end subroutine cheevd

      !! cheev.f
      subroutine cheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,
     &                  info )
      character          jobz, uplo
      integer            info, lda, lwork, n
      real               rwork( * ), w( * )
      complex            a( lda, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            cone
      parameter          ( cone = ( 1.0e0, 0.0e0 ) )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indtau, indwrk, iscale,
     &                   llwork, lwkopt, nb
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      real               clanhe, slamch
      end subroutine cheev

      !! cheevr.f
      subroutine cheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, isuppz, work, lwork,
     &                   rwork, lrwork, iwork, liwork, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, liwork, lrwork, lwork,
     &                   m, n
      real               abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      real               rwork( * ), w( * )
      complex            a( lda, * ), work( * ), z( ldz, * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      logical            alleig, indeig, lower, lquery, test, valeig,
     &                   wantz, tryrac
      character          order
      integer            i, ieeeok, iinfo, imax, indibl, indifl, indisp,
     &                   indiwo, indrd, indrdd, indre, indree, indrwk,
     &                   indtau, indwk, indwkn, iscale, itmp1, j, jj,
     &                   liwmin, llwork, llrwork, llwrkn, lrwmin,
     &                   lwkopt, lwmin, nb, nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      real               clansy, slamch
      end subroutine cheevr

      !! cheevx.f
      subroutine cheevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, lwork, rwork,
     &                   iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, lwork, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               rwork( * ), w( * )
      complex            a( lda, * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            alleig, indeig, lower, lquery, test, valeig,
     &                   wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwk, indrwk, indtau, indwrk, iscale,
     &                   itmp1, j, jj, llwork, lwkmin, lwkopt, nb,
     &                   nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      real               slamch, clanhe
      end subroutine cheevx

      !! chegs2.f
      subroutine chegs2( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      complex            a( lda, * ), b( ldb, * )
      real               one, half
      parameter          ( one = 1.0e+0, half = 0.5e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            k
      real               akk, bkk
      complex            ct
      logical            lsame
      end subroutine chegs2

      !! chegst.f
      subroutine chegst( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      complex            a( lda, * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      complex            cone, half
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ),
     &                   half = ( 0.5e+0, 0.0e+0 ) )
      logical            upper
      integer            k, kb, nb
      logical            lsame
      integer            ilaenv
      end subroutine chegst

      !! chegvd.f
      subroutine chegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                   lwork, rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, liwork, lrwork, lwork, n
      integer            iwork( * )
      real               rwork( * ), w( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery, upper, wantz
      character          trans
      integer            liopt, liwmin, lopt, lropt, lrwmin, lwmin
      logical            lsame
      end subroutine chegvd

      !! chegv.f
      subroutine chegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                  lwork, rwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, lwork, n
      real               rwork( * ), w( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery, upper, wantz
      character          trans
      integer            lwkopt, nb, neig
      logical            lsame
      integer            ilaenv
      end subroutine chegv

      !! chegvx.f
      subroutine chegvx( itype, jobz, range, uplo, n, a, lda, b, ldb,
     &                   vl, vu, il, iu, abstol, m, w, z, ldz, work,
     &                   lwork, rwork, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, lda, ldb, ldz, lwork, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               rwork( * ), w( * )
      complex            a( lda, * ), b( ldb, * ), work( * ),
     &                   z( ldz, * )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            alleig, indeig, lquery, upper, valeig, wantz
      character          trans
      integer            lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine chegvx

      !! cherfs.f
      subroutine cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine cherfs

      !! cherfsx.f
      subroutine cherfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    s, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, clanhe, cla_hercond_x, cla_hercond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine cherfsx

      !! chesv.f
      subroutine chesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine chesv

      !! chesv_rook.f
      subroutine chesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                       lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine chesv_rook

      !! chesvx.f
      subroutine chesvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,
     &                   ldb, x, ldx, rcond, ferr, berr, work, lwork,
     &                   rwork, info )
      character          fact, uplo
      integer            info, lda, ldaf, ldb, ldx, lwork, n, nrhs
      real               rcond
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery, nofact
      integer            lwkopt, nb
      real               anorm
      logical            lsame
      integer            ilaenv
      real               clanhe, slamch
      end subroutine chesvx

      !! chesvxx.f
      subroutine chesvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      real               amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      real               slamch, cla_herpvgrw
      end subroutine chesvxx

      !! cheswapr.f
      subroutine cheswapr( uplo, n, a, lda, i1, i2)
      character        uplo
      integer          i1, i2, lda, n
      complex          a( lda, n )
      logical            upper
      integer            i
      complex            tmp
      logical            lsame
      end subroutine cheswapr

      !! chetd2.f
      subroutine chetd2( uplo, n, a, lda, d, e, tau, info )
      character          uplo
      integer            info, lda, n
      real               d( * ), e( * )
      complex            a( lda, * ), tau( * )
      complex            one, zero, half
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ),
     &                   half = ( 0.5e+0, 0.0e+0 ) )
      logical            upper
      integer            i
      complex            alpha, taui
      logical            lsame
      complex            cdotc
      end subroutine chetd2

      !! chetf2.f
      subroutine chetf2( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kk, kp, kstep
      real               absakk, alpha, colmax, d, d11, d22, r1, rowmax,
     &                   tt
      complex            d12, d21, t, wk, wkm1, wkp1, zdum
      logical            lsame, sisnan
      integer            icamax
      real               slapy2
      real               cabs1
      end subroutine chetf2

      !! chetf2_rook.f
      subroutine chetf2_rook( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            done, upper
      integer            i, ii, imax, itemp, j, jmax, k, kk, kp, kstep,
     &                   p
      real               absakk, alpha, colmax, d, d11, d22, r1, stemp,
     &                   rowmax, tt, sfmin
      complex            d12, d21, t, wk, wkm1, wkp1, z
      logical            lsame
      integer            icamax
      real               slamch, slapy2
      real   cabs1
      end subroutine chetf2_rook

      !! chetrd.f
      subroutine chetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      real               d( * ), e( * )
      complex            a( lda, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery, upper
      integer            i, iinfo, iws, j, kk, ldwork, lwkopt, nb,
     &                   nbmin, nx
      logical            lsame
      integer            ilaenv
      end subroutine chetrd

      !! chetrf.f
      subroutine chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine chetrf

      !! chetrf_rook.f
      subroutine chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine chetrf_rook

      !! chetri2.f
      subroutine chetri2( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      logical            upper, lquery
      integer            minsize, nbmax
      logical            lsame
      integer            ilaenv
      end subroutine chetri2

      !! chetri2x.f
      subroutine chetri2x( uplo, n, a, lda, ipiv, work, nb, info )
      character          uplo
      integer            info, lda, n, nb
      integer            ipiv( * )
      complex            a( lda, * ), work( n+nb+1,* )
      real               one
      complex            cone, zero
      parameter          ( one = 1.0e+0,
     &                   cone = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i, iinfo, ip, k, cut, nnb
      integer            count
      integer            j, u11, invd
      complex   ak, akkp1, akp1, d, t
      complex   u01_i_j, u01_ip1_j
      complex   u11_i_j, u11_ip1_j
      logical            lsame
      end subroutine chetri2x

      !! chetri.f
      subroutine chetri( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      real               one
      complex            cone, zero
      parameter          ( one = 1.0e+0, cone = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kp, kstep
      real               ak, akp1, d, t
      complex            akkp1, temp
      logical            lsame
      complex            cdotc
      end subroutine chetri

      !! chetri_rook.f
      subroutine chetri_rook( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      real               one
      complex            cone, czero
      parameter          ( one = 1.0e+0, cone = ( 1.0e+0, 0.0e+0 ),
     &                   czero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kp, kstep
      real               ak, akp1, d, t
      complex            akkp1, temp
      logical            lsame
      complex            cdotc
      end subroutine chetri_rook

      !! chetrs2.f
      subroutine chetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                    work, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      complex            one
      parameter          ( one = (1.0e+0,0.0e+0) )
      logical            upper
      integer            i, iinfo, j, k, kp
      real               s
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine chetrs2

      !! chetrs.f
      subroutine chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kp
      real               s
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine chetrs

      !! chetrs_rook.f
      subroutine chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                        info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kp
      real               s
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine chetrs_rook

      !! chfrk.f
      subroutine chfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,
     &                  c )
      real               alpha, beta
      integer            k, lda, n
      character          trans, transr, uplo
      complex            a( lda, * ), c( * )
      real               one, zero
      complex            czero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ) )
      logical            lower, normaltransr, nisodd, notrans
      integer            info, nrowa, j, nk, n1, n2
      complex            calpha, cbeta
      logical            lsame
      end subroutine chfrk

      !! chgeqz.f
      subroutine chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,
     &                   alpha, beta, q, ldq, z, ldz, work, lwork,
     &                   rwork, info )
      character          compq, compz, job
      integer            ihi, ilo, info, ldh, ldq, ldt, ldz, lwork, n
      real               rwork( * )
      complex            alpha( * ), beta( * ), h( ldh, * ),
     &                   q( ldq, * ), t( ldt, * ), work( * ),
     &                   z( ldz, * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               half
      parameter          ( half = 0.5e+0 )
      logical            ilazr2, ilazro, ilq, ilschr, ilz, lquery
      integer            icompq, icompz, ifirst, ifrstm, iiter, ilast,
     &                   ilastm, in, ischur, istart, j, jc, jch, jiter,
     &                   jr, maxit
      real               absb, anorm, ascale, atol, bnorm, bscale, btol,
     &                   c, safmin, temp, temp2, tempr, ulp
      complex            abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2,
     &                   ctemp3, eshift, rtdisc, s, shift, signbc, t1,
     &                   u12, x
      logical            lsame
      real               clanhs, slamch
      real               abs1
      end subroutine chgeqz

      !! chla_transtype.f
      character(len=1) function chla_transtype( trans )
      integer            trans
      integer blas_no_trans, blas_trans, blas_conj_trans
      parameter ( blas_no_trans = 111, blas_trans = 112,
     &     blas_conj_trans = 113 )
      end function chla_transtype

      !! chpcon.f
      subroutine chpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
      character          uplo
      integer            info, n
      real               anorm, rcond
      integer            ipiv( * )
      complex            ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, ip, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine chpcon

      !! chpevd.f
      subroutine chpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,
     &                   rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      real               rwork( * ), w( * )
      complex            ap( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery, wantz
      integer            iinfo, imax, inde, indrwk, indtau, indwrk,
     &                   iscale, liwmin, llrwk, llwrk, lrwmin, lwmin
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               clanhp, slamch
      end subroutine chpevd

      !! chpev.f
      subroutine chpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,
     &                  info )
      character          jobz, uplo
      integer            info, ldz, n
      real               rwork( * ), w( * )
      complex            ap( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            wantz
      integer            iinfo, imax, inde, indrwk, indtau, indwrk,
     &                   iscale
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               clanhp, slamch
      end subroutine chpev

      !! chpevx.f
      subroutine chpevx( jobz, range, uplo, n, ap, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, rwork, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, ldz, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               rwork( * ), w( * )
      complex            ap( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            cone
      parameter          ( cone = ( 1.0e0, 0.0e0 ) )
      logical            alleig, indeig, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwk, indrwk, indtau, indwrk, iscale,
     &                   itmp1, j, jj, nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      real               clanhp, slamch
      end subroutine chpevx

      !! chpgst.f
      subroutine chpgst( itype, uplo, n, ap, bp, info )
      character          uplo
      integer            info, itype, n
      complex            ap( * ), bp( * )
      real               one, half
      parameter          ( one = 1.0e+0, half = 0.5e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, j1, j1j1, jj, k, k1, k1k1, kk
      real               ajj, akk, bjj, bkk
      complex            ct
      logical            lsame
      complex            cdotc
      end subroutine chpgst

      !! chpgvd.f
      subroutine chpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                   lwork, rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      real               rwork( * ), w( * )
      complex            ap( * ), bp( * ), work( * ), z( ldz, * )
      logical            lquery, upper, wantz
      character          trans
      integer            j, liwmin, lrwmin, lwmin, neig
      logical            lsame
      end subroutine chpgvd

      !! chpgv.f
      subroutine chpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                  rwork, info )
      character          jobz, uplo
      integer            info, itype, ldz, n
      real               rwork( * ), w( * )
      complex            ap( * ), bp( * ), work( * ), z( ldz, * )
      logical            upper, wantz
      character          trans
      integer            j, neig
      logical            lsame
      end subroutine chpgv

      !! chpgvx.f
      subroutine chpgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,
     &                   il, iu, abstol, m, w, z, ldz, work, rwork,
     &                   iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, ldz, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               rwork( * ), w( * )
      complex            ap( * ), bp( * ), work( * ), z( ldz, * )
      logical            alleig, indeig, upper, valeig, wantz
      character          trans
      integer            j
      logical            lsame
      end subroutine chpgvx

      !! chprfs.f
      subroutine chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine chprfs

      !! chpsv.f
      subroutine chpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex            ap( * ), b( ldb, * )
      logical            lsame
      end subroutine chpsv

      !! chpsvx.f
      subroutine chpsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,
     &                   ldx, rcond, ferr, berr, work, rwork, info )
      character          fact, uplo
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nofact
      real               anorm
      logical            lsame
      real               clanhp, slamch
      end subroutine chpsvx

      !! chptrd.f
      subroutine chptrd( uplo, n, ap, d, e, tau, info )
      character          uplo
      integer            info, n
      real               d( * ), e( * )
      complex            ap( * ), tau( * )
      complex            one, zero, half
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ),
     &                   half = ( 0.5e+0, 0.0e+0 ) )
      logical            upper
      integer            i, i1, i1i1, ii
      complex            alpha, taui
      logical            lsame
      complex            cdotc
      end subroutine chptrd

      !! chptrf.f
      subroutine chptrf( uplo, n, ap, ipiv, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex            ap( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kc, kk, knc, kp, kpc,
     &                   kstep, kx, npp
      real               absakk, alpha, colmax, d, d11, d22, r1, rowmax,
     &                   tt
      complex            d12, d21, t, wk, wkm1, wkp1, zdum
      logical            lsame
      integer            icamax
      real               slapy2
      real               cabs1
      end subroutine chptrf

      !! chptri.f
      subroutine chptri( uplo, n, ap, ipiv, work, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex            ap( * ), work( * )
      real               one
      complex            cone, zero
      parameter          ( one = 1.0e+0, cone = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kc, kcnext, kp, kpc, kstep, kx, npp
      real               ak, akp1, d, t
      complex            akkp1, temp
      logical            lsame
      complex            cdotc
      end subroutine chptri

      !! chptrs.f
      subroutine chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex            ap( * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kc, kp
      real               s
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine chptrs

      !! chsein.f
      subroutine chsein( side, eigsrc, initv, select, n, h, ldh, w, vl,
     &                   ldvl, vr, ldvr, mm, m, work, rwork, ifaill,
     &                   ifailr, info )
      character          eigsrc, initv, side
      integer            info, ldh, ldvl, ldvr, m, mm, n
      logical            select( * )
      integer            ifaill( * ), ifailr( * )
      real               rwork( * )
      complex            h( ldh, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   w( * ), work( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      real               rzero
      parameter          ( rzero = 0.0e+0 )
      logical            bothv, fromqr, leftv, noinit, rightv
      integer            i, iinfo, k, kl, kln, kr, ks, ldwork
      real               eps3, hnorm, smlnum, ulp, unfl
      complex            cdum, wk
      logical            lsame, sisnan
      real               clanhs, slamch
      real               cabs1
      end subroutine chsein

      !! chseqr.f
      subroutine chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,
     &                   work, lwork, info )
      integer            ihi, ilo, info, ldh, ldz, lwork, n
      character          compz, job
      complex            h( ldh, * ), w( * ), work( * ), z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            nl
      parameter          ( nl = 49 )
      complex            zero, one
      parameter          ( zero = ( 0.0e0, 0.0e0 ),
     &                   one = ( 1.0e0, 0.0e0 ) )
      real               rzero
      parameter          ( rzero = 0.0e0 )
      complex            hl( nl, nl ), workl( nl )
      integer            kbot, nmin
      logical            initz, lquery, wantt, wantz
      integer            ilaenv
      logical            lsame
      end subroutine chseqr

      !! clabrd.f
      subroutine clabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,
     &                   ldy )
      integer            lda, ldx, ldy, m, n, nb
      real               d( * ), e( * )
      complex            a( lda, * ), taup( * ), tauq( * ), x( ldx, * ),
     &                   y( ldy, * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      integer            i
      complex            alpha
      end subroutine clabrd

      !! clacgv.f
      subroutine clacgv( n, x, incx )
      integer            incx, n
      complex            x( * )
      integer            i, ioff
      end subroutine clacgv

      !! clacn2.f
      subroutine clacn2( n, v, x, est, kase, isave )
      integer            kase, n
      real               est
      integer            isave( 3 )
      complex            v( * ), x( * )
      integer              itmax
      parameter          ( itmax = 5 )
      real                 one,         two
      parameter          ( one = 1.0e0, two = 2.0e0 )
      complex              czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                            cone = ( 1.0e0, 0.0e0 ) )
      integer            i, jlast
      real               absxi, altsgn, estold, safmin, temp
      integer            icmax1
      real               scsum1, slamch
      end subroutine clacn2

      !! clacon.f
      subroutine clacon( n, v, x, est, kase )
      integer            kase, n
      real               est
      complex            v( n ), x( n )
      integer            itmax
      parameter          ( itmax = 5 )
      real               one, two
      parameter          ( one = 1.0e0, two = 2.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      integer            i, iter, j, jlast, jump
      real               absxi, altsgn, estold, safmin, temp
      integer            icmax1
      real               scsum1, slamch
      end subroutine clacon

      !! clacp2.f
      subroutine clacp2( uplo, m, n, a, lda, b, ldb )
      character          uplo
      integer            lda, ldb, m, n
      real               a( lda, * )
      complex            b( ldb, * )
      integer            i, j
      logical            lsame
      end subroutine clacp2

      !! clacpy.f
      subroutine clacpy( uplo, m, n, a, lda, b, ldb )
      character          uplo
      integer            lda, ldb, m, n
      complex            a( lda, * ), b( ldb, * )
      integer            i, j
      logical            lsame
      end subroutine clacpy

      !! clacrm.f
      subroutine clacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
      integer            lda, ldb, ldc, m, n
      real               b( ldb, * ), rwork( * )
      complex            a( lda, * ), c( ldc, * )
      real               one, zero
      parameter          ( one = 1.0e0, zero = 0.0e0 )
      integer            i, j, l
      end subroutine clacrm

      !! clacrt.f
      subroutine clacrt( n, cx, incx, cy, incy, c, s )
      integer            incx, incy, n
      complex            c, s
      complex            cx( * ), cy( * )
      integer            i, ix, iy
      complex            ctemp
      end subroutine clacrt

      !! cladiv.f
      complex function cladiv( x, y )
      complex            x, y
      real               zi, zr
      end function cladiv

      !! claed0.f
      subroutine claed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,
     &                   iwork, info )
      integer            info, ldq, ldqs, n, qsiz
      integer            iwork( * )
      real               d( * ), e( * ), rwork( * )
      complex            q( ldq, * ), qstore( ldqs, * )
      real               two
      parameter          ( two = 2.e+0 )
      integer            curlvl, curprb, curr, i, igivcl, igivnm,
     &                   igivpt, indxq, iperm, iprmpt, iq, iqptr, iwrem,
     &                   j, k, lgn, ll, matsiz, msd2, smlsiz, smm1,
     &                   spm1, spm2, submat, subpbs, tlvls
      real               temp
      integer            ilaenv
      end subroutine claed0

      !! claed7.f
      subroutine claed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,
     &                   ldq, rho, indxq, qstore, qptr, prmptr, perm,
     &                   givptr, givcol, givnum, work, rwork, iwork,
     &                   info )
      integer            curlvl, curpbm, cutpnt, info, ldq, n, qsiz,
     &                   tlvls
      real               rho
      integer            givcol( 2, * ), givptr( * ), indxq( * ),
     &                   iwork( * ), perm( * ), prmptr( * ), qptr( * )
      real               d( * ), givnum( 2, * ), qstore( * ), rwork( * )
      complex            q( ldq, * ), work( * )
      integer            coltyp, curr, i, idlmda, indx,
     &                   indxc, indxp, iq, iw, iz, k, n1, n2, ptr
      end subroutine claed7

      !! claed8.f
      subroutine claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,
     &                   q2, ldq2, w, indxp, indx, indxq, perm, givptr,
     &                   givcol, givnum, info )
      integer            cutpnt, givptr, info, k, ldq, ldq2, n, qsiz
      real               rho
      integer            givcol( 2, * ), indx( * ), indxp( * ),
     &                   indxq( * ), perm( * )
      real               d( * ), dlamda( * ), givnum( 2, * ), w( * ),
     &                   z( * )
      complex            q( ldq, * ), q2( ldq2, * )
      real               mone, zero, one, two, eight
      parameter          ( mone = -1.0e0, zero = 0.0e0, one = 1.0e0,
     &                   two = 2.0e0, eight = 8.0e0 )
      integer            i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
      real               c, eps, s, t, tau, tol
      integer            isamax
      real               slamch, slapy2
      end subroutine claed8

      !! claein.f
      subroutine claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,
     &                   eps3, smlnum, info )
      logical            noinit, rightv
      integer            info, ldb, ldh, n
      real               eps3, smlnum
      complex            w
      real               rwork( * )
      complex            b( ldb, * ), h( ldh, * ), v( * )
      real               one, tenth
      parameter          ( one = 1.0e+0, tenth = 1.0e-1 )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      character          normin, trans
      integer            i, ierr, its, j
      real               growto, nrmsml, rootn, rtemp, scale, vnorm
      complex            cdum, ei, ej, temp, x
      integer            icamax
      real               scasum, scnrm2
      complex            cladiv
      real               cabs1
      end subroutine claein

      !! claesy.f
      subroutine claesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
      complex            a, b, c, cs1, evscal, rt1, rt2, sn1
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      complex            cone
      parameter          ( cone = ( 1.0e0, 0.0e0 ) )
      real               half
      parameter          ( half = 0.5e0 )
      real               thresh
      parameter          ( thresh = 0.1e0 )
      real               babs, evnorm, tabs, z
      complex            s, t, tmp
      end subroutine claesy

      !! claev2.f
      subroutine claev2( a, b, c, rt1, rt2, cs1, sn1 )
      real               cs1, rt1, rt2
      complex            a, b, c, sn1
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               t
      complex            w
      end subroutine claev2

      !! clag2z.f
      subroutine clag2z( m, n, sa, ldsa, a, lda, info )
      integer            info, lda, ldsa, m, n
      complex            sa( ldsa, * )
      complex(kind=16)   a( lda, * )
      integer            i, j
      end subroutine clag2z

      !! cla_gbamv.f
      subroutine cla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,
     &                      incx, beta, y, incy )
      real               alpha, beta
      integer            incx, incy, ldab, m, n, kl, ku, trans
      complex            ab( ldab, * ), x( * )
      real               y( * )
      complex            one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            symb_zero
      real               temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny, kd, ke
      complex            cdum
      real               slamch
      integer            ilatrans
      real               cabs1
      end subroutine cla_gbamv

      !! cla_gbrcond_c.f
      real function cla_gbrcond_c( trans, n, kl, ku, ab, ldab, afb,
     &                             ldafb, ipiv, c, capply, info, work,
     &                             rwork )
      character          trans
      logical            capply
      integer            n, kl, ku, kd, ke, ldab, ldafb, info
      integer            ipiv( * )
      complex            ab( ldab, * ), afb( ldafb, * ), work( * )
      real               c( * ), rwork( * )
      logical            notrans
      integer            kase, i, j
      real               ainvnm, anorm, tmp
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               cabs1
      end function cla_gbrcond_c

      !! cla_gbrcond_x.f
      real function cla_gbrcond_x( trans, n, kl, ku, ab, ldab, afb,
     &                             ldafb, ipiv, x, info, work, rwork )
      character          trans
      integer            n, kl, ku, kd, ke, ldab, ldafb, info
      integer            ipiv( * )
      complex            ab( ldab, * ), afb( ldafb, * ), work( * ),
     &                   x( * )
      real               rwork( * )
      logical            notrans
      integer            kase, i, j
      real               ainvnm, anorm, tmp
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               cabs1
      end function cla_gbrcond_x

      !! cla_gbrfsx_extended.f
      subroutine cla_gbrfsx_extended ( prec_type, trans_type, n, kl, ku,
     &                                nrhs, ab, ldab, afb, ldafb, ipiv,
     &                                colequ, c, b, ldb, y, ldy,
     &                                berr_out, n_norms, err_bnds_norm,
     &                                err_bnds_comp, res, ayb, dy,
     &                                y_tail, rcond, ithresh, rthresh,
     &                                dz_ub, ignore_cwise, info )
      integer            info, ldab, ldafb, ldb, ldy, n, kl, ku, nrhs,
     &                   prec_type, trans_type, n_norms, ithresh
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      integer            ipiv( * )
      complex            ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb(*), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      character          trans
      integer            cnt, i, j, m, x_state, z_state, y_prec_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      complex            zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      real               slamch
      character          chla_transtype
      real               cabs1
      end subroutine cla_gbrfsx_extended

      !! cla_gbrpvgrw.f
      real function cla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,
     &                            ldafb )
      integer            n, kl, ku, ncols, ldab, ldafb
      complex            ab( ldab, * ), afb( ldafb, * )
      integer            i, j, kd
      real               amax, umax, rpvgrw
      complex            zdum
      real               cabs1
      end function cla_gbrpvgrw

      !! cla_geamv.f
      subroutine cla_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,
     &                       y, incy )
      real               alpha, beta
      integer            incx, incy, lda, m, n
      integer            trans
      complex            a( lda, * ), x( * )
      real               y( * )
      complex            one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            symb_zero
      real               temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny
      complex            cdum
      real               slamch
      integer            ilatrans
      real               cabs1
      end subroutine cla_geamv

      !! cla_gercond_c.f
      real function cla_gercond_c( trans, n, a, lda, af, ldaf, ipiv, c,
     &                             capply, info, work, rwork )
      character          trans
      logical            capply
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), work( * )
      real               c( * ), rwork( * )
      logical            notrans
      integer            kase, i, j
      real               ainvnm, anorm, tmp
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               cabs1
      end function cla_gercond_c

      !! cla_gercond_x.f
      real function cla_gercond_x( trans, n, a, lda, af, ldaf, ipiv, x,
     &                             info, work, rwork )
      character          trans
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), work( * ), x( * )
      real               rwork( * )
      logical            notrans
      integer            kase
      real               ainvnm, anorm, tmp
      integer            i, j
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               cabs1
      end function cla_gercond_x

      !! cla_gerfsx_extended.f
      subroutine cla_gerfsx_extended( prec_type, trans_type, n, nrhs, a,
     &                                lda, af, ldaf, ipiv, colequ, c, b,
     &                                ldb, y, ldy, berr_out, n_norms,
     &                                errs_n, errs_c, res, ayb, dy,
     &                                y_tail, rcond, ithresh, rthresh,
     &                                dz_ub, ignore_cwise, info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   trans_type, n_norms
      logical            colequ, ignore_cwise
      integer            ithresh
      real               rthresh, dz_ub
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb( * ), rcond, berr_out( * ),
     &                   errs_n( nrhs, * ), errs_c( nrhs, * )
      character          trans
      integer            cnt, i, j,  x_state, z_state, y_prec_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      complex            zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2,
     &                   noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      real               slamch
      character          chla_transtype
      real               cabs1
      end subroutine cla_gerfsx_extended

      !! cla_gerpvgrw.f
      real function cla_gerpvgrw( n, ncols, a, lda, af, ldaf )
      integer            n, ncols, lda, ldaf
      complex            a( lda, * ), af( ldaf, * )
      integer            i, j
      real               amax, umax, rpvgrw
      complex            zdum
      real               cabs1
      end function cla_gerpvgrw

      !! clags2.f
      subroutine clags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,
     &                   snv, csq, snq )
      logical            upper
      real               a1, a3, b1, b3, csq, csu, csv
      complex            a2, b2, snq, snu, snv
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               a, aua11, aua12, aua21, aua22, avb11, avb12,
     &                   avb21, avb22, csl, csr, d, fb, fc, s1, s2, snl,
     &                   snr, ua11r, ua22r, vb11r, vb22r
      complex            b, c, d1, r, t, ua11, ua12, ua21, ua22, vb11,
     &                   vb12, vb21, vb22
      real               abs1
      end subroutine clags2

      !! clagtm.f
      subroutine clagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,
     &                   b, ldb )
      character          trans
      integer            ldb, ldx, n, nrhs
      real               alpha, beta
      complex            b( ldb, * ), d( * ), dl( * ), du( * ),
     &                   x( ldx, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      logical            lsame
      end subroutine clagtm

      !! cla_heamv.f
      subroutine cla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,
     &                      incy )
      real               alpha, beta
      integer            incx, incy, lda, n, uplo
      complex            a( lda, * ), x( * )
      real               y( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            symb_zero
      real               temp, safe1
      integer            i, info, iy, j, jx, kx, ky
      complex            zdum
      real               slamch
      integer            ilauplo
      real               cabs1
      end subroutine cla_heamv

      !! clahef.f
      subroutine clahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex            a( lda, * ), w( ldw, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      integer            imax, j, jb, jj, jmax, jp, k, kk, kkw, kp,
     &                   kstep, kw
      real               absakk, alpha, colmax, r1, rowmax, t
      complex            d11, d21, d22, z
      logical            lsame
      integer            icamax
      real               cabs1
      end subroutine clahef

      !! clahef_rook.f
      subroutine clahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,
     &                        info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex            a( lda, * ), w( ldw, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            done
      integer            imax, itemp, ii, j, jb, jj, jmax, jp1, jp2, k,
     &                   kk, kkw, kp, kstep, kw, p
      real               absakk, alpha, colmax, stemp, r1, rowmax, t,
     &                   sfmin
      complex            d11, d21, d22, z
      logical            lsame
      integer            icamax
      real               slamch
      real               cabs1
      end subroutine clahef_rook

      !! cla_hercond_c.f
      real function cla_hercond_c( uplo, n, a, lda, af, ldaf, ipiv, c,
     &                             capply, info, work, rwork )
      character          uplo
      logical            capply
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), work( * )
      real               c ( * ), rwork( * )
      integer            kase, i, j
      real               ainvnm, anorm, tmp
      logical            up, upper
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               cabs1
      end function cla_hercond_c

      !! cla_hercond_x.f
      real function cla_hercond_x( uplo, n, a, lda, af, ldaf, ipiv, x,
     &                             info, work, rwork )
      character          uplo
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), work( * ), x( * )
      real               rwork( * )
      integer            kase, i, j
      real               ainvnm, anorm, tmp
      logical            up, upper
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real cabs1
      end function cla_hercond_x

      !! cla_herfsx_extended.f
      subroutine cla_herfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, ipiv, colequ, c, b, ldb,
     &                                y, ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state,
     &                   y_prec_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec, upper
      complex            zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      real               slamch
      real               cabs1
      end subroutine cla_herfsx_extended

      !! cla_herpvgrw.f
      real function cla_herpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,
     &                            work )
      character(len=1)   uplo
      integer            n, info, lda, ldaf
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * )
      real               work( * )
      integer            ncols, i, j, k, kp
      real               amax, umax, rpvgrw, tmp
      logical            upper, lsame
      complex            zdum
      real               cabs1
      end function cla_herpvgrw

      !! clahqr.f
      subroutine clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,
     &                   ihiz, z, ldz, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, n
      logical            wantt, wantz
      complex            h( ldh, * ), w( * ), z( ldz, * )
      complex            zero, one
      parameter          ( zero = ( 0.0e0, 0.0e0 ),
     &                   one = ( 1.0e0, 0.0e0 ) )
      real               rzero, rone, half
      parameter          ( rzero = 0.0e0, rone = 1.0e0, half = 0.5e0 )
      real               dat1
      parameter          ( dat1 = 3.0e0 / 4.0e0 )
      complex            cdum, h11, h11s, h22, sc, sum, t, t1, temp, u,
     &                   v2, x, y
      real               aa, ab, ba, bb, h10, h21, rtemp, s, safmax,
     &                   safmin, smlnum, sx, t2, tst, ulp
      integer            i, i1, i2, its, itmax, j, jhi, jlo, k, l, m,
     &                   nh, nz
      complex            v( 2 )
      complex            cladiv
      real               slamch
      real               cabs1
      end subroutine clahqr

      !! clahr2.f
      subroutine clahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
      integer            k, lda, ldt, ldy, n, nb
      complex            a( lda, * ), t( ldt, nb ), tau( nb ),
     &                   y( ldy, nb )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                     one = ( 1.0e+0, 0.0e+0 ) )
      integer            i
      complex            ei
      end subroutine clahr2

      !! claic1.f
      subroutine claic1( job, j, x, sest, w, gamma, sestpr, s, c )
      integer            j, job
      real               sest, sestpr
      complex            c, gamma, s
      complex            w( j ), x( j )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      real               half, four
      parameter          ( half = 0.5e0, four = 4.0e0 )
      real               absalp, absest, absgam, b, eps, norma, s1, s2,
     &                   scl, t, test, tmp, zeta1, zeta2
      complex            alpha, cosine, sine
      real               slamch
      complex            cdotc
      end subroutine claic1

      !! cla_lin_berr.f
      subroutine cla_lin_berr ( n, nz, nrhs, res, ayb, berr )
      integer            n, nz, nrhs
      real               ayb( n, nrhs ), berr( nrhs )
      complex            res( n, nrhs )
      real               tmp
      integer            i, j
      complex            cdum
      real               slamch
      real               safe1
      complex            cabs1
      end subroutine cla_lin_berr

      !! clals0.f
      subroutine clals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,
     &                   perm, givptr, givcol, ldgcol, givnum, ldgnum,
     &                   poles, difl, difr, z, k, c, s, rwork, info )
      integer            givptr, icompq, info, k, ldb, ldbx, ldgcol,
     &                   ldgnum, nl, nr, nrhs, sqre
      real               c, s
      integer            givcol( ldgcol, * ), perm( * )
      real               difl( * ), difr( ldgnum, * ),
     &                   givnum( ldgnum, * ), poles( ldgnum, * ),
     &                   rwork( * ), z( * )
      complex            b( ldb, * ), bx( ldbx, * )
      real               one, zero, negone
      parameter          ( one = 1.0e0, zero = 0.0e0, negone = -1.0e0 )
      integer            i, j, jcol, jrow, m, n, nlp1
      real               diflj, difrj, dj, dsigj, dsigjp, temp
      real               slamc3, snrm2
      end subroutine clals0

      !! clalsa.f
      subroutine clalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,
     &                   ldu, vt, k, difl, difr, z, poles, givptr,
     &                   givcol, ldgcol, perm, givnum, c, s, rwork,
     &                   iwork, info )
      integer            icompq, info, ldb, ldbx, ldgcol, ldu, n, nrhs,
     &                   smlsiz
      integer            givcol( ldgcol, * ), givptr( * ), iwork( * ),
     &                   k( * ), perm( ldgcol, * )
      real               c( * ), difl( ldu, * ), difr( ldu, * ),
     &                   givnum( ldu, * ), poles( ldu, * ), rwork( * ),
     &                   s( * ), u( ldu, * ), vt( ldu, * ), z( ldu, * )
      complex            b( ldb, * ), bx( ldbx, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      integer            i, i1, ic, im1, inode, j, jcol, jimag, jreal,
     &                   jrow, lf, ll, lvl, lvl2, nd, ndb1, ndiml,
     &                   ndimr, nl, nlf, nlp1, nlvl, nr, nrf, nrp1, sqre
      end subroutine clalsa

      !! clalsd.f
      subroutine clalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,
     &                   rank, work, rwork, iwork, info )
      character          uplo
      integer            info, ldb, n, nrhs, rank, smlsiz
      real               rcond
      integer            iwork( * )
      real               d( * ), e( * ), rwork( * )
      complex            b( ldb, * ), work( * )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      complex            czero
      parameter          ( czero = ( 0.0e0, 0.0e0 ) )
      integer            bx, bxst, c, difl, difr, givcol, givnum,
     &                   givptr, i, icmpq1, icmpq2, irwb, irwib, irwrb,
     &                   irwu, irwvt, irwwrk, iwk, j, jcol, jimag,
     &                   jreal, jrow, k, nlvl, nm1, nrwork, nsize, nsub,
     &                   perm, poles, s, sizei, smlszp, sqre, st, st1,
     &                   u, vt, z
      real               cs, eps, orgnrm, r, rcnd, sn, tol
      integer            isamax
      real               slamch, slanst
      end subroutine clalsd

      !! clangb.f
      real             function clangb( norm, n, kl, ku, ab, ldab,
     &                 work )
      character          norm
      integer            kl, ku, ldab, n
      real               work( * )
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, k, l
      real               scale, sum, value, temp
      logical            lsame, sisnan
      end function clangb

      !! clange.f
      real             function clange( norm, m, n, a, lda, work )
      character          norm
      integer            lda, m, n
      real               work( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               scale, sum, value, temp
      logical            lsame, sisnan
      end function clange

      !! clangt.f
      real             function clangt( norm, n, dl, d, du )
      character          norm
      integer            n
      complex            d( * ), dl( * ), du( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i
      real               anorm, scale, sum, temp
      logical            lsame, sisnan
      end function clangt

      !! clanhb.f
      real             function clanhb( norm, uplo, n, k, ab, ldab,
     &                 work )
      character          norm, uplo
      integer            k, ldab, n
      real               work( * )
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, l
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function clanhb

      !! clanhe.f
      real             function clanhe( norm, uplo, n, a, lda, work )
      character          norm, uplo
      integer            lda, n
      real               work( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function clanhe

      !! clanhf.f
      real function clanhf( norm, transr, uplo, n, a, work )
      character          norm, transr, uplo
      integer            n
      real               work( 0: * )
      complex            a( 0: * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, ifm, ilu, noe, n1, k, l, lda
      real               scale, s, value, aa, temp
      logical            lsame, sisnan
      end function clanhf

      !! clanhp.f
      real             function clanhp( norm, uplo, n, ap, work )
      character          norm, uplo
      integer            n
      real               work( * )
      complex            ap( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, k
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function clanhp

      !! clanhs.f
      real             function clanhs( norm, n, a, lda, work )
      character          norm
      integer            lda, n
      real               work( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               scale, sum, value
      logical            lsame, sisnan
      end function clanhs

      !! clanht.f
      real             function clanht( norm, n, d, e )
      character          norm
      integer            n
      real               d( * )
      complex            e( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i
      real               anorm, scale, sum
      logical            lsame, sisnan
      end function clanht

      !! clansb.f
      real             function clansb( norm, uplo, n, k, ab, ldab,
     &                 work )
      character          norm, uplo
      integer            k, ldab, n
      real               work( * )
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, l
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function clansb

      !! clansp.f
      real             function clansp( norm, uplo, n, ap, work )
      character          norm, uplo
      integer            n
      real               work( * )
      complex            ap( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, k
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function clansp

      !! clansy.f
      real             function clansy( norm, uplo, n, a, lda, work )
      character          norm, uplo
      integer            lda, n
      real               work( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function clansy

      !! clantb.f
      real             function clantb( norm, uplo, diag, n, k, ab,
     &                 ldab, work )
      character          diag, norm, uplo
      integer            k, ldab, n
      real               work( * )
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            udiag
      integer            i, j, l
      real               scale, sum, value
      logical            lsame, sisnan
      end function clantb

      !! clantp.f
      real             function clantp( norm, uplo, diag, n, ap, work )
      character          diag, norm, uplo
      integer            n
      real               work( * )
      complex            ap( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            udiag
      integer            i, j, k
      real               scale, sum, value
      logical            lsame, sisnan
      end function clantp

      !! clantr.f
      real             function clantr( norm, uplo, diag, m, n, a, lda,
     &                 work )
      character          diag, norm, uplo
      integer            lda, m, n
      real               work( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            udiag
      integer            i, j
      real               scale, sum, value
      logical            lsame, sisnan
      end function clantr

      !! clapll.f
      subroutine clapll( n, x, incx, y, incy, ssmin )
      integer            incx, incy, n
      real               ssmin
      complex            x( * ), y( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      real               ssmax
      complex            a11, a12, a22, c, tau
      complex            cdotc
      end subroutine clapll

      !! clapmr.f
      subroutine clapmr( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      complex            x( ldx, * )
      integer            i, in, j, jj
      complex            temp
      end subroutine clapmr

      !! clapmt.f
      subroutine clapmt( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      complex            x( ldx, * )
      integer            i, ii, j, in
      complex            temp
      end subroutine clapmt

      !! cla_porcond_c.f
      real function cla_porcond_c( uplo, n, a, lda, af, ldaf, c, capply,
     &                             info, work, rwork )
      character          uplo
      logical            capply
      integer            n, lda, ldaf, info
      complex            a( lda, * ), af( ldaf, * ), work( * )
      real               c( * ), rwork( * )
      integer            kase
      real               ainvnm, anorm, tmp
      integer            i, j
      logical            up, upper
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real cabs1
      end function cla_porcond_c

      !! cla_porcond_x.f
      real function cla_porcond_x( uplo, n, a, lda, af, ldaf, x, info,
     &                             work, rwork )
      character          uplo
      integer            n, lda, ldaf, info
      complex            a( lda, * ), af( ldaf, * ), work( * ), x( * )
      real               rwork( * )
      integer            kase, i, j
      real               ainvnm, anorm, tmp
      logical            up, upper
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real cabs1
      end function cla_porcond_x

      !! cla_porfsx_extended.f
      subroutine cla_porfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, colequ, c, b, ldb, y,
     &                                ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state,
     &                   y_prec_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      complex            zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      real               slamch
      real               cabs1
      end subroutine cla_porfsx_extended

      !! cla_porpvgrw.f
      real function cla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
      character(len=1)   uplo
      integer            ncols, lda, ldaf
      complex            a( lda, * ), af( ldaf, * )
      real               work( * )
      integer            i, j
      real               amax, umax, rpvgrw
      logical            upper
      complex            zdum
      logical            lsame
      real               cabs1
      end function cla_porpvgrw

      !! claqgb.f
      subroutine claqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, equed )
      character          equed
      integer            kl, ku, ldab, m, n
      real               amax, colcnd, rowcnd
      real               c( * ), r( * )
      complex            ab( ldab, * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      real               slamch
      end subroutine claqgb

      !! claqge.f
      subroutine claqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   equed )
      character          equed
      integer            lda, m, n
      real               amax, colcnd, rowcnd
      real               c( * ), r( * )
      complex            a( lda, * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      real               slamch
      end subroutine claqge

      !! claqhb.f
      subroutine claqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
      character          equed, uplo
      integer            kd, ldab, n
      real               amax, scond
      real               s( * )
      complex            ab( ldab, * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine claqhb

      !! claqhe.f
      subroutine claqhe( uplo, n, a, lda, s, scond, amax, equed )
      character          equed, uplo
      integer            lda, n
      real               amax, scond
      real               s( * )
      complex            a( lda, * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine claqhe

      !! claqhp.f
      subroutine claqhp( uplo, n, ap, s, scond, amax, equed )
      character          equed, uplo
      integer            n
      real               amax, scond
      real               s( * )
      complex            ap( * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j, jc
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine claqhp

      !! claqp2.f
      subroutine claqp2( m, n, offset, a, lda, jpvt, tau, vn1, vn2,
     &                   work )
      integer            lda, m, n, offset
      integer            jpvt( * )
      real               vn1( * ), vn2( * )
      complex            a( lda, * ), tau( * ), work( * )
      real               zero, one
      complex            cone
      parameter          ( zero = 0.0e+0, one = 1.0e+0,
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      integer            i, itemp, j, mn, offpi, pvt
      real               temp, temp2, tol3z
      complex            aii
      integer            isamax
      real               scnrm2, slamch
      end subroutine claqp2

      !! claqps.f
      subroutine claqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,
     &                   vn2, auxv, f, ldf )
      integer            kb, lda, ldf, m, n, nb, offset
      integer            jpvt( * )
      real               vn1( * ), vn2( * )
      complex            a( lda, * ), auxv( * ), f( ldf, * ), tau( * )
      real               zero, one
      complex            czero, cone
      parameter          ( zero = 0.0e+0, one = 1.0e+0,
     &                   czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      integer            itemp, j, k, lastrk, lsticc, pvt, rk
      real               temp, temp2, tol3z
      complex            akk
      integer            isamax
      real               scnrm2, slamch
      end subroutine claqps

      !! claqr0.f
      subroutine claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,
     &                   ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      complex            h( ldh, * ), w( * ), work( * ), z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      real               wilk1
      parameter          ( wilk1 = 0.75e0 )
      complex            zero, one
      parameter          ( zero = ( 0.0e0, 0.0e0 ),
     &                   one = ( 1.0e0, 0.0e0 ) )
      real               two
      parameter          ( two = 2.0e0 )
      complex            aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
      real               s
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      complex            zdum( 1, 1 )
      real               cabs1
      end subroutine claqr0

      !! claqr1.f
      subroutine claqr1( n, h, ldh, s1, s2, v )
      complex            s1, s2
      integer            ldh, n
      complex            h( ldh, * ), v( * )
      complex            zero
      parameter          ( zero = ( 0.0e0, 0.0e0 ) )
      real               rzero
      parameter          ( rzero = 0.0e0 )
      complex            cdum, h21s, h31s
      real               s
      real               cabs1
      end subroutine claqr1

      !! claqr2.f
      subroutine claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt,
     &                   nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      complex            h( ldh, * ), sh( * ), t( ldt, * ), v( ldv, * ),
     &                   work( * ), wv( ldwv, * ), z( ldz, * )
      complex            zero, one
      parameter          ( zero = ( 0.0e0, 0.0e0 ),
     &                   one = ( 1.0e0, 0.0e0 ) )
      real               rzero, rone
      parameter          ( rzero = 0.0e0, rone = 1.0e0 )
      complex            beta, cdum, s, tau
      real               foo, safmax, safmin, smlnum, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, kcol, kln,
     &                   knt, krow, kwtop, ltop, lwk1, lwk2, lwkopt
      real               slamch
      real               cabs1
      end subroutine claqr2

      !! claqr3.f
      subroutine claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt,
     &                   nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      complex            h( ldh, * ), sh( * ), t( ldt, * ), v( ldv, * ),
     &                   work( * ), wv( ldwv, * ), z( ldz, * )
      complex            zero, one
      parameter          ( zero = ( 0.0e0, 0.0e0 ),
     &                   one = ( 1.0e0, 0.0e0 ) )
      real               rzero, rone
      parameter          ( rzero = 0.0e0, rone = 1.0e0 )
      complex            beta, cdum, s, tau
      real               foo, safmax, safmin, smlnum, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, kcol, kln,
     &                   knt, krow, kwtop, ltop, lwk1, lwk2, lwk3,
     &                   lwkopt, nmin
      real               slamch
      integer            ilaenv
      real               cabs1
      end subroutine claqr3

      !! claqr4.f
      subroutine claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,
     &                   ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      complex            h( ldh, * ), w( * ), work( * ), z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      real               wilk1
      parameter          ( wilk1 = 0.75e0 )
      complex            zero, one
      parameter          ( zero = ( 0.0e0, 0.0e0 ),
     &                   one = ( 1.0e0, 0.0e0 ) )
      real               two
      parameter          ( two = 2.0e0 )
      complex            aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
      real               s
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      complex            zdum( 1, 1 )
      real               cabs1
      end subroutine claqr4

      !! claqr5.f
      subroutine claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,
     &                   h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,
     &                   wv, ldwv, nh, wh, ldwh )
      integer            ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv,
     &                   ldwh, ldwv, ldz, n, nh, nshfts, nv
      logical            wantt, wantz
      complex            h( ldh, * ), s( * ), u( ldu, * ), v( ldv, * ),
     &                   wh( ldwh, * ), wv( ldwv, * ), z( ldz, * )
      complex            zero, one
      parameter          ( zero = ( 0.0e0, 0.0e0 ),
     &                   one = ( 1.0e0, 0.0e0 ) )
      real               rzero, rone
      parameter          ( rzero = 0.0e0, rone = 1.0e0 )
      complex            alpha, beta, cdum, refsum
      real               h11, h12, h21, h22, safmax, safmin, scl,
     &                   smlnum, tst1, tst2, ulp
      integer            i2, i4, incol, j, j2, j4, jbot, jcol, jlen,
     &                   jrow, jtop, k, k1, kdu, kms, knz, krcol, kzs,
     &                   m, m22, mbot, mend, mstart, mtop, nbmps, ndcol,
     &                   ns, nu
      logical            accum, blk22, bmp22
      real               slamch
      complex            vt( 3 )
      real               cabs1
      end subroutine claqr5

      !! claqsb.f
      subroutine claqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
      character          equed, uplo
      integer            kd, ldab, n
      real               amax, scond
      real               s( * )
      complex            ab( ldab, * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine claqsb

      !! claqsp.f
      subroutine claqsp( uplo, n, ap, s, scond, amax, equed )
      character          equed, uplo
      integer            n
      real               amax, scond
      real               s( * )
      complex            ap( * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j, jc
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine claqsp

      !! claqsy.f
      subroutine claqsy( uplo, n, a, lda, s, scond, amax, equed )
      character          equed, uplo
      integer            lda, n
      real               amax, scond
      real               s( * )
      complex            a( lda, * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine claqsy

      !! clar1v.f
      subroutine clar1v( n, b1, bn, lambda, d, l, ld, lld,
     &           pivmin, gaptol, z, wantnc, negcnt, ztz, mingma,
     &           r, isuppz, nrminv, resid, rqcorr, work )
      logical            wantnc
      integer   b1, bn, n, negcnt, r
      real               gaptol, lambda, mingma, nrminv, pivmin, resid,
     &                   rqcorr, ztz
      integer            isuppz( * )
      real               d( * ), l( * ), ld( * ), lld( * ),
     &                  work( * )
      complex          z( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      complex            cone
      parameter          ( cone = ( 1.0e0, 0.0e0 ) )
      logical            sawnan1, sawnan2
      integer            i, indlpl, indp, inds, indumn, neg1, neg2, r1,
     &                   r2
      real               dminus, dplus, eps, s, tmp
      logical sisnan
      real               slamch
      end subroutine clar1v

      !! clar2v.f
      subroutine clar2v( n, x, y, z, incx, c, s, incc )
      integer            incc, incx, n
      real               c( * )
      complex            s( * ), x( * ), y( * ), z( * )
      integer            i, ic, ix
      real               ci, sii, sir, t1i, t1r, t5, t6, xi, yi, zii,
     &                   zir
      complex            si, t2, t3, t4, zi
      end subroutine clar2v

      !! clarcm.f
      subroutine clarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
      integer            lda, ldb, ldc, m, n
      real               a( lda, * ), rwork( * )
      complex            b( ldb, * ), c( ldc, * )
      real               one, zero
      parameter          ( one = 1.0e0, zero = 0.0e0 )
      integer            i, j, l
      end subroutine clarcm

      !! clarfb.f
      subroutine clarfb( side, trans, direct, storev, m, n, k, v, ldv,
     &                   t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, ldc, ldt, ldv, ldwork, m, n
      complex            c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      character          transt
      integer            i, j
      logical            lsame
      end subroutine clarfb

      !! clarf.f
      subroutine clarf( side, m, n, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, ldc, m, n
      complex            tau
      complex            c( ldc, * ), v( * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            applyleft
      integer            i, lastv, lastc
      logical            lsame
      integer            ilaclr, ilaclc
      end subroutine clarf

      !! clarfg.f
      subroutine clarfg( n, alpha, x, incx, tau )
      integer            incx, n
      complex            alpha, tau
      complex            x( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            j, knt
      real               alphi, alphr, beta, rsafmn, safmin, xnorm
      real               scnrm2, slamch, slapy3
      complex            cladiv
      end subroutine clarfg

      !! clarfgp.f
      subroutine clarfgp( n, alpha, x, incx, tau )
      integer            incx, n
      complex            alpha, tau
      complex            x( * )
      real               two, one, zero
      parameter          ( two = 2.0e+0, one = 1.0e+0, zero = 0.0e+0 )
      integer            j, knt
      real               alphi, alphr, beta, bignum, smlnum, xnorm
      complex            savealpha
      real               scnrm2, slamch, slapy3, slapy2
      complex            cladiv
      end subroutine clarfgp

      !! clarft.f
      subroutine clarft( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      complex            t( ldt, * ), tau( * ), v( ldv, * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, j, prevlastv, lastv
      logical            lsame
      end subroutine clarft

      !! clarfx.f
      subroutine clarfx( side, m, n, v, tau, c, ldc, work )
      character          side
      integer            ldc, m, n
      complex            tau
      complex            c( ldc, * ), v( * ), work( * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      integer            j
      complex            sum, t1, t10, t2, t3, t4, t5, t6, t7, t8, t9,
     &                   v1, v10, v2, v3, v4, v5, v6, v7, v8, v9
      logical            lsame
      end subroutine clarfx

      !! clargv.f
      subroutine clargv( n, x, incx, y, incy, c, incc )
      integer            incc, incx, incy, n
      real               c( * )
      complex            x( * ), y( * )
      real               two, one, zero
      parameter          ( two = 2.0e+0, one = 1.0e+0, zero = 0.0e+0 )
      complex            czero
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ) )
      integer            count, i, ic, ix, iy, j
      real               cs, d, di, dr, eps, f2, f2s, g2, g2s, safmin,
     &                   safmn2, safmx2, scale
      complex            f, ff, fs, g, gs, r, sn
      real               slamch, slapy2
      real               abs1, abssq
      end subroutine clargv

      !! clarnv.f
      subroutine clarnv( idist, iseed, n, x )
      integer            idist, n
      integer            iseed( 4 )
      complex            x( * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      integer            lv
      parameter          ( lv = 128 )
      real               twopi
      parameter          ( twopi = 6.2831853071795864769252867663e+0 )
      integer            i, il, iv
      real               u( lv )
      end subroutine clarnv

      !! clarrv.f
      subroutine clarrv( n, vl, vu, d, l, pivmin,
     &                   isplit, m, dol, dou, minrgp,
     &                   rtol1, rtol2, w, werr, wgap,
     &                   iblock, indexw, gers, z, ldz, isuppz,
     &                   work, iwork, info )
      integer            dol, dou, info, ldz, m, n
      real               minrgp, pivmin, rtol1, rtol2, vl, vu
      integer            iblock( * ), indexw( * ), isplit( * ),
     &                   isuppz( * ), iwork( * )
      real               d( * ), gers( * ), l( * ), w( * ), werr( * ),
     &                   wgap( * ), work( * )
      complex           z( ldz, * )
      integer            maxitr
      parameter          ( maxitr = 10 )
      complex            czero
      parameter          ( czero = ( 0.0e0, 0.0e0 ) )
      real               zero, one, two, three, four, half
      parameter          ( zero = 0.0e0, one = 1.0e0,
     &                     two = 2.0e0, three = 3.0e0,
     &                     four = 4.0e0, half = 0.5e0)
      logical            eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
      integer            done, i, ibegin, idone, iend, ii, iindc1,
     &                   iindc2, iindr, iindwk, iinfo, im, in, indeig,
     &                   indld, indlld, indwrk, isupmn, isupmx, iter,
     &                   itmp1, j, jblk, k, miniwsize, minwsize, nclus,
     &                   ndepth, negcnt, newcls, newfst, newftt, newlst,
     &                   newsiz, offset, oldcls, oldfst, oldien, oldlst,
     &                   oldncl, p, parity, q, wbegin, wend, windex,
     &                   windmn, windpl, zfrom, zto, zusedl, zusedu,
     &                   zusedw
      integer            indin1, indin2
      real               bstres, bstw, eps, fudge, gap, gaptol, gl, gu,
     &                   lambda, left, lgap, mingma, nrminv, resid,
     &                   rgap, right, rqcorr, rqtol, savgap, sgndef,
     &                   sigma, spdiam, ssigma, tau, tmp, tol, ztz
      real               slamch
      end subroutine clarrv

      !! clarscl2.f
      subroutine clarscl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      complex            x( ldx, * )
      real               d( * )
      integer            i, j
      end subroutine clarscl2

      !! clartg.f
      subroutine clartg( f, g, cs, sn, r )
      real               cs
      complex            f, g, r, sn
      real               two, one, zero
      parameter          ( two = 2.0e+0, one = 1.0e+0, zero = 0.0e+0 )
      complex            czero
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ) )
      integer            count, i
      real               d, di, dr, eps, f2, f2s, g2, g2s, safmin,
     &                   safmn2, safmx2, scale
      complex            ff, fs, gs
      real               slamch, slapy2
      logical            sisnan
      real               abs1, abssq
      end subroutine clartg

      !! clartv.f
      subroutine clartv( n, x, incx, y, incy, c, s, incc )
      integer            incc, incx, incy, n
      real               c( * )
      complex            s( * ), x( * ), y( * )
      integer            i, ic, ix, iy
      complex            xi, yi
      end subroutine clartv

      !! clarzb.f
      subroutine clarzb( side, trans, direct, storev, m, n, k, l, v,
     &                   ldv, t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, l, ldc, ldt, ldv, ldwork, m, n
      complex            c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      character          transt
      integer            i, info, j
      logical            lsame
      end subroutine clarzb

      !! clarz.f
      subroutine clarz( side, m, n, l, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, l, ldc, m, n
      complex            tau
      complex            c( ldc, * ), v( * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            lsame
      end subroutine clarz

      !! clarzt.f
      subroutine clarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      complex            t( ldt, * ), tau( * ), v( ldv, * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, info, j
      logical            lsame
      end subroutine clarzt

      !! clascl2.f
      subroutine clascl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      real               d( * )
      complex            x( ldx, * )
      integer            i, j
      end subroutine clascl2

      !! clascl.f
      subroutine clascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
      character          type
      integer            info, kl, ku, lda, m, n
      real               cfrom, cto
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            done
      integer            i, itype, j, k1, k2, k3, k4
      real               bignum, cfrom1, cfromc, cto1, ctoc, mul, smlnum
      logical            lsame, sisnan
      real               slamch
      end subroutine clascl

      !! claset.f
      subroutine claset( uplo, m, n, alpha, beta, a, lda )
      character          uplo
      integer            lda, m, n
      complex            alpha, beta
      complex            a( lda, * )
      integer            i, j
      logical            lsame
      end subroutine claset

      !! clasr.f
      subroutine clasr( side, pivot, direct, m, n, c, s, a, lda )
      character          direct, pivot, side
      integer            lda, m, n
      real               c( * ), s( * )
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, info, j
      real               ctemp, stemp
      complex            temp
      logical            lsame
      end subroutine clasr

      !! classq.f
      subroutine classq( n, x, incx, scale, sumsq )
      integer            incx, n
      real               scale, sumsq
      complex            x( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            ix
      real               temp1
      logical            sisnan
      end subroutine classq

      !! claswp.f
      subroutine claswp( n, a, lda, k1, k2, ipiv, incx )
      integer            incx, k1, k2, lda, n
      integer            ipiv( * )
      complex            a( lda, * )
      integer            i, i1, i2, inc, ip, ix, ix0, j, k, n32
      complex            temp
      end subroutine claswp

      !! cla_syamv.f
      subroutine cla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,
     &                      incy )
      real               alpha, beta
      integer            incx, incy, lda, n
      integer            uplo
      complex            a( lda, * ), x( * )
      real               y( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            symb_zero
      real               temp, safe1
      integer            i, info, iy, j, jx, kx, ky
      complex            zdum
      real               slamch
      integer            ilauplo
      real               cabs1
      end subroutine cla_syamv

      !! clasyf.f
      subroutine clasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex            a( lda, * ), w( ldw, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      integer            imax, j, jb, jj, jmax, jp, k, kk, kkw, kp,
     &                   kstep, kw
      real               absakk, alpha, colmax, rowmax
      complex            d11, d21, d22, r1, t, z
      logical            lsame
      integer            icamax
      real               cabs1
      end subroutine clasyf

      !! clasyf_rook.f
      subroutine clasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,
     &                        info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex            a( lda, * ), w( ldw, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      complex            cone, czero
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ),
     &                   czero = ( 0.0e+0, 0.0e+0 ) )
      logical            done
      integer            imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk,
     &                   kw, kkw, kp, kstep, p, ii
      real               absakk, alpha, colmax, rowmax, stemp, sfmin
      complex            d11, d12, d21, d22, r1, t, z
      logical            lsame
      integer            icamax
      real               slamch
      real               cabs1
      end subroutine clasyf_rook

      !! cla_syrcond_c.f
      real function cla_syrcond_c( uplo, n, a, lda, af, ldaf, ipiv, c,
     &                             capply, info, work, rwork )
      character          uplo
      logical            capply
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), work( * )
      real               c( * ), rwork( * )
      integer            kase
      real               ainvnm, anorm, tmp
      integer            i, j
      logical            up, upper
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real cabs1
      end function cla_syrcond_c

      !! cla_syrcond_x.f
      real function cla_syrcond_x( uplo, n, a, lda, af, ldaf, ipiv, x,
     &                             info, work, rwork )
      character          uplo
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), work( * ), x( * )
      real               rwork( * )
      integer            kase
      real               ainvnm, anorm, tmp
      integer            i, j
      logical            up, upper
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               cabs1
      end function cla_syrcond_x

      !! cla_syrfsx_extended.f
      subroutine cla_syrfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, ipiv, colequ, c, b, ldb,
     &                                y, ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state,
     &                   y_prec_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec, upper
      complex            zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      real               slamch
      real               cabs1
      end subroutine cla_syrfsx_extended

      !! cla_syrpvgrw.f
      real function cla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,
     &                            work )
      character(len=1)   uplo
      integer            n, info, lda, ldaf
      complex            a( lda, * ), af( ldaf, * )
      real               work( * )
      integer            ipiv( * )
      integer            ncols, i, j, k, kp
      real               amax, umax, rpvgrw, tmp
      logical            upper
      complex            zdum
      logical            lsame
      real               cabs1
      end function cla_syrpvgrw

      !! clatbs.f
      subroutine clatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,
     &                   scale, cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, kd, ldab, n
      real               scale
      real               cnorm( * )
      complex            ab( ldab, * ), x( * )
      real               zero, half, one, two
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0,
     &                   two = 2.0e+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast, jlen, maind
      real               bignum, grow, rec, smlnum, tjj, tmax, tscal,
     &                   xbnd, xj, xmax
      complex            csumj, tjjs, uscal, zdum
      logical            lsame
      integer            icamax, isamax
      real               scasum, slamch
      complex            cdotc, cdotu, cladiv
      real               cabs1, cabs2
      end subroutine clatbs

      !! clatdf.f
      subroutine clatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,
     &                   jpiv )
      integer            ijob, ldz, n
      real               rdscal, rdsum
      integer            ipiv( * ), jpiv( * )
      complex            rhs( * ), z( ldz, * )
      integer            maxdim
      parameter          ( maxdim = 2 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      integer            i, info, j, k
      real               rtemp, scale, sminu, splus
      complex            bm, bp, pmone, temp
      real               rwork( maxdim )
      complex            work( 4*maxdim ), xm( maxdim ), xp( maxdim )
      real               scasum
      complex            cdotc
      end subroutine clatdf

      !! clatps.f
      subroutine clatps( uplo, trans, diag, normin, n, ap, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, n
      real               scale
      real               cnorm( * )
      complex            ap( * ), x( * )
      real               zero, half, one, two
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0,
     &                   two = 2.0e+0 )
      logical            notran, nounit, upper
      integer            i, imax, ip, j, jfirst, jinc, jlast, jlen
      real               bignum, grow, rec, smlnum, tjj, tmax, tscal,
     &                   xbnd, xj, xmax
      complex            csumj, tjjs, uscal, zdum
      logical            lsame
      integer            icamax, isamax
      real               scasum, slamch
      complex            cdotc, cdotu, cladiv
      real               cabs1, cabs2
      end subroutine clatps

      !! clatrd.f
      subroutine clatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
      character          uplo
      integer            lda, ldw, n, nb
      real               e( * )
      complex            a( lda, * ), tau( * ), w( ldw, * )
      complex            zero, one, half
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ),
     &                   half = ( 0.5e+0, 0.0e+0 ) )
      integer            i, iw
      complex            alpha
      logical            lsame
      complex            cdotc
      end subroutine clatrd

      !! clatrs.f
      subroutine clatrs( uplo, trans, diag, normin, n, a, lda, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, lda, n
      real               scale
      real               cnorm( * )
      complex            a( lda, * ), x( * )
      real               zero, half, one, two
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0,
     &                   two = 2.0e+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast
      real               bignum, grow, rec, smlnum, tjj, tmax, tscal,
     &                   xbnd, xj, xmax
      complex            csumj, tjjs, uscal, zdum
      logical            lsame
      integer            icamax, isamax
      real               scasum, slamch
      complex            cdotc, cdotu, cladiv
      real               cabs1, cabs2
      end subroutine clatrs

      !! clatrz.f
      subroutine clatrz( m, n, l, a, lda, tau, work )
      integer            l, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i
      complex            alpha
      end subroutine clatrz

      !! clauu2.f
      subroutine clauu2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex            a( lda, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i
      real               aii
      logical            lsame
      complex            cdotc
      end subroutine clauu2

      !! clauum.f
      subroutine clauum( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex            a( lda, * )
      real               one
      parameter          ( one = 1.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i, ib, nb
      logical            lsame
      integer            ilaenv
      end subroutine clauum

      !! cla_wwaddw.f
      subroutine cla_wwaddw( n, x, y, w )
      integer            n
      complex            x( * ), y( * ), w( * )
      complex            s
      integer            i
      end subroutine cla_wwaddw

      !! cpbcon.f
      subroutine cpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,
     &                   rwork, info )
      character          uplo
      integer            info, kd, ldab, n
      real               anorm, rcond
      real               rwork( * )
      complex            ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      character          normin
      integer            ix, kase
      real               ainvnm, scale, scalel, scaleu, smlnum
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               slamch
      real               cabs1
      end subroutine cpbcon

      !! cpbequ.f
      subroutine cpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
      character          uplo
      integer            info, kd, ldab, n
      real               amax, scond
      real               s( * )
      complex            ab( ldab, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            upper
      integer            i, j
      real               smin
      logical            lsame
      end subroutine cpbequ

      !! cpbrfs.f
      subroutine cpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,
     &                   ldb, x, ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      real               berr( * ), ferr( * ), rwork( * )
      complex            ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, j, k, kase, l, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine cpbrfs

      !! cpbstf.f
      subroutine cpbstf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            j, kld, km, m
      real               ajj
      logical            lsame
      end subroutine cpbstf

      !! cpbsv.f
      subroutine cpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      complex            ab( ldab, * ), b( ldb, * )
      logical            lsame
      end subroutine cpbsv

      !! cpbsvx.f
      subroutine cpbsvx( fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb,
     &                   equed, s, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, rwork, info )
      character          equed, fact, uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      real               rcond
      real               berr( * ), ferr( * ), rwork( * ), s( * )
      complex            ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            equil, nofact, rcequ, upper
      integer            i, infequ, j, j1, j2
      real               amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      real               clanhb, slamch
      end subroutine cpbsvx

      !! cpbtf2.f
      subroutine cpbtf2( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            j, kld, kn
      real               ajj
      logical            lsame
      end subroutine cpbtf2

      !! cpbtrf.f
      subroutine cpbtrf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      complex            ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      integer            nbmax, ldwork
      parameter          ( nbmax = 32, ldwork = nbmax+1 )
      integer            i, i2, i3, ib, ii, j, jj, nb
      complex            work( ldwork, nbmax )
      logical            lsame
      integer            ilaenv
      end subroutine cpbtrf

      !! cpbtrs.f
      subroutine cpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      complex            ab( ldab, * ), b( ldb, * )
      logical            upper
      integer            j
      logical            lsame
      end subroutine cpbtrs

      !! cpftrf.f
      subroutine cpftrf( transr, uplo, n, a, info )
      character          transr, uplo
      integer            n, info
      complex            a( 0: * )
      real               one
      complex            cone
      parameter          ( one = 1.0e+0, cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine cpftrf

      !! cpftri.f
      subroutine cpftri( transr, uplo, n, a, info )
      character          transr, uplo
      integer            info, n
      complex            a( 0: * )
      real               one
      complex            cone
      parameter          ( one = 1.0e+0, cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine cpftri

      !! cpftrs.f
      subroutine cpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
      character          transr, uplo
      integer            info, ldb, n, nrhs
      complex            a( 0: * ), b( ldb, * )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lower, normaltransr
      logical            lsame
      end subroutine cpftrs

      !! cpocon.f
      subroutine cpocon( uplo, n, a, lda, anorm, rcond, work, rwork,
     &                   info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      real               rwork( * )
      complex            a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      character          normin
      integer            ix, kase
      real               ainvnm, scale, scalel, scaleu, smlnum
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               slamch
      real               cabs1
      end subroutine cpocon

      !! cpoequb.f
      subroutine cpoequb( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      real               amax, scond
      complex            a( lda, * )
      real               s( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i
      real               smin, base, tmp
      real               slamch
      end subroutine cpoequb

      !! cpoequ.f
      subroutine cpoequ( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      real               amax, scond
      real               s( * )
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i
      real               smin
      end subroutine cpoequ

      !! cporfs.f
      subroutine cporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,
     &                   ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      real               berr( * ), ferr( * ), rwork( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine cporfs

      !! cporfsx.f
      subroutine cporfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, s, b,
     &                    ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               rwork( * ), s( * ), params(*), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, clanhe, cla_porcond_x, cla_porcond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine cporfsx

      !! cposv.f
      subroutine cposv( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      complex            a( lda, * ), b( ldb, * )
      logical            lsame
      end subroutine cposv

      !! cposvx.f
      subroutine cposvx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                   s, b, ldb, x, ldx, rcond, ferr, berr, work,
     &                   rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      real               rcond
      real               berr( * ), ferr( * ), rwork( * ), s( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      real               amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      real               clanhe, slamch
      end subroutine cposvx

      !! cposvxx.f
      subroutine cposvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                    s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      real               amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      real               slamch, cla_porpvgrw
      end subroutine cposvxx

      !! cpotf2.f
      subroutine cpotf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j
      real               ajj
      logical            lsame, sisnan
      complex            cdotc
      end subroutine cpotf2

      !! cpotrf2.f
      recursive subroutine cpotrf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex            a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = (1.0e+0, 0.0e+0) )
      logical            upper
      integer            n1, n2, iinfo
      real               ajj
      logical            lsame, sisnan
      end subroutine cpotrf2

      !! cpotrf.f
      subroutine cpotrf( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex            a( lda, * )
      real               one
      complex            cone
      parameter          ( one = 1.0e+0, cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, jb, nb
      logical            lsame
      integer            ilaenv
      end subroutine cpotrf

      !! cpotri.f
      subroutine cpotri( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex            a( lda, * )
      logical            lsame
      end subroutine cpotri

      !! cpotrs.f
      subroutine cpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      complex            a( lda, * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      logical            lsame
      end subroutine cpotrs

      !! cppcon.f
      subroutine cppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
      character          uplo
      integer            info, n
      real               anorm, rcond
      real               rwork( * )
      complex            ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      character          normin
      integer            ix, kase
      real               ainvnm, scale, scalel, scaleu, smlnum
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               slamch
      real               cabs1
      end subroutine cppcon

      !! cppequ.f
      subroutine cppequ( uplo, n, ap, s, scond, amax, info )
      character          uplo
      integer            info, n
      real               amax, scond
      real               s( * )
      complex            ap( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, jj
      real               smin
      logical            lsame
      end subroutine cppequ

      !! cpprfs.f
      subroutine cpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,
     &                   berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      real               berr( * ), ferr( * ), rwork( * )
      complex            afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine cpprfs

      !! cppsv.f
      subroutine cppsv( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      complex            ap( * ), b( ldb, * )
      logical            lsame
      end subroutine cppsv

      !! cppsvx.f
      subroutine cppsvx( fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb,
     &                   x, ldx, rcond, ferr, berr, work, rwork, info )
      character          equed, fact, uplo
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      real               berr( * ), ferr( * ), rwork( * ), s( * )
      complex            afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      real               amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      real               clanhp, slamch
      end subroutine cppsvx

      !! cpptrf.f
      subroutine cpptrf( uplo, n, ap, info )
      character          uplo
      integer            info, n
      complex            ap( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            upper
      integer            j, jc, jj
      real               ajj
      logical            lsame
      complex            cdotc
      end subroutine cpptrf

      !! cpptri.f
      subroutine cpptri( uplo, n, ap, info )
      character          uplo
      integer            info, n
      complex            ap( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            j, jc, jj, jjn
      real               ajj
      logical            lsame
      complex            cdotc
      end subroutine cpptri

      !! cpptrs.f
      subroutine cpptrs( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      complex            ap( * ), b( ldb, * )
      logical            upper
      integer            i
      logical            lsame
      end subroutine cpptrs

      !! cpstf2.f
      subroutine cpstf2( uplo, n, a, lda, piv, rank, tol, work, info )
      real               tol
      integer            info, lda, n, rank
      character          uplo
      complex            a( lda, * )
      real               work( 2*n )
      integer            piv( n )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      complex            ctemp
      real               ajj, sstop, stemp
      integer            i, itemp, j, pvt
      logical            upper
      real               slamch
      logical            lsame, sisnan
      end subroutine cpstf2

      !! cpstrf.f
      subroutine cpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
      real               tol
      integer            info, lda, n, rank
      character          uplo
      complex            a( lda, * )
      real               work( 2*n )
      integer            piv( n )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      complex            ctemp
      real               ajj, sstop, stemp
      integer            i, itemp, j, jb, k, nb, pvt
      logical            upper
      real               slamch
      integer            ilaenv
      logical            lsame, sisnan
      end subroutine cpstrf

      !! cptcon.f
      subroutine cptcon( n, d, e, anorm, rcond, rwork, info )
      integer            info, n
      real               anorm, rcond
      real               d( * ), rwork( * )
      complex            e( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, ix
      real               ainvnm
      integer            isamax
      end subroutine cptcon

      !! cpteqr.f
      subroutine cpteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      real               d( * ), e( * ), work( * )
      complex            z( ldz, * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lsame
      complex            c( 1, 1 ), vt( 1, 1 )
      integer            i, icompz, nru
      end subroutine cpteqr

      !! cptrfs.f
      subroutine cptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      real               berr( * ), d( * ), df( * ), ferr( * ),
     &                   rwork( * )
      complex            b( ldb, * ), e( * ), ef( * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, ix, j, nz
      real               eps, lstres, s, safe1, safe2, safmin
      complex            bi, cx, dx, ex, zdum
      logical            lsame
      integer            isamax
      real               slamch
      real               cabs1
      end subroutine cptrfs

      !! cptsv.f
      subroutine cptsv( n, nrhs, d, e, b, ldb, info )
      integer            info, ldb, n, nrhs
      real               d( * )
      complex            b( ldb, * ), e( * )
      end subroutine cptsv

      !! cptsvx.f
      subroutine cptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, rwork, info )
      character          fact
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      real               berr( * ), d( * ), df( * ), ferr( * ),
     &                   rwork( * )
      complex            b( ldb, * ), e( * ), ef( * ), work( * ),
     &                   x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nofact
      real               anorm
      logical            lsame
      real               clanht, slamch
      end subroutine cptsvx

      !! cpttrf.f
      subroutine cpttrf( n, d, e, info )
      integer            info, n
      real               d( * )
      complex            e( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            i, i4
      real               eii, eir, f, g
      end subroutine cpttrf

      !! cpttrs.f
      subroutine cpttrs( uplo, n, nrhs, d, e, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      real               d( * )
      complex            b( ldb, * ), e( * )
      logical            upper
      integer            iuplo, j, jb, nb
      integer            ilaenv
      end subroutine cpttrs

      !! cptts2.f
      subroutine cptts2( iuplo, n, nrhs, d, e, b, ldb )
      integer            iuplo, ldb, n, nrhs
      real               d( * )
      complex            b( ldb, * ), e( * )
      integer            i, j
      end subroutine cptts2

      !! crot.f
      subroutine crot( n, cx, incx, cy, incy, c, s )
      integer            incx, incy, n
      real               c
      complex            s
      complex            cx( * ), cy( * )
      integer            i, ix, iy
      complex            stemp
      end subroutine crot

      !! cspcon.f
      subroutine cspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
      character          uplo
      integer            info, n
      real               anorm, rcond
      integer            ipiv( * )
      complex            ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, ip, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine cspcon

      !! cspmv.f
      subroutine cspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
      character          uplo
      integer            incx, incy, n
      complex            alpha, beta
      complex            ap( * ), x( * ), y( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, info, ix, iy, j, jx, jy, k, kk, kx, ky
      complex            temp1, temp2
      logical            lsame
      end subroutine cspmv

      !! cspr.f
      subroutine cspr( uplo, n, alpha, x, incx, ap )
      character          uplo
      integer            incx, n
      complex            alpha
      complex            ap( * ), x( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, info, ix, j, jx, k, kk, kx
      complex            temp
      logical            lsame
      end subroutine cspr

      !! csprfs.f
      subroutine csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine csprfs

      !! cspsv.f
      subroutine cspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex            ap( * ), b( ldb, * )
      logical            lsame
      end subroutine cspsv

      !! cspsvx.f
      subroutine cspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,
     &                   ldx, rcond, ferr, berr, work, rwork, info )
      character          fact, uplo
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nofact
      real               anorm
      logical            lsame
      real               clansp, slamch
      end subroutine cspsvx

      !! csptrf.f
      subroutine csptrf( uplo, n, ap, ipiv, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex            ap( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i, imax, j, jmax, k, kc, kk, knc, kp, kpc,
     &                   kstep, kx, npp
      real               absakk, alpha, colmax, rowmax
      complex            d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, zdum
      logical            lsame
      integer            icamax
      real               cabs1
      end subroutine csptrf

      !! csptri.f
      subroutine csptri( uplo, n, ap, ipiv, work, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex            ap( * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kc, kcnext, kp, kpc, kstep, kx, npp
      complex            ak, akkp1, akp1, d, t, temp
      logical            lsame
      complex            cdotu
      end subroutine csptri

      !! csptrs.f
      subroutine csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex            ap( * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kc, kp
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine csptrs

      !! csrscl.f
      subroutine csrscl( n, sa, sx, incx )
      integer            incx, n
      real               sa
      complex            sx( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            done
      real               bignum, cden, cden1, cnum, cnum1, mul, smlnum
      real               slamch
      end subroutine csrscl

      !! cstedc.f
      subroutine cstedc( compz, n, d, e, z, ldz, work, lwork, rwork,
     &                   lrwork, iwork, liwork, info )
      character          compz
      integer            info, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      real               d( * ), e( * ), rwork( * )
      complex            work( * ), z( ldz, * )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      logical            lquery
      integer            finish, i, icompz, ii, j, k, lgn, liwmin, ll,
     &                   lrwmin, lwmin, m, smlsiz, start
      real               eps, orgnrm, p, tiny
      logical            lsame
      integer            ilaenv
      real               slamch, slanst
      end subroutine cstedc

      !! cstegr.f
      subroutine cstegr( jobz, range, n, d, e, vl, vu, il, iu,
     &           abstol, m, w, z, ldz, isuppz, work, lwork, iwork,
     &           liwork, info )
      character          jobz, range
      integer            il, info, iu, ldz, liwork, lwork, m, n
      real             abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      real               d( * ), e( * ), w( * ), work( * )
      complex            z( ldz, * )
      logical tryrac
      end subroutine cstegr

      !! cstein.f
      subroutine cstein( n, d, e, m, w, iblock, isplit, z, ldz, work,
     &                   iwork, ifail, info )
      integer            info, ldz, m, n
      integer            iblock( * ), ifail( * ), isplit( * ),
     &                   iwork( * )
      real               d( * ), e( * ), w( * ), work( * )
      complex            z( ldz, * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      real               zero, one, ten, odm3, odm1
      parameter          ( zero = 0.0e+0, one = 1.0e+0, ten = 1.0e+1,
     &                   odm3 = 1.0e-3, odm1 = 1.0e-1 )
      integer            maxits, extra
      parameter          ( maxits = 5, extra = 2 )
      integer            b1, blksiz, bn, gpind, i, iinfo, indrv1,
     &                   indrv2, indrv3, indrv4, indrv5, its, j, j1,
     &                   jblk, jmax, jr, nblk, nrmchk
      real               ctr, eps, eps1, nrm, onenrm, ortol, pertol,
     &                   scl, sep, stpcrt, tol, xj, xjm
      integer            iseed( 4 )
      integer            isamax
      real               sasum, slamch, snrm2
      end subroutine cstein

      !! cstemr.f
      subroutine cstemr( jobz, range, n, d, e, vl, vu, il, iu,
     &                   m, w, z, ldz, nzc, isuppz, tryrac, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, range
      logical            tryrac
      integer            il, info, iu, ldz, nzc, liwork, lwork, m, n
      real             vl, vu
      integer            isuppz( * ), iwork( * )
      real               d( * ), e( * ), w( * ), work( * )
      complex            z( ldz, * )
      real               zero, one, four, minrgp
      parameter          ( zero = 0.0e0, one = 1.0e0,
     &                     four = 4.0e0,
     &                     minrgp = 3.0e-3 )
      logical            alleig, indeig, lquery, valeig, wantz, zquery
      integer            i, ibegin, iend, ifirst, iil, iindbl, iindw,
     &                   iindwk, iinfo, iinspl, iiu, ilast, in, indd,
     &                   inde2, inderr, indgp, indgrs, indwrk, itmp,
     &                   itmp2, j, jblk, jj, liwmin, lwmin, nsplit,
     &                   nzcmin, offset, wbegin, wend
      real               bignum, cs, eps, pivmin, r1, r2, rmax, rmin,
     &                   rtol1, rtol2, safmin, scale, smlnum, sn,
     &                   thresh, tmp, tnrm, wl, wu
      logical            lsame
      real               slamch, slanst
      end subroutine cstemr

      !! csteqr.f
      subroutine csteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      real               d( * ), e( * ), work( * )
      complex            z( ldz, * )
      real               zero, one, two, three
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   three = 3.0e0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e0, 0.0e0 ),
     &                   cone = ( 1.0e0, 0.0e0 ) )
      integer            maxit
      parameter          ( maxit = 30 )
      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
     &                   nm1, nmaxit
      real               anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
     &                   s, safmax, safmin, ssfmax, ssfmin, tst
      logical            lsame
      real               slamch, slanst, slapy2
      end subroutine csteqr

      !! csycon.f
      subroutine csycon( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine csycon

      !! csycon_rook.f
      subroutine csycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                        info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      complex            czero
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine csycon_rook

      !! csyconv.f
      subroutine csyconv( uplo, way, n, a, lda, ipiv, e, info )
      character          uplo, way
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * ), e( * )
      complex            zero
      parameter          ( zero = (0.0e+0,0.0e+0) )
      logical            lsame
      logical            upper, convert
      integer            i, ip, j
      complex            temp
      end subroutine csyconv

      !! csyequb.f
      subroutine csyequb( uplo, n, a, lda, s, scond, amax, work, info )
      integer            info, lda, n
      real               amax, scond
      character          uplo
      complex            a( lda, * ), work( * )
      real               s( * )
      real               one, zero
      parameter          ( one = 1.0e0, zero = 0.0e0 )
      integer            max_iter
      parameter          ( max_iter = 100 )
      integer            i, j, iter
      real               avg, std, tol, c0, c1, c2, t, u, si, d, base,
     &                   smin, smax, smlnum, bignum, scale, sumsq
      logical            up
      complex            zdum
      real               slamch
      logical            lsame
      real               cabs1
      end subroutine csyequb

      !! csymv.f
      subroutine csymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
      character          uplo
      integer            incx, incy, lda, n
      complex            alpha, beta
      complex            a( lda, * ), x( * ), y( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, info, ix, iy, j, jx, jy, kx, ky
      complex            temp1, temp2
      logical            lsame
      end subroutine csymv

      !! csyr.f
      subroutine csyr( uplo, n, alpha, x, incx, a, lda )
      character          uplo
      integer            incx, lda, n
      complex            alpha
      complex            a( lda, * ), x( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, info, ix, j, jx, kx
      complex            temp
      logical            lsame
      end subroutine csyr

      !! csyrfs.f
      subroutine csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine csyrfs

      !! csyrfsx.f
      subroutine csyrfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    s, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, clansy, cla_syrcond_x, cla_syrcond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine csyrfsx

      !! csysv.f
      subroutine csysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine csysv

      !! csysv_rook.f
      subroutine csysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine csysv_rook

      !! csysvx.f
      subroutine csysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,
     &                   ldb, x, ldx, rcond, ferr, berr, work, lwork,
     &                   rwork, info )
      character          fact, uplo
      integer            info, lda, ldaf, ldb, ldx, lwork, n, nrhs
      real               rcond
      integer            ipiv( * )
      real               berr( * ), ferr( * ), rwork( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery, nofact
      integer            lwkopt, nb
      real               anorm
      logical            lsame
      integer            ilaenv
      real               clansy, slamch
      end subroutine csysvx

      !! csysvxx.f
      subroutine csysvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            ipiv( * )
      complex            a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      real               amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      real               slamch, cla_syrpvgrw
      end subroutine csysvxx

      !! csyswapr.f
      subroutine csyswapr( uplo, n, a, lda, i1, i2)
      character        uplo
      integer          i1, i2, lda, n
      complex          a( lda, n )
      logical            upper
      integer            i
      complex            tmp
      logical            lsame
      end subroutine csyswapr

      !! csytf2.f
      subroutine csytf2( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i, imax, j, jmax, k, kk, kp, kstep
      real               absakk, alpha, colmax, rowmax
      complex            d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, z
      logical            lsame, sisnan
      integer            icamax
      real               cabs1
      end subroutine csytf2

      !! csytf2_rook.f
      subroutine csytf2_rook( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper, done
      integer            i, imax, j, jmax, itemp, k, kk, kp, kstep,
     &                   p, ii
      real               absakk, alpha, colmax, rowmax, stemp, sfmin
      complex            d11, d12, d21, d22, t, wk, wkm1, wkp1, z
      logical            lsame
      integer            icamax
      real               slamch
      real               cabs1
      end subroutine csytf2_rook

      !! csytrf.f
      subroutine csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine csytrf

      !! csytrf_rook.f
      subroutine csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine csytrf_rook

      !! csytri2.f
      subroutine csytri2( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      logical            upper, lquery
      integer            minsize, nbmax
      logical            lsame
      integer            ilaenv
      end subroutine csytri2

      !! csytri2x.f
      subroutine csytri2x( uplo, n, a, lda, ipiv, work, nb, info )
      character          uplo
      integer            info, lda, n, nb
      integer            ipiv( * )
      complex            a( lda, * ), work( n+nb+1,* )
      complex              one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i, iinfo, ip, k, cut, nnb
      integer            count
      integer            j, u11, invd
      complex   ak, akkp1, akp1, d, t
      complex   u01_i_j, u01_ip1_j
      complex   u11_i_j, u11_ip1_j
      logical            lsame
      end subroutine csytri2x

      !! csytri.f
      subroutine csytri( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            k, kp, kstep
      complex            ak, akkp1, akp1, d, t, temp
      logical            lsame
      complex            cdotu
      end subroutine csytri

      !! csytri_rook.f
      subroutine csytri_rook( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex            a( lda, * ), work( * )
      complex            cone, czero
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ),
     &                   czero = ( 0.0e+0, 0.0e+0 ) )
      logical            upper
      integer            k, kp, kstep
      complex            ak, akkp1, akp1, d, t, temp
      logical            lsame
      complex            cdotu
      end subroutine csytri_rook

      !! csytrs2.f
      subroutine csytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                    work, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * ), work( * )
      complex            one
      parameter          ( one = (1.0e+0,0.0e+0) )
      logical            upper
      integer            i, iinfo, j, k, kp
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine csytrs2

      !! csytrs.f
      subroutine csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kp
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine csytrs

      !! csytrs_rook.f
      subroutine csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                        info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex            a( lda, * ), b( ldb, * )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            j, k, kp
      complex            ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine csytrs_rook

      !! ctbcon.f
      subroutine ctbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,
     &                   rwork, info )
      character          diag, norm, uplo
      integer            info, kd, ldab, n
      real               rcond
      real               rwork( * )
      complex            ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, anorm, scale, smlnum, xnorm
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               clantb, slamch
      real               cabs1
      end subroutine ctbcon

      !! ctbrfs.f
      subroutine ctbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, x, ldx, ferr, berr, work, rwork, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, ldx, n, nrhs
      real               berr( * ), ferr( * ), rwork( * )
      complex            ab( ldab, * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            notran, nounit, upper
      character          transn, transt
      integer            i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine ctbrfs

      !! ctbtrs.f
      subroutine ctbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, n, nrhs
      complex            ab( ldab, * ), b( ldb, * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      logical            nounit, upper
      integer            j
      logical            lsame
      end subroutine ctbtrs

      !! ctfsm.f
      subroutine ctfsm( transr, side, uplo, trans, diag, m, n, alpha, a,
     &                  b, ldb )
      character          transr, diag, side, trans, uplo
      integer            ldb, m, n
      complex            alpha
      complex            a( 0: * ), b( 0: ldb-1, 0: * )
      complex            cone, czero
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ),
     &                   czero = ( 0.0e+0, 0.0e+0 ) )
      logical            lower, lside, misodd, nisodd, normaltransr,
     &                   notrans
      integer            m1, m2, n1, n2, k, info, i, j
      logical            lsame
      end subroutine ctfsm

      !! ctftri.f
      subroutine ctftri( transr, uplo, diag, n, a, info )
      character          transr, uplo, diag
      integer            info, n
      complex            a( 0: * )
      complex            cone
      parameter          ( cone = ( 1.0e+0, 0.0e+0 ) )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine ctftri

      !! ctfttp.f
      subroutine ctfttp( transr, uplo, n, arf, ap, info )
      character          transr, uplo
      integer            info, n
      complex            ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine ctfttp

      !! ctfttr.f
      subroutine ctfttr( transr, uplo, n, arf, a, lda, info )
      character          transr, uplo
      integer            info, n, lda
      complex            a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt, nx2, np1x2
      integer            i, j, l, ij
      logical            lsame
      end subroutine ctfttr

      !! ctgevc.f
      subroutine ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,
     &                   ldvl, vr, ldvr, mm, m, work, rwork, info )
      character          howmny, side
      integer            info, ldp, lds, ldvl, ldvr, m, mm, n
      logical            select( * )
      real               rwork( * )
      complex            p( ldp, * ), s( lds, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            compl, compr, ilall, ilback, ilbbad, ilcomp,
     &                   lsa, lsb
      integer            i, ibeg, ieig, iend, ihwmny, im, iside, isrc,
     &                   j, je, jr
      real               acoefa, acoeff, anorm, ascale, bcoefa, big,
     &                   bignum, bnorm, bscale, dmin, safmin, sbeta,
     &                   scale, small, temp, ulp, xmax
      complex            bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
      logical            lsame
      real               slamch
      complex            cladiv
      real               abs1
      end subroutine ctgevc

      !! ctgex2.f
      subroutine ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, j1, info )
      logical            wantq, wantz
      integer            info, j1, lda, ldb, ldq, ldz, n
      complex            a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      real               twenty
      parameter          ( twenty = 2.0e+1 )
      integer            ldst
      parameter          ( ldst = 2 )
      logical            wands
      parameter          ( wands = .true. )
      logical            strong, weak
      integer            i, m
      real               cq, cz, eps, sa, sb, scale, smlnum, ss, sum,
     &                   thresh, ws
      complex            cdum, f, g, sq, sz
      complex            s( ldst, ldst ), t( ldst, ldst ), work( 8 )
      real               slamch
      end subroutine ctgex2

      !! ctgexc.f
      subroutine ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, ifst, ilst, info )
      logical            wantq, wantz
      integer            ifst, ilst, info, lda, ldb, ldq, ldz, n
      complex            a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      integer            here
      end subroutine ctgexc

      !! ctgsen.f
      subroutine ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,
     &                   alpha, beta, q, ldq, z, ldz, m, pl, pr, dif,
     &                   work, lwork, iwork, liwork, info )
      logical            wantq, wantz
      integer            ijob, info, lda, ldb, ldq, ldz, liwork, lwork,
     &                   m, n
      real               pl, pr
      logical            select( * )
      integer            iwork( * )
      real               dif( * )
      complex            a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), q( ldq, * ), work( * ), z( ldz, * )
      integer            idifjb
      parameter          ( idifjb = 3 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, swap, wantd, wantd1, wantd2, wantp
      integer            i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2,
     &                   n1, n2
      real               dscale, dsum, rdscal, safmin
      complex            temp1, temp2
      integer            isave( 3 )
      real               slamch
      end subroutine ctgsen

      !! ctgsja.f
      subroutine ctgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,
     &                   ldb, tola, tolb, alpha, beta, u, ldu, v, ldv,
     &                   q, ldq, work, ncycle, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n,
     &                   ncycle, p
      real               tola, tolb
      real               alpha( * ), beta( * )
      complex            a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   u( ldu, * ), v( ldv, * ), work( * )
      integer            maxit
      parameter          ( maxit = 40 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            initq, initu, initv, upper, wantq, wantu, wantv
      integer            i, j, kcycle
      real               a1, a3, b1, b3, csq, csu, csv, error, gamma,
     &                   rwk, ssmin
      complex            a2, b2, snq, snu, snv
      logical            lsame
      end subroutine ctgsja

      !! ctgsna.f
      subroutine ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,
     &                   ldvl, vr, ldvr, s, dif, mm, m, work, lwork,
     &                   iwork, info )
      character          howmny, job
      integer            info, lda, ldb, ldvl, ldvr, lwork, m, mm, n
      logical            select( * )
      integer            iwork( * )
      real               dif( * ), s( * )
      complex            a( lda, * ), b( ldb, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      real               zero, one
      integer            idifjb
      parameter          ( zero = 0.0e+0, one = 1.0e+0, idifjb = 3 )
      logical            lquery, somcon, wantbh, wantdf, wants
      integer            i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
      real               bignum, cond, eps, lnrm, rnrm, scale, smlnum
      complex            yhax, yhbx
      complex            dummy( 1 ), dummy1( 1 )
      logical            lsame
      real               scnrm2, slamch, slapy2
      complex            cdotc
      end subroutine ctgsna

      !! ctgsy2.f
      subroutine ctgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, rdsum, rdscal,
     &                   info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf, m, n
      real               rdscal, rdsum, scale
      complex            a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * )
      real               zero, one
      integer            ldz
      parameter          ( zero = 0.0e+0, one = 1.0e+0, ldz = 2 )
      logical            notran
      integer            i, ierr, j, k
      real               scaloc
      complex            alpha
      integer            ipiv( ldz ), jpiv( ldz )
      complex            rhs( ldz ), z( ldz, ldz )
      logical            lsame
      end subroutine ctgsy2

      !! ctgsyl.f
      subroutine ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, dif, work, lwork,
     &                   iwork, info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf,
     &                   lwork, m, n
      real               dif, scale
      integer            iwork( * )
      complex            a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            czero
      parameter          ( czero = (0.0e+0, 0.0e+0) )
      logical            lquery, notran
      integer            i, ie, ifunc, iround, is, isolve, j, je, js, k,
     &                   linfo, lwmin, mb, nb, p, pq, q
      real               dscale, dsum, scale2, scaloc
      logical            lsame
      integer            ilaenv
      end subroutine ctgsyl

      !! ctpcon.f
      subroutine ctpcon( norm, uplo, diag, n, ap, rcond, work, rwork,
     &                   info )
      character          diag, norm, uplo
      integer            info, n
      real               rcond
      real               rwork( * )
      complex            ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, anorm, scale, smlnum, xnorm
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               clantp, slamch
      real               cabs1
      end subroutine ctpcon

      !! ctpmqrt.f
      subroutine ctpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,
     &                    a, lda, b, ldb, work, info )
      character side, trans
      integer   info, k, ldv, lda, ldb, m, n, l, nb, ldt
      complex   v( ldv, * ), a( lda, * ), b( ldb, * ), t( ldt, * ),
     &          work( * )
      logical            left, right, tran, notran
      integer            i, ib, mb, lb, kf, ldaq, ldvq
      logical            lsame
      end subroutine ctpmqrt

      !! ctpqrt2.f
      subroutine ctpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
      integer   info, lda, ldb, ldt, n, m, l
      complex   a( lda, * ), b( ldb, * ), t( ldt, * )
      complex  one, zero
      parameter( one = (1.0,0.0), zero = (0.0,0.0) )
      integer   i, j, p, mp, np
      complex   alpha
      end subroutine ctpqrt2

      !! ctpqrt.f
      subroutine ctpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,
     &                   info )
      integer info, lda, ldb, ldt, n, m, l, nb
      complex a( lda, * ), b( ldb, * ), t( ldt, * ), work( * )
      integer    i, ib, lb, mb, iinfo
      end subroutine ctpqrt

      !! ctprfb.f
      subroutine ctprfb( side, trans, direct, storev, m, n, k, l,
     &                   v, ldv, t, ldt, a, lda, b, ldb, work, ldwork )
      character direct, side, storev, trans
      integer   k, l, lda, ldb, ldt, ldv, ldwork, m, n
      complex   a( lda, * ), b( ldb, * ), t( ldt, * ),
     &          v( ldv, * ), work( ldwork, * )
      complex   one, zero
      parameter ( one = (1.0,0.0), zero = (0.0,0.0) )
      integer   i, j, mp, np, kp
      logical   left, forward, column, right, backward, row
      logical   lsame
      end subroutine ctprfb

      !! ctprfs.f
      subroutine ctprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          diag, trans, uplo
      integer            info, ldb, ldx, n, nrhs
      real               berr( * ), ferr( * ), rwork( * )
      complex            ap( * ), b( ldb, * ), work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            notran, nounit, upper
      character          transn, transt
      integer            i, j, k, kase, kc, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine ctprfs

      !! ctptri.f
      subroutine ctptri( uplo, diag, n, ap, info )
      character          diag, uplo
      integer            info, n
      complex            ap( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            nounit, upper
      integer            j, jc, jclast, jj
      complex            ajj
      logical            lsame
      end subroutine ctptri

      !! ctptrs.f
      subroutine ctptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
      character          diag, trans, uplo
      integer            info, ldb, n, nrhs
      complex            ap( * ), b( ldb, * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      logical            nounit, upper
      integer            j, jc
      logical            lsame
      end subroutine ctptrs

      !! ctpttf.f
      subroutine ctpttf( transr, uplo, n, ap, arf, info )
      character          transr, uplo
      integer            info, n
      complex            ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine ctpttf

      !! ctpttr.f
      subroutine ctpttr( uplo, n, ap, a, lda, info )
      character          uplo
      integer            info, n, lda
      complex            a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine ctpttr

      !! ctrcon.f
      subroutine ctrcon( norm, uplo, diag, n, a, lda, rcond, work,
     &                   rwork, info )
      character          diag, norm, uplo
      integer            info, lda, n
      real               rcond
      real               rwork( * )
      complex            a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, anorm, scale, smlnum, xnorm
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      integer            icamax
      real               clantr, slamch
      real               cabs1
      end subroutine ctrcon

      !! ctrevc.f
      subroutine ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, mm, m, work, rwork, info )
      character          howmny, side
      integer            info, ldt, ldvl, ldvr, m, mm, n
      logical            select( * )
      real               rwork( * )
      complex            t( ldt, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      complex            cmzero, cmone
      parameter          ( cmzero = ( 0.0e+0, 0.0e+0 ),
     &                   cmone = ( 1.0e+0, 0.0e+0 ) )
      logical            allv, bothv, leftv, over, rightv, somev
      integer            i, ii, is, j, k, ki
      real               ovfl, remax, scale, smin, smlnum, ulp, unfl
      complex            cdum
      logical            lsame
      integer            icamax
      real               scasum, slamch
      real               cabs1
      end subroutine ctrevc

      !! ctrexc.f
      subroutine ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
      character          compq
      integer            ifst, ilst, info, ldq, ldt, n
      complex            q( ldq, * ), t( ldt, * )
      logical            wantq
      integer            k, m1, m2, m3
      real               cs
      complex            sn, t11, t22, temp
      logical            lsame
      end subroutine ctrexc

      !! ctrrfs.f
      subroutine ctrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,
     &                   ldx, ferr, berr, work, rwork, info )
      character          diag, trans, uplo
      integer            info, lda, ldb, ldx, n, nrhs
      real               berr( * ), ferr( * ), rwork( * )
      complex            a( lda, * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            notran, nounit, upper
      character          transn, transt
      integer            i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      complex            zdum
      integer            isave( 3 )
      logical            lsame
      real               slamch
      real               cabs1
      end subroutine ctrrfs

      !! ctrsen.f
      subroutine ctrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,
     &                   sep, work, lwork, info )
      character          compq, job
      integer            info, ldq, ldt, lwork, m, n
      real               s, sep
      logical            select( * )
      complex            q( ldq, * ), t( ldt, * ), w( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, wantbh, wantq, wants, wantsp
      integer            ierr, k, kase, ks, lwmin, n1, n2, nn
      real               est, rnorm, scale
      integer            isave( 3 )
      real               rwork( 1 )
      logical            lsame
      real               clange
      end subroutine ctrsen

      !! ctrsna.f
      subroutine ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, s, sep, mm, m, work, ldwork, rwork,
     &                   info )
      character          howmny, job
      integer            info, ldt, ldvl, ldvr, ldwork, m, mm, n
      logical            select( * )
      real               rwork( * ), s( * ), sep( * )
      complex            t( ldt, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( ldwork, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0+0 )
      logical            somcon, wantbh, wants, wantsp
      character          normin
      integer            i, ierr, ix, j, k, kase, ks
      real               bignum, eps, est, lnrm, rnrm, scale, smlnum,
     &                   xnorm
      complex            cdum, prod
      integer            isave( 3 )
      complex            dummy( 1 )
      logical            lsame
      integer            icamax
      real               scnrm2, slamch
      complex            cdotc
      real               cabs1
      end subroutine ctrsna

      !! ctrsyl.f
      subroutine ctrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,
     &                   ldc, scale, info )
      character          trana, tranb
      integer            info, isgn, lda, ldb, ldc, m, n
      real               scale
      complex            a( lda, * ), b( ldb, * ), c( ldc, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            notrna, notrnb
      integer            j, k, l
      real               bignum, da11, db, eps, scaloc, sgn, smin,
     &                   smlnum
      complex            a11, suml, sumr, vec, x11
      real               dum( 1 )
      logical            lsame
      real               clange, slamch
      complex            cdotc, cdotu, cladiv
      end subroutine ctrsyl

      !! ctrti2.f
      subroutine ctrti2( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      complex            a( lda, * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            nounit, upper
      integer            j
      complex            ajj
      logical            lsame
      end subroutine ctrti2

      !! ctrtri.f
      subroutine ctrtri( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      complex            a( lda, * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      logical            nounit, upper
      integer            j, jb, nb, nn
      logical            lsame
      integer            ilaenv
      end subroutine ctrtri

      !! ctrtrs.f
      subroutine ctrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,
     &                   info )
      character          diag, trans, uplo
      integer            info, lda, ldb, n, nrhs
      complex            a( lda, * ), b( ldb, * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      logical            nounit
      logical            lsame
      end subroutine ctrtrs

      !! ctrttf.f
      subroutine ctrttf( transr, uplo, n, a, lda, arf, info )
      character          transr, uplo
      integer            info, n, lda
      complex            a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            i, ij, j, k, l, n1, n2, nt, nx2, np1x2
      logical            lsame
      end subroutine ctrttf

      !! ctrttp.f
      subroutine ctrttp( uplo, n, a, lda, ap, info )
      character          uplo
      integer            info, n, lda
      complex            a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine ctrttp

      !! ctzrzf.f
      subroutine ctzrzf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, ib, iws, ki, kk, ldwork, lwkmin, lwkopt,
     &                   m1, mu, nb, nbmin, nx
      integer            ilaenv
      end subroutine ctzrzf

      !! cunbdb1.f
      subroutine cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      complex            taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      complex            one
      parameter          ( one = (1.0e0,0.0e0) )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      real               scnrm2
      end subroutine cunbdb1

      !! cunbdb2.f
      subroutine cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      complex            taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      complex            negone, one
      parameter          ( negone = (-1.0e0,0.0e0),
     &                     one = (1.0e0,0.0e0) )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      real               scnrm2
      end subroutine cunbdb2

      !! cunbdb3.f
      subroutine cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      complex            taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      complex            one
      parameter          ( one = (1.0e0,0.0e0) )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      real               scnrm2
      end subroutine cunbdb3

      !! cunbdb4.f
      subroutine cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, phantom, work, lwork,
     &                    info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      complex            phantom(*), taup1(*), taup2(*), tauq1(*),
     &                   work(*), x11(ldx11,*), x21(ldx21,*)
      complex            negone, one, zero
      parameter          ( negone = (-1.0e0,0.0e0), one = (1.0e0,0.0e0),
     &                     zero = (0.0e0,0.0e0) )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, j, llarf,
     &                   lorbdb5, lworkmin, lworkopt
      logical            lquery
      real               scnrm2
      end subroutine cunbdb4

      !! cunbdb5.f
      subroutine cunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      complex            q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      complex            one, zero
      parameter          ( one = (1.0e0,0.0e0), zero = (0.0e0,0.0e0) )
      integer            childinfo, i, j
      real               scnrm2
      end subroutine cunbdb5

      !! cunbdb6.f
      subroutine cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      complex            q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      real               alphasq, realone, realzero
      parameter          ( alphasq = 0.01e0, realone = 1.0e0,
     &                     realzero = 0.0e0 )
      complex            negone, one, zero
      parameter          ( negone = (-1.0e0,0.0e0), one = (1.0e0,0.0e0),
     &                     zero = (0.0e0,0.0e0) )
      integer            i
      real               normsq1, normsq2, scl1, scl2, ssq1, ssq2
      end subroutine cunbdb6

      !! cunbdb.f
      subroutine cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,
     &                   x21, ldx21, x22, ldx22, theta, phi, taup1,
     &                   taup2, tauq1, tauq2, work, lwork, info )
      character          signs, trans
      integer            info, ldx11, ldx12, ldx21, ldx22, lwork, m, p,
     &                   q
      real               phi( * ), theta( * )
      complex            taup1( * ), taup2( * ), tauq1( * ), tauq2( * ),
     &                   work( * ), x11( ldx11, * ), x12( ldx12, * ),
     &                   x21( ldx21, * ), x22( ldx22, * )
      real               realone
      parameter          ( realone = 1.0e0 )
      complex            one
      parameter          ( one = (1.0e0,0.0e0) )
      logical            colmajor, lquery
      integer            i, lworkmin, lworkopt
      real               z1, z2, z3, z4
      real               scnrm2
      logical            lsame
      end subroutine cunbdb

      !! cuncsd2by1.f
      subroutine cuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,
     &                       x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t,
     &                       ldv1t, work, lwork, rwork, lrwork, iwork,
     &                       info )
      character          jobu1, jobu2, jobv1t
      integer            info, ldu1, ldu2, ldv1t, lwork, ldx11, ldx21,
     &                   m, p, q
      integer            lrwork, lrworkmin, lrworkopt
      real               rwork(*)
      real               theta(*)
      complex            u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      integer            iwork(*)
      complex            one, zero
      parameter          ( one = (1.0e0,0.0e0), zero = (0.0e0,0.0e0) )
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   j, lbbcsd, lorbdb, lorglq, lorglqmin,
     &                   lorglqopt, lorgqr, lorgqrmin, lorgqropt,
     &                   lworkmin, lworkopt, r
      logical            lquery, wantu1, wantu2, wantv1t
      logical            lsame
      end subroutine cuncsd2by1

      !! cuncsd.f
      recursive subroutine cuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,
     &                             signs, m, p, q, x11, ldx11, x12,
     &                             ldx12, x21, ldx21, x22, ldx22, theta,
     &                             u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,
     &                             ldv2t, work, lwork, rwork, lrwork,
     &                             iwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, signs, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12,
     &                   ldx21, ldx22, lrwork, lwork, m, p, q
      integer            iwork( * )
      real               theta( * )
      real               rwork( * )
      complex            u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * ), work( * ), x11( ldx11, * ),
     &                   x12( ldx12, * ), x21( ldx21, * ), x22( ldx22,
     &                   * )
      complex            one, zero
      parameter          ( one = (1.0e0,0.0e0),
     &                     zero = (0.0e0,0.0e0) )
      character          transt, signst
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   itauq2, j, lbbcsdwork, lbbcsdworkmin,
     &                   lbbcsdworkopt, lorbdbwork, lorbdbworkmin,
     &                   lorbdbworkopt, lorglqwork, lorglqworkmin,
     &                   lorglqworkopt, lorgqrwork, lorgqrworkmin,
     &                   lorgqrworkopt, lworkmin, lworkopt, p1, q1
      logical            colmajor, defaultsigns, lquery, wantu1, wantu2,
     &                   wantv1t, wantv2t
      integer            lrworkmin, lrworkopt
      logical            lrquery
      logical            lsame
      end subroutine cuncsd

      !! cung2l.f
      subroutine cung2l( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, ii, j, l
      end subroutine cung2l

      !! cung2r.f
      subroutine cung2r( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, j, l
      end subroutine cung2r

      !! cungbr.f
      subroutine cungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
      character          vect
      integer            info, k, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery, wantq
      integer            i, iinfo, j, lwkopt, mn
      logical            lsame
      integer            ilaenv
      end subroutine cungbr

      !! cunghr.f
      subroutine cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, iinfo, j, lwkopt, nb, nh
      integer            ilaenv
      end subroutine cunghr

      !! cungl2.f
      subroutine cungl2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, j, l
      end subroutine cungl2

      !! cunglq.f
      subroutine cunglq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine cunglq

      !! cungql.f
      subroutine cungql( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iws, j, kk, l, ldwork, lwkopt,
     &                   nb, nbmin, nx
      integer            ilaenv
      end subroutine cungql

      !! cungqr.f
      subroutine cungqr( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine cungqr

      !! cungr2.f
      subroutine cungr2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            one, zero
      parameter          ( one = ( 1.0e+0, 0.0e+0 ),
     &                   zero = ( 0.0e+0, 0.0e+0 ) )
      integer            i, ii, j, l
      end subroutine cungr2

      !! cungrq.f
      subroutine cungrq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ) )
      logical            lquery
      integer            i, ib, ii, iinfo, iws, j, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine cungrq

      !! cungtr.f
      subroutine cungtr( uplo, n, a, lda, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      complex            a( lda, * ), tau( * ), work( * )
      complex            zero, one
      parameter          ( zero = ( 0.0e+0, 0.0e+0 ),
     &                   one = ( 1.0e+0, 0.0e+0 ) )
      logical            lquery, upper
      integer            i, iinfo, j, lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine cungtr

      !! cunm22.f
      subroutine cunm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            m, n, n1, n2, ldq, ldc, lwork, info
      complex            q( ldq, * ), c( ldc, * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            left, lquery, notran
      integer            i, ldwork, len, lwkopt, nb, nq, nw
      logical            lsame
      end subroutine cunm22

      !! cunm2l.f
      subroutine cunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      complex            aii, taui
      logical            lsame
      end subroutine cunm2l

      !! cunm2r.f
      subroutine cunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      complex            aii, taui
      logical            lsame
      end subroutine cunm2r

      !! cunmbr.f
      subroutine cunmbr( vect, side, trans, m, n, k, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans, vect
      integer            info, k, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      logical            applyq, left, lquery, notran
      character          transt
      integer            i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmbr

      !! cunmhr.f
      subroutine cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans
      integer            ihi, ilo, info, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      logical            left, lquery
      integer            i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmhr

      !! cunml2.f
      subroutine cunml2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      complex            aii, taui
      logical            lsame
      end subroutine cunml2

      !! cunmlq.f
      subroutine cunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmlq

      !! cunmql.f
      subroutine cunmql( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmql

      !! cunmqr.f
      subroutine cunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmqr

      !! cunmr2.f
      subroutine cunmr2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      complex            aii, taui
      logical            lsame
      end subroutine cunmr2

      !! cunmr3.f
      subroutine cunmr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, l, lda, ldc, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, notran
      integer            i, i1, i2, i3, ic, ja, jc, mi, ni, nq
      complex            taui
      logical            lsame
      end subroutine cunmr3

      !! cunmrq.f
      subroutine cunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmrq

      !! cunmrz.f
      subroutine cunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, l, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, ja, jc,
     &                   ldwork, lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmrz

      !! cunmtr.f
      subroutine cunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans, uplo
      integer            info, lda, ldc, lwork, m, n
      complex            a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      logical            left, lquery, upper
      integer            i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine cunmtr

      !! cupgtr.f
      subroutine cupgtr( uplo, n, ap, tau, q, ldq, work, info )
      character          uplo
      integer            info, ldq, n
      complex            ap( * ), q( ldq, * ), tau( * ), work( * )
      complex            czero, cone
      parameter          ( czero = ( 0.0e+0, 0.0e+0 ),
     &                   cone = ( 1.0e+0, 0.0e+0 ) )
      logical            upper
      integer            i, iinfo, ij, j
      logical            lsame
      end subroutine cupgtr

      !! cupmtr.f
      subroutine cupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,
     &                   info )
      character          side, trans, uplo
      integer            info, ldc, m, n
      complex            ap( * ), c( ldc, * ), tau( * ), work( * )
      complex            one
      parameter          ( one = ( 1.0e+0, 0.0e+0 ) )
      logical            forwrd, left, notran, upper
      integer            i, i1, i2, i3, ic, ii, jc, mi, ni, nq
      complex            aii, taui
      logical            lsame
      end subroutine cupmtr

      !! dbbcsd.f
      subroutine dbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,
     &                   theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t,
     &                   v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,
     &                   b22d, b22e, work, lwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
      double precision   b11d( * ), b11e( * ), b12d( * ), b12e( * ),
     &                   b21d( * ), b21e( * ), b22d( * ), b22e( * ),
     &                   phi( * ), theta( * ), work( * )
      double precision   u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * )
      integer            maxitr
      parameter          ( maxitr = 6 )
      double precision   hundred, meighth, one, piover2, ten, zero
      parameter          ( hundred = 100.0d0, meighth = -0.125d0,
     &                     one = 1.0d0, piover2 = 1.57079632679489662d0,
     &                     ten = 10.0d0, zero = 0.0d0 )
      double precision   negone
      parameter          ( negone = -1.0d0 )
      logical            colmajor, lquery, restart11, restart12,
     &                   restart21, restart22, wantu1, wantu2, wantv1t,
     &                   wantv2t
      integer            i, imin, imax, iter, iu1cs, iu1sn, iu2cs,
     &                   iu2sn, iv1tcs, iv1tsn, iv2tcs, iv2tsn, j,
     &                   lworkmin, lworkopt, maxit, mini
      double precision   b11bulge, b12bulge, b21bulge, b22bulge, dummy,
     &                   eps, mu, nu, r, sigma11, sigma21,
     &                   temp, thetamax, thetamin, thresh, tol, tolmul,
     &                   unfl, x1, x2, y1, y2
      double precision   dlamch
      logical            lsame
      end subroutine dbbcsd

      !! dbdsdc.f
      subroutine dbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,
     &                   work, iwork, info )
      character          compq, uplo
      integer            info, ldu, ldvt, n
      integer            iq( * ), iwork( * )
      double precision   d( * ), e( * ), q( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      integer            difl, difr, givcol, givnum, givptr, i, ic,
     &                   icompq, ierr, ii, is, iu, iuplo, ivt, j, k, kk,
     &                   mlvl, nm1, nsize, perm, poles, qstart, smlsiz,
     &                   smlszp, sqre, start, wstart, z
      double precision   cs, eps, orgnrm, p, r, sn
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlanst
      end subroutine dbdsdc

      !! dbdsqr.f
      subroutine dbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,
     &                   ldu, c, ldc, work, info )
      character          uplo
      integer            info, ldc, ldu, ldvt, n, ncc, ncvt, nru
      double precision   c( ldc, * ), d( * ), e( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   negone
      parameter          ( negone = -1.0d0 )
      double precision   hndrth
      parameter          ( hndrth = 0.01d0 )
      double precision   ten
      parameter          ( ten = 10.0d0 )
      double precision   hndrd
      parameter          ( hndrd = 100.0d0 )
      double precision   meigth
      parameter          ( meigth = -0.125d0 )
      integer            maxitr
      parameter          ( maxitr = 6 )
      logical            lower, rotate
      integer            i, idir, isub, iter, j, ll, lll, m, maxit, nm1,
     &                   nm12, nm13, oldll, oldm
      double precision   abse, abss, cosl, cosr, cs, eps, f, g, h, mu,
     &                   oldcs, oldsn, r, shift, sigmn, sigmx, sinl,
     &                   sinr, sll, smax, smin, sminl, sminoa,
     &                   sn, thresh, tol, tolmul, unfl
      logical            lsame
      double precision   dlamch
      end subroutine dbdsqr

      !! dbdsvdx.f
      subroutine dbdsvdx( uplo, jobz, range, n, d, e, vl, vu, il, iu,
     &                    ns, s, z, ldz, work, iwork, info)
      character          jobz, range, uplo
      integer            il, info, iu, ldz, n, ns
      double precision   vl, vu
      integer            iwork( * )
      double precision   d( * ), e( * ), s( * ), work( * ),
     &                   z( ldz, * )
      double precision   zero, one, ten, hndrd, meigth
      parameter          ( zero = 0.0d0, one = 1.0d0, ten = 10.0d0,
     &                     hndrd = 100.0d0, meigth = -0.1250d0 )
      double precision   fudge
      parameter          ( fudge = 2.0d0 )
      character          rngvx
      logical            allsv, indsv, lower, split, sveq0, valsv, wantz
      integer            i, icolz, idbeg, idend, idtgk, idptr, ieptr,
     &                   ietgk, iifail, iiwork, iltgk, irowu, irowv,
     &                   irowz, isbeg, isplt, itemp, iutgk, j, k,
     &                   ntgk, nru, nrv, nsl
      double precision   abstol, eps, emin, mu, nrmu, nrmv, ortol, smax,
     &                   smin, sqrt2, thresh, tol, ulp,
     &                   vltgk, vutgk, zjtji
      logical            lsame
      integer            idamax
      double precision   ddot, dlamch, dnrm2
      end subroutine dbdsvdx

      !! ddisna.f
      subroutine ddisna( job, m, n, d, sep, info )
      character          job
      integer            info, m, n
      double precision   d( * ), sep( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            decr, eigen, incr, left, right, sing
      integer            i, k
      double precision   anorm, eps, newgap, oldgap, safmin, thresh
      logical            lsame
      double precision   dlamch
      end subroutine ddisna

      !! dgbbrd.f
      subroutine dgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,
     &                   ldq, pt, ldpt, c, ldc, work, info )
      character          vect
      integer            info, kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
      double precision   ab( ldab, * ), c( ldc, * ), d( * ), e( * ),
     &                   pt( ldpt, * ), q( ldq, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            wantb, wantc, wantpt, wantq
      integer            i, inca, j, j1, j2, kb, kb1, kk, klm, klu1,
     &                   kun, l, minmn, ml, ml0, mn, mu, mu0, nr, nrt
      double precision   ra, rb, rc, rs
      logical            lsame
      end subroutine dgbbrd

      !! dgbcon.f
      subroutine dgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,
     &                   work, iwork, info )
      character          norm
      integer            info, kl, ku, ldab, n
      double precision   anorm, rcond
      integer            ipiv( * ), iwork( * )
      double precision   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            lnoti, onenrm
      character          normin
      integer            ix, j, jp, kase, kase1, kd, lm
      double precision   ainvnm, scale, smlnum, t
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   ddot, dlamch
      end subroutine dgbcon

      !! dgbequb.f
      subroutine dgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                    amax, info )
      integer            info, kl, ku, ldab, m, n
      double precision   amax, colcnd, rowcnd
      double precision   ab( ldab, * ), c( * ), r( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, kd
      double precision   bignum, rcmax, rcmin, smlnum, radix, logrdx
      double precision   dlamch
      end subroutine dgbequb

      !! dgbequ.f
      subroutine dgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, info )
      integer            info, kl, ku, ldab, m, n
      double precision   amax, colcnd, rowcnd
      double precision   ab( ldab, * ), c( * ), r( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, kd
      double precision   bignum, rcmax, rcmin, smlnum
      double precision   dlamch
      end subroutine dgbequ

      !! dgbrfs.f
      subroutine dgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, iwork,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            notran
      character          transt
      integer            count, i, j, k, kase, kk, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dgbrfs

      !! dgbrfsx.f
      subroutine dgbrfsx( trans, equed, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, r, c, b, ldb, x, ldx, rcond,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, iwork,
     &                    info )
      character          trans, equed
      integer            info, ldab, ldafb, ldb, ldx, n, kl, ku, nrhs,
     &                   nparams, n_err_bnds
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran
      integer            j, trans_type, prec_type, ref_type
      integer            n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, dlangb, dla_gbrcond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine dgbrfsx

      !! dgbsv.f
      subroutine dgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      double precision   ab( ldab, * ), b( ldb, * )
      end subroutine dgbsv

      !! dgbsvx.f
      subroutine dgbsvx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                   ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, iwork, info )
      character          equed, fact, trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), c( * ), ferr( * ), r( * ),
     &                   work( * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j, j1, j2
      double precision   amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      double precision   dlamch, dlangb, dlantb
      end subroutine dgbsvx

      !! dgbsvxx.f
      subroutine dgbsvxx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                    rcond, rpvgrw, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          equed, fact, trans
      integer            info, ldab, ldafb, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds, kl, ku
      double precision   rcond, rpvgrw
      integer            ipiv( * ), iwork( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, i, j
      double precision   amax, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, smlnum
      logical            lsame
      double precision   dlamch, dla_gbrpvgrw
      end subroutine dgbsvxx

      !! dgbtf2.f
      subroutine dgbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      double precision   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, jp, ju, km, kv
      integer            idamax
      end subroutine dgbtf2

      !! dgbtrf.f
      subroutine dgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      double precision   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            nbmax, ldwork
      parameter          ( nbmax = 64, ldwork = nbmax+1 )
      integer            i, i2, i3, ii, ip, j, j2, j3, jb, jj, jm, jp,
     &                   ju, k2, km, kv, nb, nw
      double precision   temp
      double precision   work13( ldwork, nbmax ),
     &                   work31( ldwork, nbmax )
      integer            idamax, ilaenv
      end subroutine dgbtrf

      !! dgbtrs.f
      subroutine dgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      double precision   ab( ldab, * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lnoti, notran
      integer            i, j, kd, l, lm
      logical            lsame
      end subroutine dgbtrs

      !! dgebak.f
      subroutine dgebak( job, side, n, ilo, ihi, scale, m, v, ldv,
     &                   info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      double precision   scale( * ), v( ldv, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            leftv, rightv
      integer            i, ii, k
      double precision   s
      logical            lsame
      end subroutine dgebak

      !! dgebal.f
      subroutine dgebal( job, n, a, lda, ilo, ihi, scale, info )
      character          job
      integer            ihi, ilo, info, lda, n
      double precision   a( lda, * ), scale( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   sclfac
      parameter          ( sclfac = 2.0d+0 )
      double precision   factor
      parameter          ( factor = 0.95d+0 )
      logical            noconv
      integer            i, ica, iexc, ira, j, k, l, m
      double precision   c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1,
     &                   sfmin2
      logical            disnan, lsame
      integer            idamax
      double precision   dlamch, dnrm2
      end subroutine dgebal

      !! dgebd2.f
      subroutine dgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
      integer            info, lda, m, n
      double precision   a( lda, * ), d( * ), e( * ), taup( * ),
     &                   tauq( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i
      end subroutine dgebd2

      !! dgebrd.f
      subroutine dgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,
     &                   info )
      integer            info, lda, lwork, m, n
      double precision   a( lda, * ), d( * ), e( * ), taup( * ),
     &                   tauq( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lquery
      integer            i, iinfo, j, ldwrkx, ldwrky, lwkopt, minmn, nb,
     &                   nbmin, nx
      double precision   ws
      integer            ilaenv
      end subroutine dgebrd

      !! dgecon.f
      subroutine dgecon( norm, n, a, lda, anorm, rcond, work, iwork,
     &                   info )
      character          norm
      integer            info, lda, n
      double precision   anorm, rcond
      integer            iwork( * )
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            onenrm
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, scale, sl, smlnum, su
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch
      end subroutine dgecon

      !! dgeequb.f
      subroutine dgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                    info )
      integer            info, lda, m, n
      double precision   amax, colcnd, rowcnd
      double precision   a( lda, * ), c( * ), r( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   bignum, rcmax, rcmin, smlnum, radix, logrdx
      double precision   dlamch
      end subroutine dgeequb

      !! dgeequ.f
      subroutine dgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   info )
      integer            info, lda, m, n
      double precision   amax, colcnd, rowcnd
      double precision   a( lda, * ), c( * ), r( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   bignum, rcmax, rcmin, smlnum
      double precision   dlamch
      end subroutine dgeequ

      !! dgees.f
      subroutine dgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,
     &                  vs, ldvs, work, lwork, bwork, info )
      character          jobvs, sort
      integer            info, lda, ldvs, lwork, n, sdim
      logical            bwork( * )
      double precision   a( lda, * ), vs( ldvs, * ), wi( * ), work( * ),
     &                   wr( * )
      logical            select
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            cursl, lastsl, lquery, lst2sl, scalea, wantst,
     &                   wantvs
      integer            hswork, i, i1, i2, ibal, icond, ierr, ieval,
     &                   ihi, ilo, inxt, ip, itau, iwrk, maxwrk, minwrk
      double precision   anrm, bignum, cscale, eps, s, sep, smlnum
      integer            idum( 1 )
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgees

      !! dgeesx.f
      subroutine dgeesx( jobvs, sort, select, sense, n, a, lda, sdim,
     &                   wr, wi, vs, ldvs, rconde, rcondv, work, lwork,
     &                   iwork, liwork, bwork, info )
      character          jobvs, sense, sort
      integer            info, lda, ldvs, liwork, lwork, n, sdim
      double precision   rconde, rcondv
      logical            bwork( * )
      integer            iwork( * )
      double precision   a( lda, * ), vs( ldvs, * ), wi( * ), work( * ),
     &                   wr( * )
      logical            select
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            cursl, lastsl, lquery, lst2sl, scalea, wantsb,
     &                   wantse, wantsn, wantst, wantsv, wantvs
      integer            hswork, i, i1, i2, ibal, icond, ierr, ieval,
     &                   ihi, ilo, inxt, ip, itau, iwrk, liwrk, lwrk,
     &                   maxwrk, minwrk
      double precision   anrm, bignum, cscale, eps, smlnum
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgeesx

      !! dgeev.f
      subroutine dgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,
     &                  ldvr, work, lwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldvl, ldvr, lwork, n
      double precision   a( lda, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   wi( * ), work( * ), wr( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, scalea, wantvl, wantvr
      character          side
      integer            hswork, i, ibal, ierr, ihi, ilo, itau, iwrk, k,
     &                   maxwrk, minwrk, nout
      double precision   anrm, bignum, cs, cscale, eps, r, scl, smlnum,
     &                   sn
      logical            select( 1 )
      double precision   dum( 1 )
      logical            lsame
      integer            idamax, ilaenv
      double precision   dlamch, dlange, dlapy2, dnrm2
      end subroutine dgeev

      !! dgeevx.f
      subroutine dgeevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,
     &                   vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm,
     &                   rconde, rcondv, work, lwork, iwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldvl, ldvr, lwork, n
      double precision   abnrm
      integer            iwork( * )
      double precision   a( lda, * ), rconde( * ), rcondv( * ),
     &                   scale( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   wi( * ), work( * ), wr( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, scalea, wantvl, wantvr, wntsnb, wntsne,
     &                   wntsnn, wntsnv
      character          job, side
      integer            hswork, i, icond, ierr, itau, iwrk, k, maxwrk,
     &                   minwrk, nout
      double precision   anrm, bignum, cs, cscale, eps, r, scl, smlnum,
     &                   sn
      logical            select( 1 )
      double precision   dum( 1 )
      logical            lsame
      integer            idamax, ilaenv
      double precision   dlamch, dlange, dlapy2, dnrm2
      end subroutine dgeevx

      !! dgehd2.f
      subroutine dgehd2( n, ilo, ihi, a, lda, tau, work, info )
      integer            ihi, ilo, info, lda, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i
      double precision   aii
      end subroutine dgehd2

      !! dgehrd.f
      subroutine dgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      double precision  a( lda, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      double precision  zero, one
      parameter          ( zero = 0.0d+0,
     &                     one = 1.0d+0 )
      logical            lquery
      integer            i, ib, iinfo, iwt, j, ldwork, lwkopt, nb,
     &                   nbmin, nh, nx
      double precision  ei
      integer            ilaenv
      end subroutine dgehrd

      !! dgejsv.f
      subroutine dgejsv( joba, jobu, jobv, jobr, jobt, jobp,
     &                   m, n, a, lda, sva, u, ldu, v, ldv,
     &                   work, lwork, iwork, info )
      integer     info, lda, ldu, ldv, lwork, m, n
      double precision a( lda, * ), sva( n ), u( ldu, * ), v( ldv, * ),
     &            work( lwork )
      integer     iwork( * )
      character(len=1) joba, jobp, jobr, jobt, jobu, jobv
      double precision   zero,  one
      parameter ( zero = 0.0d0, one = 1.0d0 )
      double precision aapp, aaqq, aatmax, aatmin, big, big1, cond_ok,
     &        condr1, condr2, entra,  entrat, epsln,  maxprj, scalem,
     &        sconda, sfmin,  small,  temp1,  uscal1, uscal2, xsc
      integer ierr,   n1,     nr,     numrank,        p, q,   warning
      logical almort, defr,   errest, goscal, jracc,  kill,   lsvec,
     &        l2aber, l2kill, l2pert, l2rank, l2tran,
     &        noscal, rowpiv, rsvec,  transp
      double precision  dlamch, dnrm2
      integer   idamax
      logical   lsame
      end subroutine dgejsv

      !! dgelq2.f
      subroutine dgelq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i, k
      double precision   aii
      end subroutine dgelq2

      !! dgelqf.f
      subroutine dgelqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine dgelqf

      !! dgelsd.f
      subroutine dgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,
     &                   work, lwork, iwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      double precision   rcond
      integer            iwork( * )
      double precision   a( lda, * ), b( ldb, * ), s( * ), work( * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      logical            lquery
      integer            iascl, ibscl, ie, il, itau, itaup, itauq,
     &                   ldwork, liwork, maxmn, maxwrk, minmn, minwrk,
     &                   mm, mnthr, nlvl, nwork, smlsiz, wlalsd
      double precision   anrm, bignum, bnrm, eps, sfmin, smlnum
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgelsd

      !! dgels.f
      subroutine dgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,
     &                  info )
      character          trans
      integer            info, lda, ldb, lwork, m, n, nrhs
      double precision   a( lda, * ), b( ldb, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, tpsd
      integer            brow, i, iascl, ibscl, j, mn, nb, scllen, wsize
      double precision   anrm, bignum, bnrm, smlnum
      double precision   rwork( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgels

      !! dgelss.f
      subroutine dgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,
     &                   work, lwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      double precision   rcond
      double precision   a( lda, * ), b( ldb, * ), s( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery
      integer            bdspac, bl, chunk, i, iascl, ibscl, ie, il,
     &                   itau, itaup, itauq, iwork, ldwork, maxmn,
     &                   maxwrk, minmn, minwrk, mm, mnthr
      integer            lwork_dgeqrf, lwork_dormqr, lwork_dgebrd,
     &                   lwork_dormbr, lwork_dorgbr, lwork_dormlq,
     &                   lwork_dgelqf
      double precision   anrm, bignum, bnrm, eps, sfmin, smlnum, thr
      double precision   dum( 1 )
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgelss

      !! dgelsy.f
      subroutine dgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,
     &                   work, lwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      double precision   rcond
      integer            jpvt( * )
      double precision   a( lda, * ), b( ldb, * ), work( * )
      integer            imax, imin
      parameter          ( imax = 1, imin = 2 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery
      integer            i, iascl, ibscl, ismax, ismin, j, lwkmin,
     &                   lwkopt, mn, nb, nb1, nb2, nb3, nb4
      double precision   anrm, bignum, bnrm, c1, c2, s1, s2, smax,
     &                   smaxpr, smin, sminpr, smlnum, wsize
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgelsy

      !! dgemqrt.f
      subroutine dgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,
     &                   c, ldc, work, info )
      character side, trans
      integer   info, k, ldv, ldc, m, n, nb, ldt
      double precision v( ldv, * ), c( ldc, * ), t( ldt, * ), work( * )
      logical            left, right, tran, notran
      integer            i, ib, ldwork, kf, q
      logical            lsame
      end subroutine dgemqrt

      !! dgeql2.f
      subroutine dgeql2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i, k
      double precision   aii
      end subroutine dgeql2

      !! dgeqlf.f
      subroutine dgeqlf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine dgeqlf

      !! dgeqp3.f
      subroutine dgeqp3( m, n, a, lda, jpvt, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      integer            jpvt( * )
      double precision   a( lda, * ), tau( * ), work( * )
      integer            inb, inbmin, ixover
      parameter          ( inb = 1, inbmin = 2, ixover = 3 )
      logical            lquery
      integer            fjb, iws, j, jb, lwkopt, minmn, minws, na, nb,
     &                   nbmin, nfxd, nx, sm, sminmn, sn, topbmn
      integer            ilaenv
      double precision   dnrm2
      end subroutine dgeqp3

      !! dgeqr2.f
      subroutine dgeqr2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i, k
      double precision   aii
      end subroutine dgeqr2

      !! dgeqr2p.f
      subroutine dgeqr2p( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i, k
      double precision   aii
      end subroutine dgeqr2p

      !! dgeqrf.f
      subroutine dgeqrf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine dgeqrf

      !! dgeqrfp.f
      subroutine dgeqrfp( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine dgeqrfp

      !! dgeqrt2.f
      subroutine dgeqrt2( m, n, a, lda, t, ldt, info )
      integer   info, lda, ldt, m, n
      double precision   a( lda, * ), t( ldt, * )
      double precision  one, zero
      parameter( one = 1.0d+00, zero = 0.0d+00 )
      integer   i, k
      double precision   aii, alpha
      end subroutine dgeqrt2

      !! dgeqrt3.f
      recursive subroutine dgeqrt3( m, n, a, lda, t, ldt, info )
      integer   info, lda, m, n, ldt
      double precision   a( lda, * ), t( ldt, * )
      double precision   one
      parameter ( one = 1.0d+00 )
      integer   i, i1, j, j1, n1, n2, iinfo
      end subroutine dgeqrt3

      !! dgeqrt.f
      subroutine dgeqrt( m, n, nb, a, lda, t, ldt, work, info )
      integer info, lda, ldt, m, n, nb
      double precision a( lda, * ), t( ldt, * ), work( * )
      integer    i, ib, iinfo, k
      logical    use_recursive_qr
      parameter( use_recursive_qr=.true. )
      end subroutine dgeqrt

      !! dgerfs.f
      subroutine dgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, iwork, info )
      character          trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            notran
      character          transt
      integer            count, i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dgerfs

      !! dgerfsx.f
      subroutine dgerfsx( trans, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          trans, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ), work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran
      integer            j, trans_type, prec_type, ref_type
      integer            n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, dlange, dla_gercond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine dgerfsx

      !! dgerq2.f
      subroutine dgerq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i, k
      double precision   aii
      end subroutine dgerq2

      !! dgerqf.f
      subroutine dgerqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine dgerqf

      !! dgesc2.f
      subroutine dgesc2( n, a, lda, rhs, ipiv, jpiv, scale )
      integer            lda, n
      double precision   scale
      integer            ipiv( * ), jpiv( * )
      double precision   a( lda, * ), rhs( * )
      double precision   one, two
      parameter          ( one = 1.0d+0, two = 2.0d+0 )
      integer            i, j
      double precision   bignum, eps, smlnum, temp
      integer            idamax
      double precision   dlamch
      end subroutine dgesc2

      !! dgesdd.f
      subroutine dgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work,
     &                   lwork, iwork, info )
      character          jobz
      integer            info, lda, ldu, ldvt, lwork, m, n
      integer            iwork( * )
      double precision   a( lda, * ), s( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, wntqa, wntqas, wntqn, wntqo, wntqs
      integer            bdspac, blk, chunk, i, ie, ierr, il,
     &                   ir, iscl, itau, itaup, itauq, iu, ivt, ldwkvt,
     &                   ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk,
     &                   mnthr, nwork, wrkbl
      double precision   anrm, bignum, eps, smlnum
      integer            idum( 1 )
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgesdd

      !! dgesvd.f
      subroutine dgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,
     &                   vt, ldvt, work, lwork, info )
      character          jobu, jobvt
      integer            info, lda, ldu, ldvt, lwork, m, n
      double precision   a( lda, * ), s( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, wntua, wntuas, wntun, wntuo, wntus,
     &                   wntva, wntvas, wntvn, wntvo, wntvs
      integer            bdspac, blk, chunk, i, ie, ierr, ir, iscl,
     &                   itau, itaup, itauq, iu, iwork, ldwrkr, ldwrku,
     &                   maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru,
     &                   nrvt, wrkbl
      integer            lwork_dgeqrf, lwork_dorgqr_n, lwork_dorgqr_m,
     &                   lwork_dgebrd, lwork_dorgbr_p, lwork_dorgbr_q,
     &                   lwork_dgelqf, lwork_dorglq_n, lwork_dorglq_m
      double precision   anrm, bignum, eps, smlnum
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgesvd

      !! dgesvdx.f
      subroutine dgesvdx( jobu, jobvt, range, m, n, a, lda, vl, vu,
     &                    il, iu, ns, s, u, ldu, vt, ldvt, work,
     &                    lwork, iwork, info )
      character          jobu, jobvt, range
      integer            il, info, iu, lda, ldu, ldvt, lwork, m, n, ns
      double precision   vl, vu
      integer            iwork( * )
      double precision   a( lda, * ), s( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      character          jobz, rngtgk
      logical            alls, inds, lquery, vals, wantu, wantvt
      integer            i, id, ie, ierr, ilqf, iltgk, iqrf, iscl,
     &                   itau, itaup, itauq, itemp, itgkz, iutgk,
     &                   j, maxwrk, minmn, minwrk, mnthr
      double precision   abstol, anrm, bignum, eps, smlnum
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange, dnrm2
      end subroutine dgesvdx

      !! dgesv.f
      subroutine dgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      double precision   a( lda, * ), b( ldb, * )
      end subroutine dgesv

      !! dgesvj.f
      subroutine dgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,
     &                   ldv, work, lwork, info )
      integer            info, lda, ldv, lwork, m, mv, n
      character(len=1)   joba, jobu, jobv
      double precision   a( lda, * ), sva( n ), v( ldv, * ),
     &                   work( lwork )
      double precision   zero, half, one
      parameter          ( zero = 0.0d0, half = 0.5d0, one = 1.0d0)
      integer            nsweep
      parameter          ( nsweep = 30 )
      double precision   aapp, aapp0, aapq, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, ctol, epsln, large, mxaapq,
     &                   mxsinj, rootbig, rooteps, rootsfmin, roottol,
     &                   skl, sfmin, small, sn, t, temp1, theta,
     &                   thsign, tol
      integer            blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &                   iswrot, jbc, jgl, kbl, lkahead, mvl, n2, n34,
     &                   n4, nbl, notrot, p, pskipped, q, rowskip,
     &                   swband
      logical            applv, goscale, lower, lsvec, noscale, rotok,
     &                   rsvec, uctol, upper
      double precision   fastr( 5 )
      double precision   ddot, dnrm2
      integer            idamax
      double precision   dlamch
      logical            lsame
      end subroutine dgesvj

      !! dgesvx.f
      subroutine dgesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                   equed, r, c, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, iwork, info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), c( * ), ferr( * ), r( * ),
     &                   work( * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j
      double precision   amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      double precision   dlamch, dlange, dlantr
      end subroutine dgesvx

      !! dgesvxx.f
      subroutine dgesvxx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, r, c, b, ldb, x, ldx, rcond, rpvgrw,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, iwork,
     &                    info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, j
      double precision   amax, bignum, colcnd, rcmax, rcmin, rowcnd,
     &                   smlnum
      logical            lsame
      double precision   dlamch, dla_gerpvgrw
      end subroutine dgesvxx

      !! dgetc2.f
      subroutine dgetc2( n, a, lda, ipiv, jpiv, info )
      integer            info, lda, n
      integer            ipiv( * ), jpiv( * )
      double precision   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i, ip, ipv, j, jp, jpv
      double precision   bignum, eps, smin, smlnum, xmax
      double precision   dlamch
      end subroutine dgetc2

      !! dgetf2.f
      subroutine dgetf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      double precision   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      double precision   sfmin
      integer            i, j, jp
      double precision   dlamch
      integer            idamax
      end subroutine dgetf2

      !! dgetrf2.f
      recursive subroutine dgetrf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      double precision   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      double precision   sfmin, temp
      integer            i, iinfo, n1, n2
      double precision   dlamch
      integer            idamax
      end subroutine dgetrf2

      !! dgetrf.f
      subroutine dgetrf( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      double precision   a( lda, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i, iinfo, j, jb, nb
      integer            ilaenv
      end subroutine dgetrf

      !! dgetri.f
      subroutine dgetri( n, a, lda, ipiv, work, lwork, info )
      integer            info, lda, lwork, n
      integer            ipiv( * )
      double precision   a( lda, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery
      integer            i, iws, j, jb, jj, jp, ldwork, lwkopt, nb,
     &                   nbmin, nn
      integer            ilaenv
      end subroutine dgetri

      !! dgetrs.f
      subroutine dgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          trans
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      double precision   a( lda, * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            notran
      logical            lsame
      end subroutine dgetrs

      !! dggbak.f
      subroutine dggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,
     &                   ldv, info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      double precision   lscale( * ), rscale( * ), v( ldv, * )
      logical            leftv, rightv
      integer            i, k
      logical            lsame
      end subroutine dggbak

      !! dggbal.f
      subroutine dggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,
     &                   rscale, work, info )
      character          job
      integer            ihi, ilo, info, lda, ldb, n
      double precision   a( lda, * ), b( ldb, * ), lscale( * ),
     &                   rscale( * ), work( * )
      double precision   zero, half, one
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0 )
      double precision   three, sclfac
      parameter          ( three = 3.0d+0, sclfac = 1.0d+1 )
      integer            i, icab, iflow, ip1, ir, irab, it, j, jc, jp1,
     &                   k, kount, l, lcab, lm1, lrab, lsfmax, lsfmin,
     &                   m, nr, nrp2
      double precision   alpha, basl, beta, cab, cmax, coef, coef2,
     &                   coef5, cor, ew, ewc, gamma, pgamma, rab, sfmax,
     &                   sfmin, sum, t, ta, tb, tc
      logical            lsame
      integer            idamax
      double precision   ddot, dlamch
      end subroutine dggbal

      !! dgges3.f
      subroutine dgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,
     &                   ldb, sdim, alphar, alphai, beta, vsl, ldvsl,
     &                   vsr, ldvsr, work, lwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      double precision   a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vsl( ldvsl, * ),
     &                   vsr( ldvsr, * ), work( * )
      logical            selctg
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, lst2sl, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, ip, iright, irows, itau, iwrk, lwkopt
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, safmax, safmin, smlnum
      integer            idum( 1 )
      double precision   dif( 2 )
      logical            lsame
      double precision   dlamch, dlange
      end subroutine dgges3

      !! dgges.f
      subroutine dgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,
     &                  sdim, alphar, alphai, beta, vsl, ldvsl, vsr,
     &                  ldvsr, work, lwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      double precision   a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vsl( ldvsl, * ),
     &                   vsr( ldvsr, * ), work( * )
      logical            selctg
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, lst2sl, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, ip, iright, irows, itau, iwrk, maxwrk,
     &                   minwrk
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, safmax, safmin, smlnum
      integer            idum( 1 )
      double precision   dif( 2 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dgges

      !! dggesx.f
      subroutine dggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,
     &                   b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl,
     &                   vsr, ldvsr, rconde, rcondv, work, lwork, iwork,
     &                   liwork, bwork, info )
      character          jobvsl, jobvsr, sense, sort
      integer            info, lda, ldb, ldvsl, ldvsr, liwork, lwork, n,
     &                   sdim
      logical            bwork( * )
      integer            iwork( * )
      double precision   a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), rconde( 2 ),
     &                   rcondv( 2 ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, lst2sl, wantsb, wantse, wantsn, wantst,
     &                   wantsv
      integer            i, icols, ierr, ihi, ijob, ijobvl, ijobvr,
     &                   ileft, ilo, ip, iright, irows, itau, iwrk,
     &                   liwmin, lwrk, maxwrk, minwrk
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps, pl,
     &                   pr, safmax, safmin, smlnum
      double precision   dif( 2 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dggesx

      !! dggev3.f
      subroutine dggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,
     &                   alphai, beta, vl, ldvl, vr, ldvr, work, lwork,
     &                   info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      double precision   a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, itau, iwrk, jc, jr, lwkopt
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      logical            ldumma( 1 )
      logical            lsame
      double precision   dlamch, dlange
      end subroutine dggev3

      !! dggev.f
      subroutine dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,
     &                  beta, vl, ldvl, vr, ldvr, work, lwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      double precision   a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, itau, iwrk, jc, jr, maxwrk,
     &                   minwrk
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dggev

      !! dggevx.f
      subroutine dggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,
     &                   alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo,
     &                   ihi, lscale, rscale, abnrm, bbnrm, rconde,
     &                   rcondv, work, lwork, iwork, bwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldb, ldvl, ldvr, lwork, n
      double precision   abnrm, bbnrm
      logical            bwork( * )
      integer            iwork( * )
      double precision   a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), lscale( * ),
     &                   rconde( * ), rcondv( * ), rscale( * ),
     &                   vl( ldvl, * ), vr( ldvr, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl,
     &                   pair, wantsb, wantse, wantsn, wantsv
      character          chtemp
      integer            i, icols, ierr, ijobvl, ijobvr, in, irows,
     &                   itau, iwrk, iwrk1, j, jc, jr, m, maxwrk,
     &                   minwrk, mm
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlange
      end subroutine dggevx

      !! dggglm.f
      subroutine dggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      double precision   a( lda, * ), b( ldb, * ), d( * ), work( * ),
     &                   x( * ), y( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery
      integer            i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3,
     &                   nb4, np
      integer            ilaenv
      end subroutine dggglm

      !! dgghd3.f
      subroutine dgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, work, lwork, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n, lwork
      double precision   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            blk22, initq, initz, lquery, wantq, wantz
      character(len=1)   compq2, compz2
      integer            cola, i, ierr, j, j0, jcol, jj, jrow, k,
     &                   kacc22, len, lwkopt, n2nb, nb, nblst, nbmin,
     &                   nh, nnb, nx, ppw, ppwo, pw, top, topq
      double precision   c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
      logical            lsame
      integer            ilaenv
      end subroutine dgghd3

      !! dgghrd.f
      subroutine dgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n
      double precision   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            ilq, ilz
      integer            icompq, icompz, jcol, jrow
      double precision   c, s, temp
      logical            lsame
      end subroutine dgghrd

      !! dgglse.f
      subroutine dgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      double precision   a( lda, * ), b( ldb, * ), c( * ), d( * ),
     &                   work( * ), x( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lquery
      integer            lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3,
     &                   nb4, nr
      integer            ilaenv
      end subroutine dgglse

      !! dggqrf.f
      subroutine dggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      double precision   a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine dggqrf

      !! dggrqf.f
      subroutine dggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      double precision   a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine dggrqf

      !! dggsvd3.f
      subroutine dggsvd3( jobu, jobv, jobq, m, n, p, k, l, a, lda, b,
     &                    ldb, alpha, beta, u, ldu, v, ldv, q, ldq,
     &                    work, lwork, iwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      integer            iwork( * )
      double precision   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), q( ldq, * ), u( ldu, * ),
     &                   v( ldv, * ), work( * )
      logical            wantq, wantu, wantv, lquery
      integer            i, ibnd, isub, j, ncycle, lwkopt
      double precision   anorm, bnorm, smax, temp, tola, tolb, ulp, unfl
      logical            lsame
      double precision   dlamch, dlange
      end subroutine dggsvd3

      !! dggsvp3.f
      subroutine dggsvp3( jobu, jobv, jobq, m, p, n, a, lda, b, ldb,
     &                    tola, tolb, k, l, u, ldu, v, ldv, q, ldq,
     &                    iwork, tau, work, lwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      double precision   tola, tolb
      integer            iwork( * )
      double precision   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   tau( * ), u( ldu, * ), v( ldv, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            forwrd, wantq, wantu, wantv, lquery
      integer            i, j, lwkopt
      logical            lsame
      end subroutine dggsvp3

      !! dgsvj0.f
      subroutine dgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,
     &                   sfmin, tol, nsweep, work, lwork, info )
      integer            info, lda, ldv, lwork, m, mv, n, nsweep
      double precision   eps, sfmin, tol
      character(len=1)   jobv
      double precision   a( lda, * ), sva( n ), d( n ), v( ldv, * ),
     &                   work( lwork )
      double precision   zero, half, one
      parameter          ( zero = 0.0d0, half = 0.5d0, one = 1.0d0)
      double precision   aapp, aapp0, aapq, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, mxaapq, mxsinj, rootbig, rooteps,
     &                   rootsfmin, roottol, small, sn, t, temp1, theta,
     &                   thsign
      integer            blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &                   iswrot, jbc, jgl, kbl, lkahead, mvl, nbl,
     &                   notrot, p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      double precision   fastr( 5 )
      double precision   ddot, dnrm2
      integer            idamax
      logical            lsame
      end subroutine dgsvj0

      !! dgsvj1.f
      subroutine dgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,
     &                   eps, sfmin, tol, nsweep, work, lwork, info )
      double precision   eps, sfmin, tol
      integer            info, lda, ldv, lwork, m, mv, n, n1, nsweep
      character(len=1)   jobv
      double precision   a( lda, * ), d( n ), sva( n ), v( ldv, * ),
     &                   work( lwork )
      double precision   zero, half, one
      parameter          ( zero = 0.0d0, half = 0.5d0, one = 1.0d0 )
      double precision   aapp, aapp0, aapq, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, large, mxaapq, mxsinj, rootbig,
     &                   rooteps, rootsfmin, roottol, small, sn, t,
     &                   temp1, theta, thsign
      integer            blskip, emptsw, i, ibr, igl, ierr, ijblsk,
     &                   iswrot, jbc, jgl, kbl, mvl, notrot, nblc, nblr,
     &                   p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      double precision   fastr( 5 )
      double precision   ddot, dnrm2
      integer            idamax
      logical            lsame
      end subroutine dgsvj1

      !! dgtcon.f
      subroutine dgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,
     &                   work, iwork, info )
      character          norm
      integer            info, n
      double precision   anorm, rcond
      integer            ipiv( * ), iwork( * )
      double precision   d( * ), dl( * ), du( * ), du2( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            onenrm
      integer            i, kase, kase1
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine dgtcon

      !! dgtrfs.f
      subroutine dgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, iwork,
     &                   info )
      character          trans
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      double precision   b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   dl( * ), dlf( * ), du( * ), du2( * ), duf( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dgtrfs

      !! dgtsv.f
      subroutine dgtsv( n, nrhs, dl, d, du, b, ldb, info )
      integer            info, ldb, n, nrhs
      double precision   b( ldb, * ), d( * ), dl( * ), du( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            i, j
      double precision   fact, temp
      end subroutine dgtsv

      !! dgtsvx.f
      subroutine dgtsvx( fact, trans, n, nrhs, dl, d, du, dlf, df, duf,
     &                   du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, iwork, info )
      character          fact, trans
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   dl( * ), dlf( * ), du( * ), du2( * ), duf( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nofact, notran
      character          norm
      double precision   anorm
      logical            lsame
      double precision   dlamch, dlangt
      end subroutine dgtsvx

      !! dgttrf.f
      subroutine dgttrf( n, dl, d, du, du2, ipiv, info )
      integer            info, n
      integer            ipiv( * )
      double precision   d( * ), dl( * ), du( * ), du2( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            i
      double precision   fact, temp
      end subroutine dgttrf

      !! dgttrs.f
      subroutine dgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      double precision   b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      logical            notran
      integer            itrans, j, jb, nb
      integer            ilaenv
      end subroutine dgttrs

      !! dgtts2.f
      subroutine dgtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
      integer            itrans, ldb, n, nrhs
      integer            ipiv( * )
      double precision   b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      integer            i, ip, j
      double precision   temp
      end subroutine dgtts2

      !! dhgeqz.f
      subroutine dhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,
     &                   alphar, alphai, beta, q, ldq, z, ldz, work,
     &                   lwork, info )
      character          compq, compz, job
      integer            ihi, ilo, info, ldh, ldq, ldt, ldz, lwork, n
      double precision   alphai( * ), alphar( * ), beta( * ),
     &                   h( ldh, * ), q( ldq, * ), t( ldt, * ),
     &                   work( * ), z( ldz, * )
      double precision   half, zero, one, safety
      parameter          ( half = 0.5d+0, zero = 0.0d+0, one = 1.0d+0,
     &                   safety = 1.0d+2 )
      logical            ilazr2, ilazro, ilpivt, ilq, ilschr, ilz,
     &                   lquery
      integer            icompq, icompz, ifirst, ifrstm, iiter, ilast,
     &                   ilastm, in, ischur, istart, j, jc, jch, jiter,
     &                   jr, maxit
      double precision   a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11,
     &                   ad11l, ad12, ad12l, ad21, ad21l, ad22, ad22l,
     &                   ad32l, an, anorm, ascale, atol, b11, b1a, b1i,
     &                   b1r, b22, b2a, b2i, b2r, bn, bnorm, bscale,
     &                   btol, c, c11i, c11r, c12, c21, c22i, c22r, cl,
     &                   cq, cr, cz, eshift, s, s1, s1inv, s2, safmax,
     &                   safmin, scale, sl, sqi, sqr, sr, szi, szr, t1,
     &                   tau, temp, temp2, tempi, tempr, u1, u12, u12l,
     &                   u2, ulp, vs, w11, w12, w21, w22, wabs, wi, wr,
     &                   wr2
      double precision   v( 3 )
      logical            lsame
      double precision   dlamch, dlanhs, dlapy2, dlapy3
      end subroutine dhgeqz

      !! dhsein.f
      subroutine dhsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,
     &                   vl, ldvl, vr, ldvr, mm, m, work, ifaill,
     &                   ifailr, info )
      character          eigsrc, initv, side
      integer            info, ldh, ldvl, ldvr, m, mm, n
      logical            select( * )
      integer            ifaill( * ), ifailr( * )
      double precision   h( ldh, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   wi( * ), work( * ), wr( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            bothv, fromqr, leftv, noinit, pair, rightv
      integer            i, iinfo, k, kl, kln, kr, ksi, ksr, ldwork
      double precision   bignum, eps3, hnorm, smlnum, ulp, unfl, wki,
     &                   wkr
      logical            lsame, disnan
      double precision   dlamch, dlanhs
      end subroutine dhsein

      !! dhseqr.f
      subroutine dhseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,
     &                   ldz, work, lwork, info )
      integer            ihi, ilo, info, ldh, ldz, lwork, n
      character          compz, job
      double precision   h( ldh, * ), wi( * ), work( * ), wr( * ),
     &                   z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            nl
      parameter          ( nl = 49 )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      double precision   hl( nl, nl ), workl( nl )
      integer            i, kbot, nmin
      logical            initz, lquery, wantt, wantz
      integer            ilaenv
      logical            lsame
      end subroutine dhseqr

      !! disnan.f
      logical function disnan( din )
      double precision   din
      logical dlaisnan
      end function disnan

      !! dlabad.f
      subroutine dlabad( small, large )
      double precision   large, small
      end subroutine dlabad

      !! dlabrd.f
      subroutine dlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,
     &                   ldy )
      integer            lda, ldx, ldy, m, n, nb
      double precision   a( lda, * ), d( * ), e( * ), taup( * ),
     &                   tauq( * ), x( ldx, * ), y( ldy, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      integer            i
      end subroutine dlabrd

      !! dlacn2.f
      subroutine dlacn2( n, v, x, isgn, est, kase, isave )
      integer            kase, n
      double precision   est
      integer            isgn( * ), isave( 3 )
      double precision   v( * ), x( * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      integer            i, jlast
      double precision   altsgn, estold, temp
      integer            idamax
      double precision   dasum
      end subroutine dlacn2

      !! dlacon.f
      subroutine dlacon( n, v, x, isgn, est, kase )
      integer            kase, n
      double precision   est
      integer            isgn( * )
      double precision   v( * ), x( * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      integer            i, iter, j, jlast, jump
      double precision   altsgn, estold, temp
      integer            idamax
      double precision   dasum
      end subroutine dlacon

      !! dlacpy.f
      subroutine dlacpy( uplo, m, n, a, lda, b, ldb )
      character          uplo
      integer            lda, ldb, m, n
      double precision   a( lda, * ), b( ldb, * )
      integer            i, j
      logical            lsame
      end subroutine dlacpy

      !! dladiv.f
      subroutine dladiv( a, b, c, d, p, q )
      double precision   a, b, c, d, p, q
      double precision   bs
      parameter          ( bs = 2.0d0 )
      double precision   half
      parameter          ( half = 0.5d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      double precision   aa, bb, cc, dd, ab, cd, s, ov, un, be, eps
      double precision   dlamch
      end subroutine dladiv

      !! dlae2.f
      subroutine dlae2( a, b, c, rt1, rt2 )
      double precision   a, b, c, rt1, rt2
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   half
      parameter          ( half = 0.5d0 )
      double precision   ab, acmn, acmx, adf, df, rt, sm, tb
      end subroutine dlae2

      !! dlaebz.f
      subroutine dlaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,
     &                   reltol, pivmin, d, e, e2, nval, ab, c, mout,
     &                   nab, work, iwork, info )
      integer            ijob, info, minp, mmax, mout, n, nbmin, nitmax
      double precision   abstol, pivmin, reltol
      integer            iwork( * ), nab( mmax, * ), nval( * )
      double precision   ab( mmax, * ), c( * ), d( * ), e( * ), e2( * ),
     &                   work( * )
      double precision   zero, two, half
      parameter          ( zero = 0.0d0, two = 2.0d0,
     &                   half = 1.0d0 / two )
      integer            itmp1, itmp2, j, ji, jit, jp, kf, kfnew, kl,
     &                   klnew
      double precision   tmp1, tmp2
      end subroutine dlaebz

      !! dlaed0.f
      subroutine dlaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,
     &                   work, iwork, info )
      integer            icompq, info, ldq, ldqs, n, qsiz
      integer            iwork( * )
      double precision   d( * ), e( * ), q( ldq, * ), qstore( ldqs, * ),
     &                   work( * )
      double precision   zero, one, two
      parameter          ( zero = 0.d0, one = 1.d0, two = 2.d0 )
      integer            curlvl, curprb, curr, i, igivcl, igivnm,
     &                   igivpt, indxq, iperm, iprmpt, iq, iqptr, iwrem,
     &                   j, k, lgn, matsiz, msd2, smlsiz, smm1, spm1,
     &                   spm2, submat, subpbs, tlvls
      double precision   temp
      integer            ilaenv
      end subroutine dlaed0

      !! dlaed1.f
      subroutine dlaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,
     &                   info )
      integer            cutpnt, info, ldq, n
      double precision   rho
      integer            indxq( * ), iwork( * )
      double precision   d( * ), q( ldq, * ), work( * )
      integer            coltyp, i, idlmda, indx, indxc, indxp, iq2, is,
     &                   iw, iz, k, n1, n2, zpp1
      end subroutine dlaed1

      !! dlaed2.f
      subroutine dlaed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,
     &                   q2, indx, indxc, indxp, coltyp, info )
      integer            info, k, ldq, n, n1
      double precision   rho
      integer            coltyp( * ), indx( * ), indxc( * ), indxp( * ),
     &                   indxq( * )
      double precision   d( * ), dlamda( * ), q( ldq, * ), q2( * ),
     &                   w( * ), z( * )
      double precision   mone, zero, one, two, eight
      parameter          ( mone = -1.0d0, zero = 0.0d0, one = 1.0d0,
     &                   two = 2.0d0, eight = 8.0d0 )
      integer            ctot( 4 ), psm( 4 )
      integer            ct, i, imax, iq1, iq2, j, jmax, js, k2, n1p1,
     &                   n2, nj, pj
      double precision   c, eps, s, t, tau, tol
      integer            idamax
      double precision   dlamch, dlapy2
      end subroutine dlaed2

      !! dlaed3.f
      subroutine dlaed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,
     &                   ctot, w, s, info )
      integer            info, k, ldq, n, n1
      double precision   rho
      integer            ctot( * ), indx( * )
      double precision   d( * ), dlamda( * ), q( ldq, * ), q2( * ),
     &                   s( * ), w( * )
      double precision   one, zero
      parameter          ( one = 1.0d0, zero = 0.0d0 )
      integer            i, ii, iq2, j, n12, n2, n23
      double precision   temp
      double precision   dlamc3, dnrm2
      end subroutine dlaed3

      !! dlaed4.f
      subroutine dlaed4( n, i, d, z, delta, rho, dlam, info )
      integer            i, info, n
      double precision   dlam, rho
      double precision   d( * ), delta( * ), z( * )
      integer            maxit
      parameter          ( maxit = 30 )
      double precision   zero, one, two, three, four, eight, ten
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   three = 3.0d0, four = 4.0d0, eight = 8.0d0,
     &                   ten = 10.0d0 )
      logical            orgati, swtch, swtch3
      integer            ii, iim1, iip1, ip1, iter, j, niter
      double precision   a, b, c, del, dltlb, dltub, dphi, dpsi, dw,
     &                   eps, erretm, eta, midpt, phi, prew, psi,
     &                   rhoinv, tau, temp, temp1, w
      double precision   zz( 3 )
      double precision   dlamch
      end subroutine dlaed4

      !! dlaed5.f
      subroutine dlaed5( i, d, z, delta, rho, dlam )
      integer            i
      double precision   dlam, rho
      double precision   d( 2 ), delta( 2 ), z( 2 )
      double precision   zero, one, two, four
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   four = 4.0d0 )
      double precision   b, c, del, tau, temp, w
      end subroutine dlaed5

      !! dlaed6.f
      subroutine dlaed6( kniter, orgati, rho, d, z, finit, tau, info )
      logical            orgati
      integer            info, kniter
      double precision   finit, rho, tau
      double precision   d( 3 ), z( 3 )
      integer            maxit
      parameter          ( maxit = 40 )
      double precision   zero, one, two, three, four, eight
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   three = 3.0d0, four = 4.0d0, eight = 8.0d0 )
      double precision   dlamch
      double precision   dscale( 3 ), zscale( 3 )
      logical            scale
      integer            i, iter, niter
      double precision   a, b, base, c, ddf, df, eps, erretm, eta, f,
     &                   fc, sclfac, sclinv, small1, small2, sminv1,
     &                   sminv2, temp, temp1, temp2, temp3, temp4,
     &                   lbd, ubd
      end subroutine dlaed6

      !! dlaed7.f
      subroutine dlaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,
     &                   ldq, indxq, rho, cutpnt, qstore, qptr, prmptr,
     &                   perm, givptr, givcol, givnum, work, iwork,
     &                   info )
      integer            curlvl, curpbm, cutpnt, icompq, info, ldq, n,
     &                   qsiz, tlvls
      double precision   rho
      integer            givcol( 2, * ), givptr( * ), indxq( * ),
     &                   iwork( * ), perm( * ), prmptr( * ), qptr( * )
      double precision   d( * ), givnum( 2, * ), q( ldq, * ),
     &                   qstore( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d0, zero = 0.0d0 )
      integer            coltyp, curr, i, idlmda, indx, indxc, indxp,
     &                   iq2, is, iw, iz, k, ldq2, n1, n2, ptr
      end subroutine dlaed7

      !! dlaed8.f
      subroutine dlaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,
     &                   cutpnt, z, dlamda, q2, ldq2, w, perm, givptr,
     &                   givcol, givnum, indxp, indx, info )
      integer            cutpnt, givptr, icompq, info, k, ldq, ldq2, n,
     &                   qsiz
      double precision   rho
      integer            givcol( 2, * ), indx( * ), indxp( * ),
     &                   indxq( * ), perm( * )
      double precision   d( * ), dlamda( * ), givnum( 2, * ),
     &                   q( ldq, * ), q2( ldq2, * ), w( * ), z( * )
      double precision   mone, zero, one, two, eight
      parameter          ( mone = -1.0d0, zero = 0.0d0, one = 1.0d0,
     &                   two = 2.0d0, eight = 8.0d0 )
      integer            i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
      double precision   c, eps, s, t, tau, tol
      integer            idamax
      double precision   dlamch, dlapy2
      end subroutine dlaed8

      !! dlaed9.f
      subroutine dlaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,
     &                   s, lds, info )
      integer            info, k, kstart, kstop, ldq, lds, n
      double precision   rho
      double precision   d( * ), dlamda( * ), q( ldq, * ), s( lds, * ),
     &                   w( * )
      integer            i, j
      double precision   temp
      double precision   dlamc3, dnrm2
      end subroutine dlaed9

      !! dlaeda.f
      subroutine dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,
     &                   givcol, givnum, q, qptr, z, ztemp, info )
      integer            curlvl, curpbm, info, n, tlvls
      integer            givcol( 2, * ), givptr( * ), perm( * ),
     &                   prmptr( * ), qptr( * )
      double precision   givnum( 2, * ), q( * ), z( * ), ztemp( * )
      double precision   zero, half, one
      parameter          ( zero = 0.0d0, half = 0.5d0, one = 1.0d0 )
      integer            bsiz1, bsiz2, curr, i, k, mid, psiz1, psiz2,
     &                   ptr, zptr1
      end subroutine dlaeda

      !! dlaein.f
      subroutine dlaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,
     &                   ldb, work, eps3, smlnum, bignum, info )
      logical            noinit, rightv
      integer            info, ldb, ldh, n
      double precision   bignum, eps3, smlnum, wi, wr
      double precision   b( ldb, * ), h( ldh, * ), vi( * ), vr( * ),
     &                   work( * )
      double precision   zero, one, tenth
      parameter          ( zero = 0.0d+0, one = 1.0d+0, tenth = 1.0d-1 )
      character          normin, trans
      integer            i, i1, i2, i3, ierr, its, j
      double precision   absbii, absbjj, ei, ej, growto, norm, nrmsml,
     &                   rec, rootn, scale, temp, vcrit, vmax, vnorm, w,
     &                   w1, x, xi, xr, y
      integer            idamax
      double precision   dasum, dlapy2, dnrm2
      end subroutine dlaein

      !! dlaev2.f
      subroutine dlaev2( a, b, c, rt1, rt2, cs1, sn1 )
      double precision   a, b, c, cs1, rt1, rt2, sn1
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   half
      parameter          ( half = 0.5d0 )
      integer            sgn1, sgn2
      double precision   ab, acmn, acmx, acs, adf, cs, ct, df, rt, sm,
     &                   tb, tn
      end subroutine dlaev2

      !! dlaexc.f
      subroutine dlaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,
     &                   info )
      logical            wantq
      integer            info, j1, ldq, ldt, n, n1, n2
      double precision   q( ldq, * ), t( ldt, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   ten
      parameter          ( ten = 1.0d+1 )
      integer            ldd, ldx
      parameter          ( ldd = 4, ldx = 2 )
      integer            ierr, j2, j3, j4, k, nd
      double precision   cs, dnorm, eps, scale, smlnum, sn, t11, t22,
     &                   t33, tau, tau1, tau2, temp, thresh, wi1, wi2,
     &                   wr1, wr2, xnorm
      double precision   d( ldd, 4 ), u( 3 ), u1( 3 ), u2( 3 ),
     &                   x( ldx, 2 )
      double precision   dlamch, dlange
      end subroutine dlaexc

      !! dlag2.f
      subroutine dlag2( a, lda, b, ldb, safmin, scale1, scale2, wr1,
     &                  wr2, wi )
      integer            lda, ldb
      double precision   safmin, scale1, scale2, wi, wr1, wr2
      double precision   a( lda, * ), b( ldb, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      double precision   half
      parameter          ( half = one / two )
      double precision   fuzzy1
      parameter          ( fuzzy1 = one+1.0d-5 )
      double precision   a11, a12, a21, a22, abi22, anorm, as11, as12,
     &                   as22, ascale, b11, b12, b22, binv11, binv22,
     &                   bmin, bnorm, bscale, bsize, c1, c2, c3, c4, c5,
     &                   diff, discr, pp, qq, r, rtmax, rtmin, s1, s2,
     &                   safmax, shift, ss, sum, wabs, wbig, wdet,
     &                   wscale, wsize, wsmall
      end subroutine dlag2

      !! dlag2s.f
      subroutine dlag2s( m, n, a, lda, sa, ldsa, info )
      integer            info, lda, ldsa, m, n
      real               sa( ldsa, * )
      double precision   a( lda, * )
      integer            i, j
      double precision   rmax
      real               slamch
      end subroutine dlag2s

      !! dla_gbamv.f
      subroutine dla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,
     &                      incx, beta, y, incy )
      double precision   alpha, beta
      integer            incx, incy, ldab, m, n, kl, ku, trans
      double precision   ab( ldab, * ), x( * ), y( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            symb_zero
      double precision   temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny, kd, ke
      double precision   dlamch
      integer            ilatrans
      end subroutine dla_gbamv

      !! dla_gbrcond.f
      double precision function dla_gbrcond( trans, n, kl, ku, ab, ldab,
     &                                       afb, ldafb, ipiv, cmode, c,
     &                                       info, work, iwork )
      character          trans
      integer            n, ldab, ldafb, info, kl, ku, cmode
      integer            iwork( * ), ipiv( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), work( * ),
     &                   c( * )
      logical            notrans
      integer            kase, i, j, kd, ke
      double precision   ainvnm, tmp
      integer            isave( 3 )
      logical            lsame
      end function dla_gbrcond

      !! dla_gbrfsx_extended.f
      subroutine dla_gbrfsx_extended( prec_type, trans_type, n, kl, ku,
     &                                nrhs, ab, ldab, afb, ldafb, ipiv,
     &                                colequ, c, b, ldb, y, ldy,
     &                                berr_out, n_norms, err_bnds_norm,
     &                                err_bnds_comp, res, ayb, dy,
     &                                y_tail, rcond, ithresh, rthresh,
     &                                dz_ub, ignore_cwise, info )
      integer            info, ldab, ldafb, ldb, ldy, n, kl, ku, nrhs,
     &                   prec_type, trans_type, n_norms, ithresh
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      integer            ipiv( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   y( ldy, * ), res(*), dy(*), y_tail(*)
      double precision   c( * ), ayb(*), rcond, berr_out(*),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      character          trans
      integer            cnt, i, j, m, x_state, z_state, y_prec_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      double precision   dlamch
      character          chla_transtype
      end subroutine dla_gbrfsx_extended

      !! dla_gbrpvgrw.f
      double precision function dla_gbrpvgrw( n, kl, ku, ncols, ab,
     &                                        ldab, afb, ldafb )
      integer            n, kl, ku, ncols, ldab, ldafb
      double precision   ab( ldab, * ), afb( ldafb, * )
      integer            i, j, kd
      double precision   amax, umax, rpvgrw
      end function dla_gbrpvgrw

      !! dla_geamv.f
      subroutine dla_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,
     &                       y, incy )
      double precision   alpha, beta
      integer            incx, incy, lda, m, n, trans
      double precision   a( lda, * ), x( * ), y( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            symb_zero
      double precision   temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny
      double precision   dlamch
      integer            ilatrans
      end subroutine dla_geamv

      !! dla_gercond.f
      double precision function dla_gercond ( trans, n, a, lda, af,
     &                                        ldaf, ipiv, cmode, c,
     &                                        info, work, iwork )
      character          trans
      integer            n, lda, ldaf, info, cmode
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), work( * ),
     &                   c( * )
      logical            notrans
      integer            kase, i, j
      double precision   ainvnm, tmp
      integer            isave( 3 )
      logical            lsame
      end function dla_gercond

      !! dla_gerfsx_extended.f
      subroutine dla_gerfsx_extended( prec_type, trans_type, n, nrhs, a,
     &                                lda, af, ldaf, ipiv, colequ, c, b,
     &                                ldb, y, ldy, berr_out, n_norms,
     &                                errs_n, errs_c, res, ayb, dy,
     &                                y_tail, rcond, ithresh, rthresh,
     &                                dz_ub, ignore_cwise, info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   trans_type, n_norms, ithresh
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      integer            ipiv( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb( * ), rcond, berr_out( * ),
     &                   errs_n( nrhs, * ), errs_c( nrhs, * )
      character          trans
      integer            cnt, i, j, x_state, z_state, y_prec_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      double precision   dlamch
      character          chla_transtype
      end subroutine dla_gerfsx_extended

      !! dla_gerpvgrw.f
      double precision function dla_gerpvgrw( n, ncols, a, lda, af,
     &         ldaf )
      integer            n, ncols, lda, ldaf
      double precision   a( lda, * ), af( ldaf, * )
      integer            i, j
      double precision   amax, umax, rpvgrw
      end function dla_gerpvgrw

      !! dlags2.f
      subroutine dlags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,
     &                   snv, csq, snq )
      logical            upper
      double precision   a1, a2, a3, b1, b2, b3, csq, csu, csv, snq,
     &                   snu, snv
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   a, aua11, aua12, aua21, aua22, avb11, avb12,
     &                   avb21, avb22, b, c, csl, csr, d, r, s1, s2,
     &                   snl, snr, ua11, ua11r, ua12, ua21, ua22, ua22r,
     &                   vb11, vb11r, vb12, vb21, vb22, vb22r
      end subroutine dlags2

      !! dlagtf.f
      subroutine dlagtf( n, a, lambda, b, c, tol, d, in, info )
      integer            info, n
      double precision   lambda, tol
      integer            in( * )
      double precision   a( * ), b( * ), c( * ), d( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            k
      double precision   eps, mult, piv1, piv2, scale1, scale2, temp, tl
      double precision   dlamch
      end subroutine dlagtf

      !! dlagtm.f
      subroutine dlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,
     &                   b, ldb )
      character          trans
      integer            ldb, ldx, n, nrhs
      double precision   alpha, beta
      double precision   b( ldb, * ), d( * ), dl( * ), du( * ),
     &                   x( ldx, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      logical            lsame
      end subroutine dlagtm

      !! dlagts.f
      subroutine dlagts( job, n, a, b, c, d, in, y, tol, info )
      integer            info, job, n
      double precision   tol
      integer            in( * )
      double precision   a( * ), b( * ), c( * ), d( * ), y( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            k
      double precision   absak, ak, bignum, eps, pert, sfmin, temp
      double precision   dlamch
      end subroutine dlagts

      !! dlagv2.f
      subroutine dlagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,
     &                   csr, snr )
      integer            lda, ldb
      double precision   csl, csr, snl, snr
      double precision   a( lda, * ), alphai( 2 ), alphar( 2 ),
     &                   b( ldb, * ), beta( 2 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   anorm, ascale, bnorm, bscale, h1, h2, h3, qq,
     &                   r, rr, safmin, scale1, scale2, t, ulp, wi, wr1,
     &                   wr2
      double precision   dlamch, dlapy2
      end subroutine dlagv2

      !! dlahqr.f
      subroutine dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,
     &                   iloz, ihiz, z, ldz, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, n
      logical            wantt, wantz
      double precision   h( ldh, * ), wi( * ), wr( * ), z( ldz, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      double precision   dat1, dat2
      parameter          ( dat1 = 3.0d0 / 4.0d0, dat2 = -0.4375d0 )
      double precision   aa, ab, ba, bb, cs, det, h11, h12, h21, h21s,
     &                   h22, rt1i, rt1r, rt2i, rt2r, rtdisc, s, safmax,
     &                   safmin, smlnum, sn, sum, t1, t2, t3, tr, tst,
     &                   ulp, v2, v3
      integer            i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz
      double precision   v( 3 )
      double precision   dlamch
      end subroutine dlahqr

      !! dlahr2.f
      subroutine dlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
      integer            k, lda, ldt, ldy, n, nb
      double precision  a( lda, * ), t( ldt, nb ), tau( nb ),
     &                   y( ldy, nb )
      double precision  zero, one
      parameter          ( zero = 0.0d+0,
     &                     one = 1.0d+0 )
      integer            i
      double precision  ei
      end subroutine dlahr2

      !! dlaic1.f
      subroutine dlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
      integer            j, job
      double precision   c, gamma, s, sest, sestpr
      double precision   w( j ), x( j )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      double precision   half, four
      parameter          ( half = 0.5d0, four = 4.0d0 )
      double precision   absalp, absest, absgam, alpha, b, cosine, eps,
     &                   norma, s1, s2, sine, t, test, tmp, zeta1, zeta2
      double precision   ddot, dlamch
      end subroutine dlaic1

      !! dlaisnan.f
      logical function dlaisnan( din1, din2 )
      double precision   din1, din2
      end function dlaisnan

      !! dla_lin_berr.f
      subroutine dla_lin_berr ( n, nz, nrhs, res, ayb, berr )
      integer            n, nz, nrhs
      double precision   ayb( n, nrhs ), berr( nrhs )
      double precision   res( n, nrhs )
      double precision   tmp
      integer            i, j
      double precision   dlamch
      double precision   safe1
      end subroutine dla_lin_berr

      !! dlaln2.f
      subroutine dlaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,
     &                   ldb, wr, wi, x, ldx, scale, xnorm, info )
      logical            ltrans
      integer            info, lda, ldb, ldx, na, nw
      double precision   ca, d1, d2, scale, smin, wi, wr, xnorm
      double precision   a( lda, * ), b( ldb, * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      integer            icmax, j
      double precision   bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21,
     &                   ci22, cmax, cnorm, cr21, cr22, csi, csr, li21,
     &                   lr21, smini, smlnum, temp, u22abs, ui11, ui11r,
     &                   ui12, ui12s, ui22, ur11, ur11r, ur12, ur12s,
     &                   ur22, xi1, xi2, xr1, xr2
      logical            rswap( 4 ), zswap( 4 )
      integer            ipivot( 4, 4 )
      double precision   ci( 2, 2 ), civ( 4 ), cr( 2, 2 ), crv( 4 )
      double precision   dlamch
      end subroutine dlaln2

      !! dlals0.f
      subroutine dlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,
     &                   perm, givptr, givcol, ldgcol, givnum, ldgnum,
     &                   poles, difl, difr, z, k, c, s, work, info )
      integer            givptr, icompq, info, k, ldb, ldbx, ldgcol,
     &                   ldgnum, nl, nr, nrhs, sqre
      double precision   c, s
      integer            givcol( ldgcol, * ), perm( * )
      double precision   b( ldb, * ), bx( ldbx, * ), difl( * ),
     &                   difr( ldgnum, * ), givnum( ldgnum, * ),
     &                   poles( ldgnum, * ), work( * ), z( * )
      double precision   one, zero, negone
      parameter          ( one = 1.0d0, zero = 0.0d0, negone = -1.0d0 )
      integer            i, j, m, n, nlp1
      double precision   diflj, difrj, dj, dsigj, dsigjp, temp
      double precision   dlamc3, dnrm2
      end subroutine dlals0

      !! dlalsa.f
      subroutine dlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,
     &                   ldu, vt, k, difl, difr, z, poles, givptr,
     &                   givcol, ldgcol, perm, givnum, c, s, work,
     &                   iwork, info )
      integer            icompq, info, ldb, ldbx, ldgcol, ldu, n, nrhs,
     &                   smlsiz
      integer            givcol( ldgcol, * ), givptr( * ), iwork( * ),
     &                   k( * ), perm( ldgcol, * )
      double precision   b( ldb, * ), bx( ldbx, * ), c( * ),
     &                   difl( ldu, * ), difr( ldu, * ),
     &                   givnum( ldu, * ), poles( ldu, * ), s( * ),
     &                   u( ldu, * ), vt( ldu, * ), work( * ),
     &                   z( ldu, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      integer            i, i1, ic, im1, inode, j, lf, ll, lvl, lvl2,
     &                   nd, ndb1, ndiml, ndimr, nl, nlf, nlp1, nlvl,
     &                   nr, nrf, nrp1, sqre
      end subroutine dlalsa

      !! dlalsd.f
      subroutine dlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,
     &                   rank, work, iwork, info )
      character          uplo
      integer            info, ldb, n, nrhs, rank, smlsiz
      double precision   rcond
      integer            iwork( * )
      double precision   b( ldb, * ), d( * ), e( * ), work( * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      integer            bx, bxst, c, difl, difr, givcol, givnum,
     &                   givptr, i, icmpq1, icmpq2, iwk, j, k, nlvl,
     &                   nm1, nsize, nsub, nwork, perm, poles, s, sizei,
     &                   smlszp, sqre, st, st1, u, vt, z
      double precision   cs, eps, orgnrm, r, rcnd, sn, tol
      integer            idamax
      double precision   dlamch, dlanst
      end subroutine dlalsd

      !! dlamrg.f
      subroutine dlamrg( n1, n2, a, dtrd1, dtrd2, index )
      integer            dtrd1, dtrd2, n1, n2
      integer            index( * )
      double precision   a( * )
      integer            i, ind1, ind2, n1sv, n2sv
      end subroutine dlamrg

      !! dlaneg.f
      integer function dlaneg( n, d, lld, sigma, pivmin, r )
      integer            n, r
      double precision   pivmin, sigma
      double precision   d( * ), lld( * )
      double precision   zero, one
      parameter        ( zero = 0.0d0, one = 1.0d0 )
      integer blklen
      parameter ( blklen = 128 )
      integer            bj, j, neg1, neg2, negcnt
      double precision   bsav, dminus, dplus, gamma, p, t, tmp
      logical sawnan
      logical disnan
      end function dlaneg

      !! dlangb.f
      double precision function dlangb( norm, n, kl, ku, ab, ldab,
     &                 work )
      character          norm
      integer            kl, ku, ldab, n
      double precision   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, k, l
      double precision   scale, sum, value, temp
      logical            lsame, disnan
      end function dlangb

      !! dlange.f
      double precision function dlange( norm, m, n, a, lda, work )
      character          norm
      integer            lda, m, n
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   scale, sum, value, temp
      logical            lsame, disnan
      end function dlange

      !! dlangt.f
      double precision function dlangt( norm, n, dl, d, du )
      character          norm
      integer            n
      double precision   d( * ), dl( * ), du( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i
      double precision   anorm, scale, sum, temp
      logical            lsame, disnan
      end function dlangt

      !! dlanhs.f
      double precision function dlanhs( norm, n, a, lda, work )
      character          norm
      integer            lda, n
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   scale, sum, value
      logical            lsame, disnan
      end function dlanhs

      !! dlansb.f
      double precision function dlansb( norm, uplo, n, k, ab, ldab,
     &                 work )
      character          norm, uplo
      integer            k, ldab, n
      double precision   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, l
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function dlansb

      !! dlansf.f
      double precision function dlansf( norm, transr, uplo, n, a, work )
      character          norm, transr, uplo
      integer            n
      double precision   a( 0: * ), work( 0: * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, ifm, ilu, noe, n1, k, l, lda
      double precision   scale, s, value, aa, temp
      logical            lsame, disnan
      end function dlansf

      !! dlansp.f
      double precision function dlansp( norm, uplo, n, ap, work )
      character          norm, uplo
      integer            n
      double precision   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, k
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function dlansp

      !! dlanst.f
      double precision function dlanst( norm, n, d, e )
      character          norm
      integer            n
      double precision   d( * ), e( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i
      double precision   anorm, scale, sum
      logical            lsame, disnan
      end function dlanst

      !! dlansy.f
      double precision function dlansy( norm, uplo, n, a, lda, work )
      character          norm, uplo
      integer            lda, n
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function dlansy

      !! dlantb.f
      double precision function dlantb( norm, uplo, diag, n, k, ab,
     &                 ldab, work )
      character          diag, norm, uplo
      integer            k, ldab, n
      double precision   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            udiag
      integer            i, j, l
      double precision   scale, sum, value
      logical            lsame, disnan
      end function dlantb

      !! dlantp.f
      double precision function dlantp( norm, uplo, diag, n, ap, work )
      character          diag, norm, uplo
      integer            n
      double precision   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            udiag
      integer            i, j, k
      double precision   scale, sum, value
      logical            lsame, disnan
      end function dlantp

      !! dlantr.f
      double precision function dlantr( norm, uplo, diag, m, n, a, lda,
     &                 work )
      character          diag, norm, uplo
      integer            lda, m, n
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            udiag
      integer            i, j
      double precision   scale, sum, value
      logical            lsame, disnan
      end function dlantr

      !! dlanv2.f
      subroutine dlanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
      double precision   a, b, c, cs, d, rt1i, rt1r, rt2i, rt2r, sn
      double precision   zero, half, one
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0 )
      double precision   multpl
      parameter          ( multpl = 4.0d+0 )
      double precision   aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab,
     &                   sac, scale, sigma, sn1, tau, temp, z
      double precision   dlamch, dlapy2
      end subroutine dlanv2

      !! dlapll.f
      subroutine dlapll( n, x, incx, y, incy, ssmin )
      integer            incx, incy, n
      double precision   ssmin
      double precision   x( * ), y( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   a11, a12, a22, c, ssmax, tau
      double precision   ddot
      end subroutine dlapll

      !! dlapmr.f
      subroutine dlapmr( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      double precision   x( ldx, * )
      integer            i, in, j, jj
      double precision   temp
      end subroutine dlapmr

      !! dlapmt.f
      subroutine dlapmt( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      double precision   x( ldx, * )
      integer            i, ii, in, j
      double precision   temp
      end subroutine dlapmt

      !! dla_porcond.f
      double precision function dla_porcond( uplo, n, a, lda, af, ldaf,
     &                                       cmode, c, info, work,
     &                                       iwork )
      character          uplo
      integer            n, lda, ldaf, info, cmode
      double precision   a( lda, * ), af( ldaf, * ), work( * ),
     &                   c( * )
      integer            iwork( * )
      integer            kase, i, j
      double precision   ainvnm, tmp
      logical            up
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      end function dla_porcond

      !! dla_porfsx_extended.f
      subroutine dla_porfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, colequ, c, b, ldb, y,
     &                                ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb(*), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      integer           unstable_state, working_state, conv_state,
     &                  noprog_state, y_prec_state, base_residual,
     &                  extra_residual, extra_y
      parameter         ( unstable_state = 0, working_state = 1,
     &                  conv_state = 2, noprog_state = 3 )
      parameter         ( base_residual = 0, extra_residual = 1,
     &                  extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      double precision   dlamch
      end subroutine dla_porfsx_extended

      !! dla_porpvgrw.f
      double precision function dla_porpvgrw( uplo, ncols, a, lda, af,
     &                                        ldaf, work )
      character(len=1)   uplo
      integer            ncols, lda, ldaf
      double precision   a( lda, * ), af( ldaf, * ), work( * )
      integer            i, j
      double precision   amax, umax, rpvgrw
      logical            upper
      logical            lsame
      end function dla_porpvgrw

      !! dlapy2.f
      double precision function dlapy2( x, y )
      double precision   x, y
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   w, xabs, yabs, z
      end function dlapy2

      !! dlapy3.f
      double precision function dlapy3( x, y, z )
      double precision   x, y, z
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   w, xabs, yabs, zabs
      end function dlapy3

      !! dlaqgb.f
      subroutine dlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, equed )
      character          equed
      integer            kl, ku, ldab, m, n
      double precision   amax, colcnd, rowcnd
      double precision   ab( ldab, * ), c( * ), r( * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      double precision   dlamch
      end subroutine dlaqgb

      !! dlaqge.f
      subroutine dlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   equed )
      character          equed
      integer            lda, m, n
      double precision   amax, colcnd, rowcnd
      double precision   a( lda, * ), c( * ), r( * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      double precision   dlamch
      end subroutine dlaqge

      !! dlaqp2.f
      subroutine dlaqp2( m, n, offset, a, lda, jpvt, tau, vn1, vn2,
     &                   work )
      integer            lda, m, n, offset
      integer            jpvt( * )
      double precision   a( lda, * ), tau( * ), vn1( * ), vn2( * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i, itemp, j, mn, offpi, pvt
      double precision   aii, temp, temp2, tol3z
      integer            idamax
      double precision   dlamch, dnrm2
      end subroutine dlaqp2

      !! dlaqps.f
      subroutine dlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,
     &                   vn2, auxv, f, ldf )
      integer            kb, lda, ldf, m, n, nb, offset
      integer            jpvt( * )
      double precision   a( lda, * ), auxv( * ), f( ldf, * ), tau( * ),
     &                   vn1( * ), vn2( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            itemp, j, k, lastrk, lsticc, pvt, rk
      double precision   akk, temp, temp2, tol3z
      integer            idamax
      double precision   dlamch, dnrm2
      end subroutine dlaqps

      !! dlaqr0.f
      subroutine dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,
     &                   iloz, ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      double precision   h( ldh, * ), wi( * ), work( * ), wr( * ),
     &                   z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      double precision   wilk1, wilk2
      parameter          ( wilk1 = 0.75d0, wilk2 = -0.4375d0 )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      double precision   aa, bb, cc, cs, dd, sn, ss, swap
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      double precision   zdum( 1, 1 )
      end subroutine dlaqr0

      !! dlaqr1.f
      subroutine dlaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
      double precision   si1, si2, sr1, sr2
      integer            ldh, n
      double precision   h( ldh, * ), v( * )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   h21s, h31s, s
      end subroutine dlaqr1

      !! dlaqr2.f
      subroutine dlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t,
     &                   ldt, nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      double precision   h( ldh, * ), si( * ), sr( * ), t( ldt, * ),
     &                   v( ldv, * ), work( * ), wv( ldwv, * ),
     &                   z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      double precision   aa, bb, beta, cc, cs, dd, evi, evk, foo, s,
     &                   safmax, safmin, smlnum, sn, tau, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, k, kcol,
     &                   kend, kln, krow, kwtop, ltop, lwk1, lwk2,
     &                   lwkopt
      logical            bulge, sorted
      double precision   dlamch
      end subroutine dlaqr2

      !! dlaqr3.f
      subroutine dlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t,
     &                   ldt, nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      double precision   h( ldh, * ), si( * ), sr( * ), t( ldt, * ),
     &                   v( ldv, * ), work( * ), wv( ldwv, * ),
     &                   z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      double precision   aa, bb, beta, cc, cs, dd, evi, evk, foo, s,
     &                   safmax, safmin, smlnum, sn, tau, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, k, kcol,
     &                   kend, kln, krow, kwtop, ltop, lwk1, lwk2, lwk3,
     &                   lwkopt, nmin
      logical            bulge, sorted
      double precision   dlamch
      integer            ilaenv
      end subroutine dlaqr3

      !! dlaqr4.f
      subroutine dlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,
     &                   iloz, ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      double precision   h( ldh, * ), wi( * ), work( * ), wr( * ),
     &                   z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      double precision   wilk1, wilk2
      parameter          ( wilk1 = 0.75d0, wilk2 = -0.4375d0 )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      double precision   aa, bb, cc, cs, dd, sn, ss, swap
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      double precision   zdum( 1, 1 )
      end subroutine dlaqr4

      !! dlaqr5.f
      subroutine dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,
     &                   sr, si, h, ldh, iloz, ihiz, z, ldz, v, ldv, u,
     &                   ldu, nv, wv, ldwv, nh, wh, ldwh )
      integer            ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv,
     &                   ldwh, ldwv, ldz, n, nh, nshfts, nv
      logical            wantt, wantz
      double precision   h( ldh, * ), si( * ), sr( * ), u( ldu, * ),
     &                   v( ldv, * ), wh( ldwh, * ), wv( ldwv, * ),
     &                   z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      double precision   alpha, beta, h11, h12, h21, h22, refsum,
     &                   safmax, safmin, scl, smlnum, swap, tst1, tst2,
     &                   ulp
      integer            i, i2, i4, incol, j, j2, j4, jbot, jcol, jlen,
     &                   jrow, jtop, k, k1, kdu, kms, knz, krcol, kzs,
     &                   m, m22, mbot, mend, mstart, mtop, nbmps, ndcol,
     &                   ns, nu
      logical            accum, blk22, bmp22
      double precision   dlamch
      double precision   vt( 3 )
      end subroutine dlaqr5

      !! dlaqsb.f
      subroutine dlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
      character          equed, uplo
      integer            kd, ldab, n
      double precision   amax, scond
      double precision   ab( ldab, * ), s( * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine dlaqsb

      !! dlaqsp.f
      subroutine dlaqsp( uplo, n, ap, s, scond, amax, equed )
      character          equed, uplo
      integer            n
      double precision   amax, scond
      double precision   ap( * ), s( * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j, jc
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine dlaqsp

      !! dlaqsy.f
      subroutine dlaqsy( uplo, n, a, lda, s, scond, amax, equed )
      character          equed, uplo
      integer            lda, n
      double precision   amax, scond
      double precision   a( lda, * ), s( * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine dlaqsy

      !! dlaqtr.f
      subroutine dlaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,
     &                   info )
      logical            lreal, ltran
      integer            info, ldt, n
      double precision   scale, w
      double precision   b( * ), t( ldt, * ), work( * ), x( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            notran
      integer            i, ierr, j, j1, j2, jnext, k, n1, n2
      double precision   bignum, eps, rec, scaloc, si, smin, sminw,
     &                   smlnum, sr, tjj, tmp, xj, xmax, xnorm, z
      double precision   d( 2, 2 ), v( 2, 2 )
      integer            idamax
      double precision   dasum, ddot, dlamch, dlange
      end subroutine dlaqtr

      !! dlar1v.f
      subroutine dlar1v( n, b1, bn, lambda, d, l, ld, lld,
     &           pivmin, gaptol, z, wantnc, negcnt, ztz, mingma,
     &           r, isuppz, nrminv, resid, rqcorr, work )
      logical            wantnc
      integer   b1, bn, n, negcnt, r
      double precision   gaptol, lambda, mingma, nrminv, pivmin, resid,
     &                   rqcorr, ztz
      integer            isuppz( * )
      double precision   d( * ), l( * ), ld( * ), lld( * ),
     &                  work( * )
      double precision z( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            sawnan1, sawnan2
      integer            i, indlpl, indp, inds, indumn, neg1, neg2, r1,
     &                   r2
      double precision   dminus, dplus, eps, s, tmp
      logical disnan
      double precision   dlamch
      end subroutine dlar1v

      !! dlar2v.f
      subroutine dlar2v( n, x, y, z, incx, c, s, incc )
      integer            incc, incx, n
      double precision   c( * ), s( * ), x( * ), y( * ), z( * )
      integer            i, ic, ix
      double precision   ci, si, t1, t2, t3, t4, t5, t6, xi, yi, zi
      end subroutine dlar2v

      !! dlarfb.f
      subroutine dlarfb( side, trans, direct, storev, m, n, k, v, ldv,
     &                   t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, ldc, ldt, ldv, ldwork, m, n
      double precision   c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      character          transt
      integer            i, j
      logical            lsame
      end subroutine dlarfb

      !! dlarf.f
      subroutine dlarf( side, m, n, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, ldc, m, n
      double precision   tau
      double precision   c( ldc, * ), v( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            applyleft
      integer            i, lastv, lastc
      logical            lsame
      integer            iladlr, iladlc
      end subroutine dlarf

      !! dlarfg.f
      subroutine dlarfg( n, alpha, x, incx, tau )
      integer            incx, n
      double precision   alpha, tau
      double precision   x( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            j, knt
      double precision   beta, rsafmn, safmin, xnorm
      double precision   dlamch, dlapy2, dnrm2
      end subroutine dlarfg

      !! dlarfgp.f
      subroutine dlarfgp( n, alpha, x, incx, tau )
      integer            incx, n
      double precision   alpha, tau
      double precision   x( * )
      double precision   two, one, zero
      parameter          ( two = 2.0d+0, one = 1.0d+0, zero = 0.0d+0 )
      integer            j, knt
      double precision   beta, bignum, savealpha, smlnum, xnorm
      double precision   dlamch, dlapy2, dnrm2
      end subroutine dlarfgp

      !! dlarft.f
      subroutine dlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      double precision   t( ldt, * ), tau( * ), v( ldv, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, prevlastv, lastv
      logical            lsame
      end subroutine dlarft

      !! dlarfx.f
      subroutine dlarfx( side, m, n, v, tau, c, ldc, work )
      character          side
      integer            ldc, m, n
      double precision   tau
      double precision   c( ldc, * ), v( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            j
      double precision   sum, t1, t10, t2, t3, t4, t5, t6, t7, t8, t9,
     &                   v1, v10, v2, v3, v4, v5, v6, v7, v8, v9
      logical            lsame
      end subroutine dlarfx

      !! dlargv.f
      subroutine dlargv( n, x, incx, y, incy, c, incc )
      integer            incc, incx, incy, n
      double precision   c( * ), x( * ), y( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i, ic, ix, iy
      double precision   f, g, t, tt
      end subroutine dlargv

      !! dlarnv.f
      subroutine dlarnv( idist, iseed, n, x )
      integer            idist, n
      integer            iseed( 4 )
      double precision   x( * )
      double precision   one, two
      parameter          ( one = 1.0d+0, two = 2.0d+0 )
      integer            lv
      parameter          ( lv = 128 )
      double precision   twopi
      parameter          ( twopi = 6.2831853071795864769252867663d+0 )
      integer            i, il, il2, iv
      double precision   u( lv )
      end subroutine dlarnv

      !! dlarra.f
      subroutine dlarra( n, d, e, e2, spltol, tnrm,
     &                    nsplit, isplit, info )
      integer            info, n, nsplit
      double precision    spltol, tnrm
      integer            isplit( * )
      double precision   d( * ), e( * ), e2( * )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      integer            i
      double precision   eabs, tmp1
      end subroutine dlarra

      !! dlarrb.f
      subroutine dlarrb( n, d, lld, ifirst, ilast, rtol1,
     &                   rtol2, offset, w, wgap, werr, work, iwork,
     &                   pivmin, spdiam, twist, info )
      integer            ifirst, ilast, info, n, offset, twist
      double precision   pivmin, rtol1, rtol2, spdiam
      integer            iwork( * )
      double precision   d( * ), lld( * ), w( * ),
     &                   werr( * ), wgap( * ), work( * )
      double precision   zero, two, half
      parameter        ( zero = 0.0d0, two = 2.0d0,
     &                   half = 0.5d0 )
      integer   maxitr
      integer            i, i1, ii, ip, iter, k, negcnt, next, nint,
     &                   olnint, prev, r
      double precision   back, cvrgd, gap, left, lgap, mid, mnwdth,
     &                   rgap, right, tmp, width
      integer            dlaneg
      end subroutine dlarrb

      !! dlarrc.f
      subroutine dlarrc( jobt, n, vl, vu, d, e, pivmin,
     &                            eigcnt, lcnt, rcnt, info )
      character          jobt
      integer            eigcnt, info, lcnt, n, rcnt
      double precision   pivmin, vl, vu
      double precision   d( * ), e( * )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      integer            i
      logical            matt
      double precision   lpivot, rpivot, sl, su, tmp, tmp2
      logical            lsame
      end subroutine dlarrc

      !! dlarrd.f
      subroutine dlarrd( range, order, n, vl, vu, il, iu, gers,
     &                    reltol, d, e, e2, pivmin, nsplit, isplit,
     &                    m, w, werr, wl, wu, iblock, indexw,
     &                    work, iwork, info )
      character          order, range
      integer            il, info, iu, m, n, nsplit
      double precision    pivmin, reltol, vl, vu, wl, wu
      integer            iblock( * ), indexw( * ),
     &                   isplit( * ), iwork( * )
      double precision   d( * ), e( * ), e2( * ),
     &                   gers( * ), w( * ), werr( * ), work( * )
      double precision   zero, one, two, half, fudge
      parameter          ( zero = 0.0d0, one = 1.0d0,
     &                     two = 2.0d0, half = one/two,
     &                     fudge = two )
      integer   allrng, valrng, indrng
      parameter ( allrng = 1, valrng = 2, indrng = 3 )
      logical            ncnvrg, toofew
      integer            i, ib, ibegin, idiscl, idiscu, ie, iend, iinfo,
     &                   im, in, ioff, iout, irange, itmax, itmp1,
     &                   itmp2, iw, iwoff, j, jblk, jdisc, je, jee, nb,
     &                   nwl, nwu
      double precision   atoli, eps, gl, gu, rtoli, tmp1, tmp2,
     &                   tnorm, uflow, wkill, wlu, wul
      integer            idumma( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch
      end subroutine dlarrd

      !! dlarre.f
      subroutine dlarre( range, n, vl, vu, il, iu, d, e, e2,
     &                    rtol1, rtol2, spltol, nsplit, isplit, m,
     &                    w, werr, wgap, iblock, indexw, gers, pivmin,
     &                    work, iwork, info )
      character          range
      integer            il, info, iu, m, n, nsplit
      double precision  pivmin, rtol1, rtol2, spltol, vl, vu
      integer            iblock( * ), isplit( * ), iwork( * ),
     &                   indexw( * )
      double precision   d( * ), e( * ), e2( * ), gers( * ),
     &                   w( * ),werr( * ), wgap( * ), work( * )
      double precision   fac, four, fourth, fudge, half, hndrd,
     &                   maxgrowth, one, pert, two, zero
      parameter          ( zero = 0.0d0, one = 1.0d0,
     &                     two = 2.0d0, four=4.0d0,
     &                     hndrd = 100.0d0,
     &                     pert = 8.0d0,
     &                     half = one/two, fourth = one/four, fac= half,
     &                     maxgrowth = 64.0d0, fudge = 2.0d0 )
      integer            maxtry, allrng, indrng, valrng
      parameter          ( maxtry = 6, allrng = 1, indrng = 2,
     &                     valrng = 3 )
      logical            forceb, norep, usedqd
      integer            cnt, cnt1, cnt2, i, ibegin, idum, iend, iinfo,
     &                   in, indl, indu, irange, j, jblk, mb, mm,
     &                   wbegin, wend
      double precision   avgap, bsrtol, clwdth, dmax, dpivot, eabs,
     &                   emax, eold, eps, gl, gu, isleft, isrght, rtl,
     &                   rtol, s1, s2, safmin, sgndef, sigma, spdiam,
     &                   tau, tmp, tmp1
      integer            iseed( 4 )
      logical            lsame
      double precision            dlamch
      end subroutine dlarre

      !! dlarrf.f
      subroutine dlarrf( n, d, l, ld, clstrt, clend,
     &                   w, wgap, werr,
     &                   spdiam, clgapl, clgapr, pivmin, sigma,
     &                   dplus, lplus, work, info )
      integer            clstrt, clend, info, n
      double precision   clgapl, clgapr, pivmin, sigma, spdiam
      double precision   d( * ), dplus( * ), l( * ), ld( * ),
     &          lplus( * ), w( * ), wgap( * ), werr( * ), work( * )
      double precision   four, maxgrowth1, maxgrowth2, one, quart, two
      parameter          ( one = 1.0d0, two = 2.0d0, four = 4.0d0,
     &                     quart = 0.25d0,
     &                     maxgrowth1 = 8.d0,
     &                     maxgrowth2 = 8.d0 )
      logical   dorrr1, forcer, nofail, sawnan1, sawnan2, tryrrr1
      integer            i, indx, ktry, ktrymax, sleft, sright, shift
      parameter          ( ktrymax = 1, sleft = 1, sright = 2 )
      double precision   avgap, bestshift, clwdth, eps, fact, fail,
     &                   fail2, growthbound, ldelta, ldmax, lsigma,
     &                   max1, max2, mingap, oldp, prod, rdelta, rdmax,
     &                   rrr1, rrr2, rsigma, s, smlgrowth, tmp, znm2
      logical disnan
      double precision   dlamch
      end subroutine dlarrf

      !! dlarrj.f
      subroutine dlarrj( n, d, e2, ifirst, ilast,
     &                   rtol, offset, w, werr, work, iwork,
     &                   pivmin, spdiam, info )
      integer            ifirst, ilast, info, n, offset
      double precision   pivmin, rtol, spdiam
      integer            iwork( * )
      double precision   d( * ), e2( * ), w( * ),
     &                   werr( * ), work( * )
      double precision   zero, one, two, half
      parameter        ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   half = 0.5d0 )
      integer   maxitr
      integer            cnt, i, i1, i2, ii, iter, j, k, next, nint,
     &                   olnint, p, prev, savi1
      double precision   dplus, fac, left, mid, right, s, tmp, width
      end subroutine dlarrj

      !! dlarrk.f
      subroutine dlarrk( n, iw, gl, gu,
     &                    d, e2, pivmin, reltol, w, werr, info)
      integer   info, iw, n
      double precision    pivmin, reltol, gl, gu, w, werr
      double precision   d( * ), e2( * )
      double precision   fudge, half, two, zero
      parameter          ( half = 0.5d0, two = 2.0d0,
     &                     fudge = two, zero = 0.0d0 )
      integer   i, it, itmax, negcnt
      double precision   atoli, eps, left, mid, right, rtoli, tmp1,
     &                   tmp2, tnorm
      double precision   dlamch
      end subroutine dlarrk

      !! dlarrr.f
      subroutine dlarrr( n, d, e, info )
      integer            n, info
      double precision   d( * ), e( * )
      double precision   zero, relcond
      parameter          ( zero = 0.0d0,
     &                     relcond = 0.999d0 )
      integer            i
      logical            yesrel
      double precision   eps, safmin, smlnum, rmin, tmp, tmp2,
     &          offdig, offdig2
      double precision   dlamch
      end subroutine dlarrr

      !! dlarrv.f
      subroutine dlarrv( n, vl, vu, d, l, pivmin,
     &                   isplit, m, dol, dou, minrgp,
     &                   rtol1, rtol2, w, werr, wgap,
     &                   iblock, indexw, gers, z, ldz, isuppz,
     &                   work, iwork, info )
      integer            dol, dou, info, ldz, m, n
      double precision   minrgp, pivmin, rtol1, rtol2, vl, vu
      integer            iblock( * ), indexw( * ), isplit( * ),
     &                   isuppz( * ), iwork( * )
      double precision   d( * ), gers( * ), l( * ), w( * ), werr( * ),
     &                   wgap( * ), work( * )
      double precision  z( ldz, * )
      integer            maxitr
      parameter          ( maxitr = 10 )
      double precision   zero, one, two, three, four, half
      parameter          ( zero = 0.0d0, one = 1.0d0,
     &                     two = 2.0d0, three = 3.0d0,
     &                     four = 4.0d0, half = 0.5d0)
      logical            eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
      integer            done, i, ibegin, idone, iend, ii, iindc1,
     &                   iindc2, iindr, iindwk, iinfo, im, in, indeig,
     &                   indld, indlld, indwrk, isupmn, isupmx, iter,
     &                   itmp1, j, jblk, k, miniwsize, minwsize, nclus,
     &                   ndepth, negcnt, newcls, newfst, newftt, newlst,
     &                   newsiz, offset, oldcls, oldfst, oldien, oldlst,
     &                   oldncl, p, parity, q, wbegin, wend, windex,
     &                   windmn, windpl, zfrom, zto, zusedl, zusedu,
     &                   zusedw
      double precision   bstres, bstw, eps, fudge, gap, gaptol, gl, gu,
     &                   lambda, left, lgap, mingma, nrminv, resid,
     &                   rgap, right, rqcorr, rqtol, savgap, sgndef,
     &                   sigma, spdiam, ssigma, tau, tmp, tol, ztz
      double precision   dlamch
      end subroutine dlarrv

      !! dlarscl2.f
      subroutine dlarscl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      double precision   d( * ), x( ldx, * )
      integer            i, j
      end subroutine dlarscl2

      !! dlartg.f
      subroutine dlartg( f, g, cs, sn, r )
      double precision   cs, f, g, r, sn
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      integer            count, i
      double precision   eps, f1, g1, safmin, safmn2, safmx2, scale
      double precision   dlamch
      end subroutine dlartg

      !! dlartgp.f
      subroutine dlartgp( f, g, cs, sn, r )
      double precision   cs, f, g, r, sn
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      integer            count, i
      double precision   eps, f1, g1, safmin, safmn2, safmx2, scale
      double precision   dlamch
      end subroutine dlartgp

      !! dlartgs.f
      subroutine dlartgs( x, y, sigma, cs, sn )
      double precision        cs, sigma, sn, x, y
      double precision        negone, one, zero
      parameter          ( negone = -1.0d0, one = 1.0d0, zero = 0.0d0 )
      double precision        r, s, thresh, w, z
      double precision        dlamch
      end subroutine dlartgs

      !! dlartv.f
      subroutine dlartv( n, x, incx, y, incy, c, s, incc )
      integer            incc, incx, incy, n
      double precision   c( * ), s( * ), x( * ), y( * )
      integer            i, ic, ix, iy
      double precision   xi, yi
      end subroutine dlartv

      !! dlaruv.f
      subroutine dlaruv( iseed, n, x )
      integer            n
      integer            iseed( 4 )
      double precision   x( n )
      double precision   one
      parameter          ( one = 1.0d0 )
      integer            lv, ipw2
      double precision   r
      parameter          ( lv = 128, ipw2 = 4096, r = one / ipw2 )
      integer            i, i1, i2, i3, i4, it1, it2, it3, it4, j
      integer            mm( lv, 4 )
      end subroutine dlaruv

      !! dlarzb.f
      subroutine dlarzb( side, trans, direct, storev, m, n, k, l, v,
     &                   ldv, t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, l, ldc, ldt, ldv, ldwork, m, n
      double precision   c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      character          transt
      integer            i, info, j
      logical            lsame
      end subroutine dlarzb

      !! dlarz.f
      subroutine dlarz( side, m, n, l, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, l, ldc, m, n
      double precision   tau
      double precision   c( ldc, * ), v( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            lsame
      end subroutine dlarz

      !! dlarzt.f
      subroutine dlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      double precision   t( ldt, * ), tau( * ), v( ldv, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            i, info, j
      logical            lsame
      end subroutine dlarzt

      !! dlas2.f
      subroutine dlas2( f, g, h, ssmin, ssmax )
      double precision   f, g, h, ssmax, ssmin
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      double precision   as, at, au, c, fa, fhmn, fhmx, ga, ha
      end subroutine dlas2

      !! dlascl2.f
      subroutine dlascl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      double precision   d( * ), x( ldx, * )
      integer            i, j
      end subroutine dlascl2

      !! dlascl.f
      subroutine dlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
      character          type
      integer            info, kl, ku, lda, m, n
      double precision   cfrom, cto
      double precision   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            done
      integer            i, itype, j, k1, k2, k3, k4
      double precision   bignum, cfrom1, cfromc, cto1, ctoc, mul, smlnum
      logical            lsame, disnan
      double precision   dlamch
      end subroutine dlascl

      !! dlasd0.f
      subroutine dlasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,
     &                   work, info )
      integer            info, ldu, ldvt, n, smlsiz, sqre
      integer            iwork( * )
      double precision   d( * ), e( * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      integer            i, i1, ic, idxq, idxqc, im1, inode, itemp, iwk,
     &                   j, lf, ll, lvl, m, ncc, nd, ndb1, ndiml, ndimr,
     &                   nl, nlf, nlp1, nlvl, nr, nrf, nrp1, sqrei
      double precision   alpha, beta
      end subroutine dlasd0

      !! dlasd1.f
      subroutine dlasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,
     &                   idxq, iwork, work, info )
      integer            info, ldu, ldvt, nl, nr, sqre
      double precision   alpha, beta
      integer            idxq( * ), iwork( * )
      double precision   d( * ), u( ldu, * ), vt( ldvt, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            coltyp, i, idx, idxc, idxp, iq, isigma, iu2,
     &                   ivt2, iz, k, ldq, ldu2, ldvt2, m, n, n1, n2
      double precision   orgnrm
      end subroutine dlasd1

      !! dlasd2.f
      subroutine dlasd2( nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt,
     &                   ldvt, dsigma, u2, ldu2, vt2, ldvt2, idxp, idx,
     &                   idxc, idxq, coltyp, info )
      integer            info, k, ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
      double precision   alpha, beta
      integer            coltyp( * ), idx( * ), idxc( * ), idxp( * ),
     &                   idxq( * )
      double precision   d( * ), dsigma( * ), u( ldu, * ),
     &                   u2( ldu2, * ), vt( ldvt, * ), vt2( ldvt2, * ),
     &                   z( * )
      double precision   zero, one, two, eight
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0,
     &                   eight = 8.0d+0 )
      integer            ctot( 4 ), psm( 4 )
      integer            ct, i, idxi, idxj, idxjp, j, jp, jprev, k2, m,
     &                   n, nlp1, nlp2
      double precision   c, eps, hlftol, s, tau, tol, z1
      double precision   dlamch, dlapy2
      end subroutine dlasd2

      !! dlasd3.f
      subroutine dlasd3( nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2,
     &                   ldu2, vt, ldvt, vt2, ldvt2, idxc, ctot, z,
     &                   info )
      integer            info, k, ldq, ldu, ldu2, ldvt, ldvt2, nl, nr,
     &                   sqre
      integer            ctot( * ), idxc( * )
      double precision   d( * ), dsigma( * ), q( ldq, * ), u( ldu, * ),
     &                   u2( ldu2, * ), vt( ldvt, * ), vt2( ldvt2, * ),
     &                   z( * )
      double precision   one, zero, negone
      parameter          ( one = 1.0d+0, zero = 0.0d+0,
     &                   negone = -1.0d+0 )
      integer            ctemp, i, j, jc, ktemp, m, n, nlp1, nlp2, nrp1
      double precision   rho, temp
      double precision   dlamc3, dnrm2
      end subroutine dlasd3

      !! dlasd4.f
      subroutine dlasd4( n, i, d, z, delta, rho, sigma, work, info )
      integer            i, info, n
      double precision   rho, sigma
      double precision   d( * ), delta( * ), work( * ), z( * )
      integer            maxit
      parameter          ( maxit = 400 )
      double precision   zero, one, two, three, four, eight, ten
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0,
     &                   three = 3.0d+0, four = 4.0d+0, eight = 8.0d+0,
     &                   ten = 10.0d+0 )
      logical            orgati, swtch, swtch3, geomavg
      integer            ii, iim1, iip1, ip1, iter, j, niter
      double precision   a, b, c, delsq, delsq2, sq2, dphi, dpsi, dtiim,
     &                   dtiip, dtipsq, dtisq, dtnsq, dtnsq1, dw, eps,
     &                   erretm, eta, phi, prew, psi, rhoinv, sglb,
     &                   sgub, tau, tau2, temp, temp1, temp2, w
      double precision   dd( 3 ), zz( 3 )
      double precision   dlamch
      end subroutine dlasd4

      !! dlasd5.f
      subroutine dlasd5( i, d, z, delta, rho, dsigma, work )
      integer            i
      double precision   dsigma, rho
      double precision   d( 2 ), delta( 2 ), work( 2 ), z( 2 )
      double precision   zero, one, two, three, four
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0,
     &                   three = 3.0d+0, four = 4.0d+0 )
      double precision   b, c, del, delsq, tau, w
      end subroutine dlasd5

      !! dlasd6.f
      subroutine dlasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,
     &                   idxq, perm, givptr, givcol, ldgcol, givnum,
     &                   ldgnum, poles, difl, difr, z, k, c, s, work,
     &                   iwork, info )
      integer            givptr, icompq, info, k, ldgcol, ldgnum, nl,
     &                   nr, sqre
      double precision   alpha, beta, c, s
      integer            givcol( ldgcol, * ), idxq( * ), iwork( * ),
     &                   perm( * )
      double precision   d( * ), difl( * ), difr( * ),
     &                   givnum( ldgnum, * ), poles( ldgnum, * ),
     &                   vf( * ), vl( * ), work( * ), z( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, idx, idxc, idxp, isigma, ivfw, ivlw, iw, m,
     &                   n, n1, n2
      double precision   orgnrm
      end subroutine dlasd6

      !! dlasd7.f
      subroutine dlasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,
     &                   vlw, alpha, beta, dsigma, idx, idxp, idxq,
     &                   perm, givptr, givcol, ldgcol, givnum, ldgnum,
     &                   c, s, info )
      integer            givptr, icompq, info, k, ldgcol, ldgnum, nl,
     &                   nr, sqre
      double precision   alpha, beta, c, s
      integer            givcol( ldgcol, * ), idx( * ), idxp( * ),
     &                   idxq( * ), perm( * )
      double precision   d( * ), dsigma( * ), givnum( ldgnum, * ),
     &                   vf( * ), vfw( * ), vl( * ), vlw( * ), z( * ),
     &                   zw( * )
      double precision   zero, one, two, eight
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0,
     &                   eight = 8.0d+0 )
      integer            i, idxi, idxj, idxjp, j, jp, jprev, k2, m, n,
     &                   nlp1, nlp2
      double precision   eps, hlftol, tau, tol, z1
      double precision   dlamch, dlapy2
      end subroutine dlasd7

      !! dlasd8.f
      subroutine dlasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,
     &                   dsigma, work, info )
      integer            icompq, info, k, lddifr
      double precision   d( * ), difl( * ), difr( lddifr, * ),
     &                   dsigma( * ), vf( * ), vl( * ), work( * ),
     &                   z( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      integer            i, iwk1, iwk2, iwk2i, iwk3, iwk3i, j
      double precision   diflj, difrj, dj, dsigj, dsigjp, rho, temp
      double precision   ddot, dlamc3, dnrm2
      end subroutine dlasd8

      !! dlasda.f
      subroutine dlasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,
     &                   difl, difr, z, poles, givptr, givcol, ldgcol,
     &                   perm, givnum, c, s, work, iwork, info )
      integer            icompq, info, ldgcol, ldu, n, smlsiz, sqre
      integer            givcol( ldgcol, * ), givptr( * ), iwork( * ),
     &                   k( * ), perm( ldgcol, * )
      double precision   c( * ), d( * ), difl( ldu, * ), difr( ldu, * ),
     &                   e( * ), givnum( ldu, * ), poles( ldu, * ),
     &                   s( * ), u( ldu, * ), vt( ldu, * ), work( * ),
     &                   z( ldu, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i, i1, ic, idxq, idxqi, im1, inode, itemp, iwk,
     &                   j, lf, ll, lvl, lvl2, m, ncc, nd, ndb1, ndiml,
     &                   ndimr, nl, nlf, nlp1, nlvl, nr, nrf, nrp1, nru,
     &                   nwork1, nwork2, smlszp, sqrei, vf, vfi, vl, vli
      double precision   alpha, beta
      end subroutine dlasda

      !! dlasdq.f
      subroutine dlasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,
     &                   u, ldu, c, ldc, work, info )
      character          uplo
      integer            info, ldc, ldu, ldvt, n, ncc, ncvt, nru, sqre
      double precision   c( ldc, * ), d( * ), e( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            rotate
      integer            i, isub, iuplo, j, np1, sqre1
      double precision   cs, r, smin, sn
      logical            lsame
      end subroutine dlasdq

      !! dlasdt.f
      subroutine dlasdt( n, lvl, nd, inode, ndiml, ndimr, msub )
      integer            lvl, msub, n, nd
      integer            inode( * ), ndiml( * ), ndimr( * )
      double precision   two
      parameter          ( two = 2.0d+0 )
      integer            i, il, ir, llst, maxn, ncrnt, nlvl
      double precision   temp
      end subroutine dlasdt

      !! dlaset.f
      subroutine dlaset( uplo, m, n, alpha, beta, a, lda )
      character          uplo
      integer            lda, m, n
      double precision   alpha, beta
      double precision   a( lda, * )
      integer            i, j
      logical            lsame
      end subroutine dlaset

      !! dlasq1.f
      subroutine dlasq1( n, d, e, work, info )
      integer            info, n
      double precision   d( * ), e( * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      integer            i, iinfo
      double precision   eps, scale, safmin, sigmn, sigmx
      double precision   dlamch
      end subroutine dlasq1

      !! dlasq2.f
      subroutine dlasq2( n, z, info )
      integer            info, n
      double precision   z( * )
      double precision   cbias
      parameter          ( cbias = 1.50d0 )
      double precision   zero, half, one, two, four, hundrd
      parameter          ( zero = 0.0d0, half = 0.5d0, one = 1.0d0,
     &                     two = 2.0d0, four = 4.0d0, hundrd = 100.0d0 )
      logical            ieee
      integer            i0, i1, i4, iinfo, ipn4, iter, iwhila, iwhilb,
     &                   k, kmin, n0, n1, nbig, ndiv, nfail, pp, splt,
     &                   ttype
      double precision   d, dee, deemin, desig, dmin, dmin1, dmin2, dn,
     &                   dn1, dn2, e, emax, emin, eps, g, oldemn, qmax,
     &                   qmin, s, safmin, sigma, t, tau, temp, tol,
     &                   tol2, trace, zmax, tempe, tempq
      integer            ilaenv
      double precision   dlamch
      end subroutine dlasq2

      !! dlasq3.f
      subroutine dlasq3( i0, n0, z, pp, dmin, sigma, desig, qmax, nfail,
     &                   iter, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1,
     &                   dn2, g, tau )
      logical            ieee
      integer            i0, iter, n0, ndiv, nfail, pp
      double precision   desig, dmin, dmin1, dmin2, dn, dn1, dn2, g,
     &                   qmax, sigma, tau
      double precision   z( * )
      double precision   cbias
      parameter          ( cbias = 1.50d0 )
      double precision   zero, qurtr, half, one, two, hundrd
      parameter          ( zero = 0.0d0, qurtr = 0.250d0, half = 0.5d0,
     &                     one = 1.0d0, two = 2.0d0, hundrd = 100.0d0 )
      integer            ipn4, j4, n0in, nn, ttype
      double precision   eps, s, t, temp, tol, tol2
      double precision   dlamch
      logical            disnan
      end subroutine dlasq3

      !! dlasq4.f
      subroutine dlasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,
     &                   dn1, dn2, tau, ttype, g )
      integer            i0, n0, n0in, pp, ttype
      double precision   dmin, dmin1, dmin2, dn, dn1, dn2, g, tau
      double precision   z( * )
      double precision   cnst1, cnst2, cnst3
      parameter          ( cnst1 = 0.5630d0, cnst2 = 1.010d0,
     &                   cnst3 = 1.050d0 )
      double precision   qurtr, third, half, zero, one, two, hundrd
      parameter          ( qurtr = 0.250d0, third = 0.3330d0,
     &                   half = 0.50d0, zero = 0.0d0, one = 1.0d0,
     &                   two = 2.0d0, hundrd = 100.0d0 )
      integer            i4, nn, np
      double precision   a2, b1, b2, gam, gap1, gap2, s
      end subroutine dlasq4

      !! dlasq5.f
      subroutine dlasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,
     &                   dn, dnm1, dnm2, ieee, eps )
      logical            ieee
      integer            i0, n0, pp
      double precision   dmin, dmin1, dmin2, dn, dnm1, dnm2, tau,
     &                   sigma, eps
      double precision   z( * )
      double precision   zero, half
      parameter          ( zero = 0.0d0, half = 0.5 )
      integer            j4, j4p2
      double precision   d, emin, temp, dthresh
      end subroutine dlasq5

      !! dlasq6.f
      subroutine dlasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,
     &                   dnm1, dnm2 )
      integer            i0, n0, pp
      double precision   dmin, dmin1, dmin2, dn, dnm1, dnm2
      double precision   z( * )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      integer            j4, j4p2
      double precision   d, emin, safmin, temp
      double precision   dlamch
      end subroutine dlasq6

      !! dlasr.f
      subroutine dlasr( side, pivot, direct, m, n, c, s, a, lda )
      character          direct, pivot, side
      integer            lda, m, n
      double precision   a( lda, * ), c( * ), s( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, info, j
      double precision   ctemp, stemp, temp
      logical            lsame
      end subroutine dlasr

      !! dlasrt.f
      subroutine dlasrt( id, n, d, info )
      character          id
      integer            info, n
      double precision   d( * )
      integer            select
      parameter          ( select = 20 )
      integer            dir, endd, i, j, start, stkpnt
      double precision   d1, d2, d3, dmnmx, tmp
      integer            stack( 2, 32 )
      logical            lsame
      end subroutine dlasrt

      !! dlassq.f
      subroutine dlassq( n, x, incx, scale, sumsq )
      integer            incx, n
      double precision   scale, sumsq
      double precision   x( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            ix
      double precision   absxi
      logical            disnan
      end subroutine dlassq

      !! dlasv2.f
      subroutine dlasv2( f, g, h, ssmin, ssmax, snr, csr, snl, csl )
      double precision   csl, csr, f, g, h, snl, snr, ssmax, ssmin
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   half
      parameter          ( half = 0.5d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   two
      parameter          ( two = 2.0d0 )
      double precision   four
      parameter          ( four = 4.0d0 )
      logical            gasmal, swap
      integer            pmax
      double precision   a, clt, crt, d, fa, ft, ga, gt, ha, ht, l, m,
     &                   mm, r, s, slt, srt, t, temp, tsign, tt
      double precision   dlamch
      end subroutine dlasv2

      !! dlaswp.f
      subroutine dlaswp( n, a, lda, k1, k2, ipiv, incx )
      integer            incx, k1, k2, lda, n
      integer            ipiv( * )
      double precision   a( lda, * )
      integer            i, i1, i2, inc, ip, ix, ix0, j, k, n32
      double precision   temp
      end subroutine dlaswp

      !! dlasy2.f
      subroutine dlasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,
     &                   ldtr, b, ldb, scale, x, ldx, xnorm, info )
      logical            ltranl, ltranr
      integer            info, isgn, ldb, ldtl, ldtr, ldx, n1, n2
      double precision   scale, xnorm
      double precision   b( ldb, * ), tl( ldtl, * ), tr( ldtr, * ),
     &                   x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   two, half, eight
      parameter          ( two = 2.0d+0, half = 0.5d+0, eight = 8.0d+0 )
      logical            bswap, xswap
      integer            i, ip, ipiv, ipsv, j, jp, jpsv, k
      double precision   bet, eps, gam, l21, sgn, smin, smlnum, tau1,
     &                   temp, u11, u12, u22, xmax
      logical            bswpiv( 4 ), xswpiv( 4 )
      integer            jpiv( 4 ), locl21( 4 ), locu12( 4 ),
     &                   locu22( 4 )
      double precision   btmp( 4 ), t16( 4, 4 ), tmp( 4 ), x2( 2 )
      integer            idamax
      double precision   dlamch
      end subroutine dlasy2

      !! dla_syamv.f
      subroutine dla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,
     &                      incy )
      double precision   alpha, beta
      integer            incx, incy, lda, n, uplo
      double precision   a( lda, * ), x( * ), y( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            symb_zero
      double precision   temp, safe1
      integer            i, info, iy, j, jx, kx, ky
      double precision   dlamch
      integer            ilauplo
      end subroutine dla_syamv

      !! dlasyf.f
      subroutine dlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      double precision   a( lda, * ), w( ldw, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      integer            imax, j, jb, jj, jmax, jp, k, kk, kkw, kp,
     &                   kstep, kw
      double precision   absakk, alpha, colmax, d11, d21, d22, r1,
     &                   rowmax, t
      logical            lsame
      integer            idamax
      end subroutine dlasyf

      !! dlasyf_rook.f
      subroutine dlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,
     &                        info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      double precision   a( lda, * ), w( ldw, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            done
      integer            imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk,
     &                   kw, kkw, kp, kstep, p, ii
      double precision   absakk, alpha, colmax, d11, d12, d21, d22,
     &                   dtemp, r1, rowmax, t, sfmin
      logical            lsame
      integer            idamax
      double precision   dlamch
      end subroutine dlasyf_rook

      !! dla_syrcond.f
      double precision function dla_syrcond( uplo, n, a, lda, af, ldaf,
     &                                       ipiv, cmode, c, info, work,
     &                                       iwork )
      character          uplo
      integer            n, lda, ldaf, info, cmode
      integer            iwork( * ), ipiv( * )
      double precision   a( lda, * ), af( ldaf, * ), work( * ), c( * )
      character          normin
      integer            kase, i, j
      double precision   ainvnm, smlnum, tmp
      logical            up
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch
      end function dla_syrcond

      !! dla_syrfsx_extended.f
      subroutine dla_syrfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, ipiv, colequ, c, b, ldb,
     &                                y, ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      integer            ipiv( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec, upper
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, y_prec_state, base_residual,
     &                   extra_residual, extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      double precision   dlamch
      end subroutine dla_syrfsx_extended

      !! dla_syrpvgrw.f
      double precision function dla_syrpvgrw( uplo, n, info, a, lda, af,
     &                                        ldaf, ipiv, work )
      character(len=1)   uplo
      integer            n, info, lda, ldaf
      integer            ipiv( * )
      double precision   a( lda, * ), af( ldaf, * ), work( * )
      integer            ncols, i, j, k, kp
      double precision   amax, umax, rpvgrw, tmp
      logical            upper
      logical            lsame
      end function dla_syrpvgrw

      !! dlat2s.f
      subroutine dlat2s( uplo, n, a, lda, sa, ldsa, info )
      character          uplo
      integer            info, lda, ldsa, n
      real               sa( ldsa, * )
      double precision   a( lda, * )
      integer            i, j
      double precision   rmax
      logical            upper
      real               slamch
      logical            lsame
      end subroutine dlat2s

      !! dlatbs.f
      subroutine dlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,
     &                   scale, cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, kd, ldab, n
      double precision   scale
      double precision   ab( ldab, * ), cnorm( * ), x( * )
      double precision   zero, half, one
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast, jlen, maind
      double precision   bignum, grow, rec, smlnum, sumj, tjj, tjjs,
     &                   tmax, tscal, uscal, xbnd, xj, xmax
      logical            lsame
      integer            idamax
      double precision   dasum, ddot, dlamch
      end subroutine dlatbs

      !! dlatdf.f
      subroutine dlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,
     &                   jpiv )
      integer            ijob, ldz, n
      double precision   rdscal, rdsum
      integer            ipiv( * ), jpiv( * )
      double precision   rhs( * ), z( ldz, * )
      integer            maxdim
      parameter          ( maxdim = 8 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i, info, j, k
      double precision   bm, bp, pmone, sminu, splus, temp
      integer            iwork( maxdim )
      double precision   work( 4*maxdim ), xm( maxdim ), xp( maxdim )
      double precision   dasum, ddot
      end subroutine dlatdf

      !! dlatps.f
      subroutine dlatps( uplo, trans, diag, normin, n, ap, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, n
      double precision   scale
      double precision   ap( * ), cnorm( * ), x( * )
      double precision   zero, half, one
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0 )
      logical            notran, nounit, upper
      integer            i, imax, ip, j, jfirst, jinc, jlast, jlen
      double precision   bignum, grow, rec, smlnum, sumj, tjj, tjjs,
     &                   tmax, tscal, uscal, xbnd, xj, xmax
      logical            lsame
      integer            idamax
      double precision   dasum, ddot, dlamch
      end subroutine dlatps

      !! dlatrd.f
      subroutine dlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
      character          uplo
      integer            lda, ldw, n, nb
      double precision   a( lda, * ), e( * ), tau( * ), w( ldw, * )
      double precision   zero, one, half
      parameter          ( zero = 0.0d+0, one = 1.0d+0, half = 0.5d+0 )
      integer            i, iw
      double precision   alpha
      logical            lsame
      double precision   ddot
      end subroutine dlatrd

      !! dlatrs.f
      subroutine dlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, lda, n
      double precision   scale
      double precision   a( lda, * ), cnorm( * ), x( * )
      double precision   zero, half, one
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast
      double precision   bignum, grow, rec, smlnum, sumj, tjj, tjjs,
     &                   tmax, tscal, uscal, xbnd, xj, xmax
      logical            lsame
      integer            idamax
      double precision   dasum, ddot, dlamch
      end subroutine dlatrs

      !! dlatrz.f
      subroutine dlatrz( m, n, l, a, lda, tau, work )
      integer            l, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            i
      end subroutine dlatrz

      !! dlauu2.f
      subroutine dlauu2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      double precision   a( lda, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            i
      double precision   aii
      logical            lsame
      double precision   ddot
      end subroutine dlauu2

      !! dlauum.f
      subroutine dlauum( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      double precision   a( lda, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            i, ib, nb
      logical            lsame
      integer            ilaenv
      end subroutine dlauum

      !! dla_wwaddw.f
      subroutine dla_wwaddw( n, x, y, w )
      integer            n
      double precision   x( * ), y( * ), w( * )
      double precision   s
      integer            i
      end subroutine dla_wwaddw

      !! dopgtr.f
      subroutine dopgtr( uplo, n, ap, tau, q, ldq, work, info )
      character          uplo
      integer            info, ldq, n
      double precision   ap( * ), q( ldq, * ), tau( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            upper
      integer            i, iinfo, ij, j
      logical            lsame
      end subroutine dopgtr

      !! dopmtr.f
      subroutine dopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,
     &                   info )
      character          side, trans, uplo
      integer            info, ldc, m, n
      double precision   ap( * ), c( ldc, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            forwrd, left, notran, upper
      integer            i, i1, i2, i3, ic, ii, jc, mi, ni, nq
      double precision   aii
      logical            lsame
      end subroutine dopmtr

      !! dorbdb1.f
      subroutine dorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      double precision   taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      double precision   dnrm2
      end subroutine dorbdb1

      !! dorbdb2.f
      subroutine dorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      double precision   taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      double precision   negone, one
      parameter          ( negone = -1.0d0, one = 1.0d0 )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      double precision   dnrm2
      end subroutine dorbdb2

      !! dorbdb3.f
      subroutine dorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      double precision   taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      double precision   dnrm2
      end subroutine dorbdb3

      !! dorbdb4.f
      subroutine dorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, phantom, work, lwork,
     &                    info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      double precision   phantom(*), taup1(*), taup2(*), tauq1(*),
     &                   work(*), x11(ldx11,*), x21(ldx21,*)
      double precision   negone, one, zero
      parameter          ( negone = -1.0d0, one = 1.0d0, zero = 0.0d0 )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, j, llarf,
     &                   lorbdb5, lworkmin, lworkopt
      logical            lquery
      double precision   dnrm2
      end subroutine dorbdb4

      !! dorbdb5.f
      subroutine dorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      double precision   q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      double precision   one, zero
      parameter          ( one = 1.0d0, zero = 0.0d0 )
      integer            childinfo, i, j
      double precision   dnrm2
      end subroutine dorbdb5

      !! dorbdb6.f
      subroutine dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      double precision   q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      double precision   alphasq, realone, realzero
      parameter          ( alphasq = 0.01d0, realone = 1.0d0,
     &                     realzero = 0.0d0 )
      double precision   negone, one, zero
      parameter          ( negone = -1.0d0, one = 1.0d0, zero = 0.0d0 )
      integer            i
      double precision   normsq1, normsq2, scl1, scl2, ssq1, ssq2
      end subroutine dorbdb6

      !! dorbdb.f
      subroutine dorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,
     &                   x21, ldx21, x22, ldx22, theta, phi, taup1,
     &                   taup2, tauq1, tauq2, work, lwork, info )
      character          signs, trans
      integer            info, ldx11, ldx12, ldx21, ldx22, lwork, m, p,
     &                   q
      double precision   phi( * ), theta( * )
      double precision   taup1( * ), taup2( * ), tauq1( * ), tauq2( * ),
     &                   work( * ), x11( ldx11, * ), x12( ldx12, * ),
     &                   x21( ldx21, * ), x22( ldx22, * )
      double precision   realone
      parameter          ( realone = 1.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      logical            colmajor, lquery
      integer            i, lworkmin, lworkopt
      double precision   z1, z2, z3, z4
      double precision   dnrm2
      logical            lsame
      end subroutine dorbdb

      !! dorcsd2by1.f
      subroutine dorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,
     &                       x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t,
     &                       ldv1t, work, lwork, iwork, info )
      character          jobu1, jobu2, jobv1t
      integer            info, ldu1, ldu2, ldv1t, lwork, ldx11, ldx21,
     &                   m, p, q
      double precision   theta(*)
      double precision   u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      integer            iwork(*)
      double precision   one, zero
      parameter          ( one = 1.0d0, zero = 0.0d0 )
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   j, lbbcsd, lorbdb, lorglq, lorglqmin,
     &                   lorglqopt, lorgqr, lorgqrmin, lorgqropt,
     &                   lworkmin, lworkopt, r
      logical            lquery, wantu1, wantu2, wantv1t
      logical            lsame
      end subroutine dorcsd2by1

      !! dorcsd.f
      recursive subroutine dorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,
     &                             signs, m, p, q, x11, ldx11, x12,
     &                             ldx12, x21, ldx21, x22, ldx22, theta,
     &                             u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,
     &                             ldv2t, work, lwork, iwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, signs, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12,
     &                   ldx21, ldx22, lwork, m, p, q
      integer            iwork( * )
      double precision   theta( * )
      double precision   u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * ), work( * ), x11( ldx11, * ),
     &                   x12( ldx12, * ), x21( ldx21, * ), x22( ldx22,
     &                   * )
      double precision   one, zero
      parameter          ( one = 1.0d0,
     &                     zero = 0.0d0 )
      character          transt, signst
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   itauq2, j, lbbcsdwork, lbbcsdworkmin,
     &                   lbbcsdworkopt, lorbdbwork, lorbdbworkmin,
     &                   lorbdbworkopt, lorglqwork, lorglqworkmin,
     &                   lorglqworkopt, lorgqrwork, lorgqrworkmin,
     &                   lorgqrworkopt, lworkmin, lworkopt
      logical            colmajor, defaultsigns, lquery, wantu1, wantu2,
     &                   wantv1t, wantv2t
      logical            lsame
      end subroutine dorcsd

      !! dorg2l.f
      subroutine dorg2l( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, ii, j, l
      end subroutine dorg2l

      !! dorg2r.f
      subroutine dorg2r( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, l
      end subroutine dorg2r

      !! dorgbr.f
      subroutine dorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
      character          vect
      integer            info, k, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, wantq
      integer            i, iinfo, j, lwkopt, mn
      logical            lsame
      integer            ilaenv
      end subroutine dorgbr

      !! dorghr.f
      subroutine dorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery
      integer            i, iinfo, j, lwkopt, nb, nh
      integer            ilaenv
      end subroutine dorghr

      !! dorgl2.f
      subroutine dorgl2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, l
      end subroutine dorgl2

      !! dorglq.f
      subroutine dorglq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine dorglq

      !! dorgql.f
      subroutine dorgql( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery
      integer            i, ib, iinfo, iws, j, kk, l, ldwork, lwkopt,
     &                   nb, nbmin, nx
      integer            ilaenv
      end subroutine dorgql

      !! dorgqr.f
      subroutine dorgqr( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine dorgqr

      !! dorgr2.f
      subroutine dorgr2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, ii, j, l
      end subroutine dorgr2

      !! dorgrq.f
      subroutine dorgrq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery
      integer            i, ib, ii, iinfo, iws, j, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine dorgrq

      !! dorgtr.f
      subroutine dorgtr( uplo, n, a, lda, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, upper
      integer            i, iinfo, j, lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine dorgtr

      !! dorm22.f
      subroutine dorm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            m, n, n1, n2, ldq, ldc, lwork, info
      double precision   q( ldq, * ), c( ldc, * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            left, lquery, notran
      integer            i, ldwork, len, lwkopt, nb, nq, nw
      logical            lsame
      end subroutine dorm22

      !! dorm2l.f
      subroutine dorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      double precision   aii
      logical            lsame
      end subroutine dorm2l

      !! dorm2r.f
      subroutine dorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      double precision   aii
      logical            lsame
      end subroutine dorm2r

      !! dormbr.f
      subroutine dormbr( vect, side, trans, m, n, k, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans, vect
      integer            info, k, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            applyq, left, lquery, notran
      character          transt
      integer            i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormbr

      !! dormhr.f
      subroutine dormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans
      integer            ihi, ilo, info, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, lquery
      integer            i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormhr

      !! dorml2.f
      subroutine dorml2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      double precision   aii
      logical            lsame
      end subroutine dorml2

      !! dormlq.f
      subroutine dormlq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormlq

      !! dormql.f
      subroutine dormql( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormql

      !! dormqr.f
      subroutine dormqr( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormqr

      !! dormr2.f
      subroutine dormr2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      double precision   aii
      logical            lsame
      end subroutine dormr2

      !! dormr3.f
      subroutine dormr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, l, lda, ldc, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, notran
      integer            i, i1, i2, i3, ic, ja, jc, mi, ni, nq
      logical            lsame
      end subroutine dormr3

      !! dormrq.f
      subroutine dormrq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormrq

      !! dormrz.f
      subroutine dormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, l, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, ja, jc,
     &                   ldwork, lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormrz

      !! dormtr.f
      subroutine dormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans, uplo
      integer            info, lda, ldc, lwork, m, n
      double precision   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, lquery, upper
      integer            i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine dormtr

      !! dpbcon.f
      subroutine dpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,
     &                   iwork, info )
      character          uplo
      integer            info, kd, ldab, n
      double precision   anorm, rcond
      integer            iwork( * )
      double precision   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      character          normin
      integer            ix, kase
      double precision   ainvnm, scale, scalel, scaleu, smlnum
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch
      end subroutine dpbcon

      !! dpbequ.f
      subroutine dpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
      character          uplo
      integer            info, kd, ldab, n
      double precision   amax, scond
      double precision   ab( ldab, * ), s( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            upper
      integer            i, j
      double precision   smin
      logical            lsame
      end subroutine dpbequ

      !! dpbrfs.f
      subroutine dpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,
     &                   ldb, x, ldx, ferr, berr, work, iwork, info )
      character          uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      integer            iwork( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, j, k, kase, l, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dpbrfs

      !! dpbstf.f
      subroutine dpbstf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      double precision   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            j, kld, km, m
      double precision   ajj
      logical            lsame
      end subroutine dpbstf

      !! dpbsv.f
      subroutine dpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      double precision   ab( ldab, * ), b( ldb, * )
      logical            lsame
      end subroutine dpbsv

      !! dpbsvx.f
      subroutine dpbsvx( fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb,
     &                   equed, s, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, iwork, info )
      character          equed, fact, uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      double precision   rcond
      integer            iwork( * )
      double precision   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), s( * ), work( * ),
     &                   x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            equil, nofact, rcequ, upper
      integer            i, infequ, j, j1, j2
      double precision   amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      double precision   dlamch, dlansb
      end subroutine dpbsvx

      !! dpbtf2.f
      subroutine dpbtf2( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      double precision   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            j, kld, kn
      double precision   ajj
      logical            lsame
      end subroutine dpbtf2

      !! dpbtrf.f
      subroutine dpbtrf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      double precision   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            nbmax, ldwork
      parameter          ( nbmax = 32, ldwork = nbmax+1 )
      integer            i, i2, i3, ib, ii, j, jj, nb
      double precision   work( ldwork, nbmax )
      logical            lsame
      integer            ilaenv
      end subroutine dpbtrf

      !! dpbtrs.f
      subroutine dpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      double precision   ab( ldab, * ), b( ldb, * )
      logical            upper
      integer            j
      logical            lsame
      end subroutine dpbtrs

      !! dpftrf.f
      subroutine dpftrf( transr, uplo, n, a, info )
      character          transr, uplo
      integer            n, info
      double precision   a( 0: * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine dpftrf

      !! dpftri.f
      subroutine dpftri( transr, uplo, n, a, info )
      character          transr, uplo
      integer            info, n
      double precision         a( 0: * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine dpftri

      !! dpftrs.f
      subroutine dpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
      character          transr, uplo
      integer            info, ldb, n, nrhs
      double precision   a( 0: * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lower, normaltransr
      logical            lsame
      end subroutine dpftrs

      !! dpocon.f
      subroutine dpocon( uplo, n, a, lda, anorm, rcond, work, iwork,
     &                   info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      integer            iwork( * )
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      character          normin
      integer            ix, kase
      double precision   ainvnm, scale, scalel, scaleu, smlnum
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch
      end subroutine dpocon

      !! dpoequb.f
      subroutine dpoequb( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      double precision   amax, scond
      double precision   a( lda, * ), s( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i
      double precision   smin, base, tmp
      double precision   dlamch
      end subroutine dpoequb

      !! dpoequ.f
      subroutine dpoequ( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      double precision   amax, scond
      double precision   a( lda, * ), s( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i
      double precision   smin
      end subroutine dpoequ

      !! dporfs.f
      subroutine dporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,
     &                   ldx, ferr, berr, work, iwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dporfs

      !! dporfsx.f
      subroutine dporfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, s, b,
     &                    ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond
      integer            iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, dlansy, dla_porcond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine dporfsx

      !! dposv.f
      subroutine dposv( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      double precision   a( lda, * ), b( ldb, * )
      logical            lsame
      end subroutine dposv

      !! dposvx.f
      subroutine dposvx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                   s, b, ldb, x, ldx, rcond, ferr, berr, work,
     &                   iwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      double precision   rcond
      integer            iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), s( * ), work( * ),
     &                   x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      double precision   amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      double precision   dlamch, dlansy
      end subroutine dposvx

      !! dposvxx.f
      subroutine dposvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                    s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, iwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      integer            iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      double precision   amax, bignum, smin, smax,
     &                   scond, smlnum
      logical            lsame
      double precision   dlamch, dla_porpvgrw
      end subroutine dposvxx

      !! dpotf2.f
      subroutine dpotf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      double precision   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            j
      double precision   ajj
      logical            lsame, disnan
      double precision   ddot
      end subroutine dpotf2

      !! dpotrf2.f
      recursive subroutine dpotrf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      double precision   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            n1, n2, iinfo
      logical            lsame, disnan
      end subroutine dpotrf2

      !! dpotrf.f
      subroutine dpotrf( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      double precision   a( lda, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            j, jb, nb
      logical            lsame
      integer            ilaenv
      end subroutine dpotrf

      !! dpotri.f
      subroutine dpotri( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      double precision   a( lda, * )
      logical            lsame
      end subroutine dpotri

      !! dpotrs.f
      subroutine dpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      double precision   a( lda, * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      logical            lsame
      end subroutine dpotrs

      !! dppcon.f
      subroutine dppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
      character          uplo
      integer            info, n
      double precision   anorm, rcond
      integer            iwork( * )
      double precision   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      character          normin
      integer            ix, kase
      double precision   ainvnm, scale, scalel, scaleu, smlnum
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch
      end subroutine dppcon

      !! dppequ.f
      subroutine dppequ( uplo, n, ap, s, scond, amax, info )
      character          uplo
      integer            info, n
      double precision   amax, scond
      double precision   ap( * ), s( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, jj
      double precision   smin
      logical            lsame
      end subroutine dppequ

      !! dpprfs.f
      subroutine dpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,
     &                   berr, work, iwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            iwork( * )
      double precision   afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dpprfs

      !! dppsv.f
      subroutine dppsv( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      double precision   ap( * ), b( ldb, * )
      logical            lsame
      end subroutine dppsv

      !! dppsvx.f
      subroutine dppsvx( fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb,
     &                   x, ldx, rcond, ferr, berr, work, iwork, info )
      character          equed, fact, uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      integer            iwork( * )
      double precision   afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), s( * ), work( * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      double precision   amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      double precision   dlamch, dlansp
      end subroutine dppsvx

      !! dpptrf.f
      subroutine dpptrf( uplo, n, ap, info )
      character          uplo
      integer            info, n
      double precision   ap( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            j, jc, jj
      double precision   ajj
      logical            lsame
      double precision   ddot
      end subroutine dpptrf

      !! dpptri.f
      subroutine dpptri( uplo, n, ap, info )
      character          uplo
      integer            info, n
      double precision   ap( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            j, jc, jj, jjn
      double precision   ajj
      logical            lsame
      double precision   ddot
      end subroutine dpptri

      !! dpptrs.f
      subroutine dpptrs( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      double precision   ap( * ), b( ldb, * )
      logical            upper
      integer            i
      logical            lsame
      end subroutine dpptrs

      !! dpstf2.f
      subroutine dpstf2( uplo, n, a, lda, piv, rank, tol, work, info )
      double precision   tol
      integer            info, lda, n, rank
      character          uplo
      double precision   a( lda, * ), work( 2*n )
      integer            piv( n )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      double precision   ajj, dstop, dtemp
      integer            i, itemp, j, pvt
      logical            upper
      double precision   dlamch
      logical            lsame, disnan
      end subroutine dpstf2

      !! dpstrf.f
      subroutine dpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
      double precision   tol
      integer            info, lda, n, rank
      character          uplo
      double precision   a( lda, * ), work( 2*n )
      integer            piv( n )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      double precision   ajj, dstop, dtemp
      integer            i, itemp, j, jb, k, nb, pvt
      logical            upper
      double precision   dlamch
      integer            ilaenv
      logical            lsame, disnan
      end subroutine dpstrf

      !! dptcon.f
      subroutine dptcon( n, d, e, anorm, rcond, work, info )
      integer            info, n
      double precision   anorm, rcond
      double precision   d( * ), e( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, ix
      double precision   ainvnm
      integer            idamax
      end subroutine dptcon

      !! dpteqr.f
      subroutine dpteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      double precision   d( * ), e( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lsame
      double precision   c( 1, 1 ), vt( 1, 1 )
      integer            i, icompz, nru
      end subroutine dpteqr

      !! dptrfs.f
      subroutine dptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,
     &                   berr, work, info )
      integer            info, ldb, ldx, n, nrhs
      double precision   b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   e( * ), ef( * ), ferr( * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      integer            count, i, ix, j, nz
      double precision   bi, cx, dx, eps, ex, lstres, s, safe1, safe2,
     &                   safmin
      integer            idamax
      double precision   dlamch
      end subroutine dptrfs

      !! dptsv.f
      subroutine dptsv( n, nrhs, d, e, b, ldb, info )
      integer            info, ldb, n, nrhs
      double precision   b( ldb, * ), d( * ), e( * )
      end subroutine dptsv

      !! dptsvx.f
      subroutine dptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, info )
      character          fact
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      double precision   b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   e( * ), ef( * ), ferr( * ), work( * ),
     &                   x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nofact
      double precision   anorm
      logical            lsame
      double precision   dlamch, dlanst
      end subroutine dptsvx

      !! dpttrf.f
      subroutine dpttrf( n, d, e, info )
      integer            info, n
      double precision   d( * ), e( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            i, i4
      double precision   ei
      end subroutine dpttrf

      !! dpttrs.f
      subroutine dpttrs( n, nrhs, d, e, b, ldb, info )
      integer            info, ldb, n, nrhs
      double precision   b( ldb, * ), d( * ), e( * )
      integer            j, jb, nb
      integer            ilaenv
      end subroutine dpttrs

      !! dptts2.f
      subroutine dptts2( n, nrhs, d, e, b, ldb )
      integer            ldb, n, nrhs
      double precision   b( ldb, * ), d( * ), e( * )
      integer            i, j
      end subroutine dptts2

      !! drscl.f
      subroutine drscl( n, sa, sx, incx )
      integer            incx, n
      double precision   sa
      double precision   sx( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            done
      double precision   bignum, cden, cden1, cnum, cnum1, mul, smlnum
      double precision   dlamch
      end subroutine drscl

      !! dsbevd.f
      subroutine dsbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                   lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, liwork, lwork, n
      integer            iwork( * )
      double precision   ab( ldab, * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lower, lquery, wantz
      integer            iinfo, inde, indwk2, indwrk, iscale, liwmin,
     &                   llwrk2, lwmin
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, dlansb
      end subroutine dsbevd

      !! dsbev.f
      subroutine dsbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                  info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, n
      double precision   ab( ldab, * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lower, wantz
      integer            iinfo, imax, inde, indwrk, iscale
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, dlansb
      end subroutine dsbev

      !! dsbevx.f
      subroutine dsbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,
     &                   vu, il, iu, abstol, m, w, z, ldz, work, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, kd, ldab, ldq, ldz, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   ab( ldab, * ), q( ldq, * ), w( * ), work( * ),
     &                   z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            alleig, indeig, lower, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwo, indwrk, iscale, itmp1, j, jj,
     &                   nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      double precision   dlamch, dlansb
      end subroutine dsbevx

      !! dsbgst.f
      subroutine dsbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,
     &                   ldx, work, info )
      character          uplo, vect
      integer            info, ka, kb, ldab, ldbb, ldx, n
      double precision   ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            update, upper, wantx
      integer            i, i0, i1, i2, inca, j, j1, j1t, j2, j2t, k,
     &                   ka1, kb1, kbt, l, m, nr, nrt, nx
      double precision   bii, ra, ra1, t
      logical            lsame
      end subroutine dsbgst

      !! dsbgvd.f
      subroutine dsbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,
     &                   z, ldz, work, lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, liwork, lwork, n
      integer            iwork( * )
      double precision   ab( ldab, * ), bb( ldbb, * ), w( * ),
     &                   work( * ), z( ldz, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            lquery, upper, wantz
      character          vect
      integer            iinfo, inde, indwk2, indwrk, liwmin, llwrk2,
     &                   lwmin
      logical            lsame
      end subroutine dsbgvd

      !! dsbgv.f
      subroutine dsbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,
     &                  ldz, work, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, n
      double precision   ab( ldab, * ), bb( ldbb, * ), w( * ),
     &                   work( * ), z( ldz, * )
      logical            upper, wantz
      character          vect
      integer            iinfo, inde, indwrk
      logical            lsame
      end subroutine dsbgv

      !! dsbgvx.f
      subroutine dsbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,
     &                   ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z,
     &                   ldz, work, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, ka, kb, ldab, ldbb, ldq, ldz, m,
     &                   n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   ab( ldab, * ), bb( ldbb, * ), q( ldq, * ),
     &                   w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            alleig, indeig, test, upper, valeig, wantz
      character          order, vect
      integer            i, iinfo, indd, inde, indee, indibl, indisp,
     &                   indiwo, indwrk, itmp1, j, jj, nsplit
      double precision   tmp1
      logical            lsame
      end subroutine dsbgvx

      !! dsbtrd.f
      subroutine dsbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,
     &                   work, info )
      character          uplo, vect
      integer            info, kd, ldab, ldq, n
      double precision   ab( ldab, * ), d( * ), e( * ), q( ldq, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            initq, upper, wantq
      integer            i, i2, ibl, inca, incx, iqaend, iqb, iqend, j,
     &                   j1, j1end, j1inc, j2, jend, jin, jinc, k, kd1,
     &                   kdm1, kdn, l, last, lend, nq, nr, nrt
      double precision   temp
      logical            lsame
      end subroutine dsbtrd

      !! dsfrk.f
      subroutine dsfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,
     &                  c )
      double precision   alpha, beta
      integer            k, lda, n
      character          trans, transr, uplo
      double precision   a( lda, * ), c( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            lower, normaltransr, nisodd, notrans
      integer            info, nrowa, j, nk, n1, n2
      logical            lsame
      end subroutine dsfrk

      !! dsgesv.f
      subroutine dsgesv( n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work,
     &                   swork, iter, info )
      integer            info, iter, lda, ldb, ldx, n, nrhs
      integer            ipiv( * )
      real               swork( * )
      double precision   a( lda, * ), b( ldb, * ), work( n, * ),
     &                   x( ldx, * )
      logical            doitref
      parameter          ( doitref = .true. )
      integer            itermax
      parameter          ( itermax = 30 )
      double precision   bwdmax
      parameter          ( bwdmax = 1.0e+00 )
      double precision   negone, one
      parameter          ( negone = -1.0d+0, one = 1.0d+0 )
      integer            i, iiter, ptsa, ptsx
      double precision   anrm, cte, eps, rnrm, xnrm
      integer            idamax
      double precision   dlamch, dlange
      end subroutine dsgesv

      !! dspcon.f
      subroutine dspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,
     &                   info )
      character          uplo
      integer            info, n
      double precision   anorm, rcond
      integer            ipiv( * ), iwork( * )
      double precision   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, ip, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine dspcon

      !! dspevd.f
      subroutine dspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, uplo
      integer            info, ldz, liwork, lwork, n
      integer            iwork( * )
      double precision   ap( * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, wantz
      integer            iinfo, inde, indtau, indwrk, iscale, liwmin,
     &                   llwork, lwmin
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, dlansp
      end subroutine dspevd

      !! dspev.f
      subroutine dspev( jobz, uplo, n, ap, w, z, ldz, work, info )
      character          jobz, uplo
      integer            info, ldz, n
      double precision   ap( * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            wantz
      integer            iinfo, imax, inde, indtau, indwrk, iscale
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, dlansp
      end subroutine dspev

      !! dspevx.f
      subroutine dspevx( jobz, range, uplo, n, ap, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, iwork, ifail,
     &                   info )
      character          jobz, range, uplo
      integer            il, info, iu, ldz, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   ap( * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            alleig, indeig, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwo, indtau, indwrk, iscale, itmp1,
     &                   j, jj, nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      double precision   dlamch, dlansp
      end subroutine dspevx

      !! dspgst.f
      subroutine dspgst( itype, uplo, n, ap, bp, info )
      character          uplo
      integer            info, itype, n
      double precision   ap( * ), bp( * )
      double precision   one, half
      parameter          ( one = 1.0d0, half = 0.5d0 )
      logical            upper
      integer            j, j1, j1j1, jj, k, k1, k1k1, kk
      double precision   ajj, akk, bjj, bkk, ct
      logical            lsame
      double precision   ddot
      end subroutine dspgst

      !! dspgvd.f
      subroutine dspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                   lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, ldz, liwork, lwork, n
      integer            iwork( * )
      double precision   ap( * ), bp( * ), w( * ), work( * ),
     &                   z( ldz, * )
      logical            lquery, upper, wantz
      character          trans
      integer            j, liwmin, lwmin, neig
      logical            lsame
      end subroutine dspgvd

      !! dspgv.f
      subroutine dspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                  info )
      character          jobz, uplo
      integer            info, itype, ldz, n
      double precision   ap( * ), bp( * ), w( * ), work( * ),
     &                   z( ldz, * )
      logical            upper, wantz
      character          trans
      integer            j, neig
      logical            lsame
      end subroutine dspgv

      !! dspgvx.f
      subroutine dspgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,
     &                   il, iu, abstol, m, w, z, ldz, work, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, ldz, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   ap( * ), bp( * ), w( * ), work( * ),
     &                   z( ldz, * )
      logical            alleig, indeig, upper, valeig, wantz
      character          trans
      integer            j
      logical            lsame
      end subroutine dspgvx

      !! dsposv.f
      subroutine dsposv( uplo, n, nrhs, a, lda, b, ldb, x, ldx, work,
     &                   swork, iter, info )
      character          uplo
      integer            info, iter, lda, ldb, ldx, n, nrhs
      real               swork( * )
      double precision   a( lda, * ), b( ldb, * ), work( n, * ),
     &                   x( ldx, * )
      logical            doitref
      parameter          ( doitref = .true. )
      integer            itermax
      parameter          ( itermax = 30 )
      double precision   bwdmax
      parameter          ( bwdmax = 1.0e+00 )
      double precision   negone, one
      parameter          ( negone = -1.0d+0, one = 1.0d+0 )
      integer            i, iiter, ptsa, ptsx
      double precision   anrm, cte, eps, rnrm, xnrm
      integer            idamax
      double precision   dlamch, dlansy
      logical            lsame
      end subroutine dsposv

      !! dsprfs.f
      subroutine dsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,
     &                   ferr, berr, work, iwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      double precision   afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dsprfs

      !! dspsv.f
      subroutine dspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      double precision   ap( * ), b( ldb, * )
      logical            lsame
      end subroutine dspsv

      !! dspsvx.f
      subroutine dspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,
     &                   ldx, rcond, ferr, berr, work, iwork, info )
      character          fact, uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nofact
      double precision   anorm
      logical            lsame
      double precision   dlamch, dlansp
      end subroutine dspsvx

      !! dsptrd.f
      subroutine dsptrd( uplo, n, ap, d, e, tau, info )
      character          uplo
      integer            info, n
      double precision   ap( * ), d( * ), e( * ), tau( * )
      double precision   one, zero, half
      parameter          ( one = 1.0d0, zero = 0.0d0,
     &                   half = 1.0d0 / 2.0d0 )
      logical            upper
      integer            i, i1, i1i1, ii
      double precision   alpha, taui
      logical            lsame
      double precision   ddot
      end subroutine dsptrd

      !! dsptrf.f
      subroutine dsptrf( uplo, n, ap, ipiv, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      double precision   ap( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kc, kk, knc, kp, kpc,
     &                   kstep, kx, npp
      double precision   absakk, alpha, colmax, d11, d12, d21, d22, r1,
     &                   rowmax, t, wk, wkm1, wkp1
      logical            lsame
      integer            idamax
      end subroutine dsptrf

      !! dsptri.f
      subroutine dsptri( uplo, n, ap, ipiv, work, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      double precision   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            j, k, kc, kcnext, kp, kpc, kstep, kx, npp
      double precision   ak, akkp1, akp1, d, t, temp
      logical            lsame
      double precision   ddot
      end subroutine dsptri

      !! dsptrs.f
      subroutine dsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      double precision   ap( * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            j, k, kc, kp
      double precision   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine dsptrs

      !! dstebz.f
      subroutine dstebz( range, order, n, vl, vu, il, iu, abstol, d, e,
     &                   m, nsplit, w, iblock, isplit, work, iwork,
     &                   info )
      character          order, range
      integer            il, info, iu, m, n, nsplit
      double precision   abstol, vl, vu
      integer            iblock( * ), isplit( * ), iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * )
      double precision   zero, one, two, half
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   half = 1.0d0 / two )
      double precision   fudge, relfac
      parameter          ( fudge = 2.1d0, relfac = 2.0d0 )
      logical            ncnvrg, toofew
      integer            ib, ibegin, idiscl, idiscu, ie, iend, iinfo,
     &                   im, in, ioff, iorder, iout, irange, itmax,
     &                   itmp1, iw, iwoff, j, jb, jdisc, je, nb, nwl,
     &                   nwu
      double precision   atoli, bnorm, gl, gu, pivmin, rtoli, safemn,
     &                   tmp1, tmp2, tnorm, ulp, wkill, wl, wlu, wu, wul
      integer            idumma( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch
      end subroutine dstebz

      !! dstedc.f
      subroutine dstedc( compz, n, d, e, z, ldz, work, lwork, iwork,
     &                   liwork, info )
      character          compz
      integer            info, ldz, liwork, lwork, n
      integer            iwork( * )
      double precision   d( * ), e( * ), work( * ), z( ldz, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      logical            lquery
      integer            finish, i, icompz, ii, j, k, lgn, liwmin,
     &                   lwmin, m, smlsiz, start, storez, strtrw
      double precision   eps, orgnrm, p, tiny
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlanst
      end subroutine dstedc

      !! dstegr.f
      subroutine dstegr( jobz, range, n, d, e, vl, vu, il, iu,
     &           abstol, m, w, z, ldz, isuppz, work, lwork, iwork,
     &           liwork, info )
      character          jobz, range
      integer            il, info, iu, ldz, liwork, lwork, m, n
      double precision abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * )
      double precision   z( ldz, * )
      logical tryrac
      end subroutine dstegr

      !! dstein.f
      subroutine dstein( n, d, e, m, w, iblock, isplit, z, ldz, work,
     &                   iwork, ifail, info )
      integer            info, ldz, m, n
      integer            iblock( * ), ifail( * ), isplit( * ),
     &                   iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one, ten, odm3, odm1
      parameter          ( zero = 0.0d+0, one = 1.0d+0, ten = 1.0d+1,
     &                   odm3 = 1.0d-3, odm1 = 1.0d-1 )
      integer            maxits, extra
      parameter          ( maxits = 5, extra = 2 )
      integer            b1, blksiz, bn, gpind, i, iinfo, indrv1,
     &                   indrv2, indrv3, indrv4, indrv5, its, j, j1,
     &                   jblk, jmax, nblk, nrmchk
      double precision   dtpcrt, eps, eps1, nrm, onenrm, ortol, pertol,
     &                   scl, sep, tol, xj, xjm, ztr
      integer            iseed( 4 )
      integer            idamax
      double precision   dasum, ddot, dlamch, dnrm2
      end subroutine dstein

      !! dstemr.f
      subroutine dstemr( jobz, range, n, d, e, vl, vu, il, iu,
     &                   m, w, z, ldz, nzc, isuppz, tryrac, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, range
      logical            tryrac
      integer            il, info, iu, ldz, nzc, liwork, lwork, m, n
      double precision vl, vu
      integer            isuppz( * ), iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * )
      double precision   z( ldz, * )
      double precision   zero, one, four, minrgp
      parameter          ( zero = 0.0d0, one = 1.0d0,
     &                     four = 4.0d0,
     &                     minrgp = 1.0d-3 )
      logical            alleig, indeig, lquery, valeig, wantz, zquery
      integer            i, ibegin, iend, ifirst, iil, iindbl, iindw,
     &                   iindwk, iinfo, iinspl, iiu, ilast, in, indd,
     &                   inde2, inderr, indgp, indgrs, indwrk, itmp,
     &                   itmp2, j, jblk, jj, liwmin, lwmin, nsplit,
     &                   nzcmin, offset, wbegin, wend
      double precision   bignum, cs, eps, pivmin, r1, r2, rmax, rmin,
     &                   rtol1, rtol2, safmin, scale, smlnum, sn,
     &                   thresh, tmp, tnrm, wl, wu
      logical            lsame
      double precision   dlamch, dlanst
      end subroutine dstemr

      !! dsteqr.f
      subroutine dsteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      double precision   d( * ), e( * ), work( * ), z( ldz, * )
      double precision   zero, one, two, three
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   three = 3.0d0 )
      integer            maxit
      parameter          ( maxit = 30 )
      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
     &                   nm1, nmaxit
      double precision   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
     &                   s, safmax, safmin, ssfmax, ssfmin, tst
      logical            lsame
      double precision   dlamch, dlanst, dlapy2
      end subroutine dsteqr

      !! dsterf.f
      subroutine dsterf( n, d, e, info )
      integer            info, n
      double precision   d( * ), e( * )
      double precision   zero, one, two, three
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   three = 3.0d0 )
      integer            maxit
      parameter          ( maxit = 30 )
      integer            i, iscale, jtot, l, l1, lend, lendsv, lsv, m,
     &                   nmaxit
      double precision   alpha, anorm, bb, c, eps, eps2, gamma, oldc,
     &                   oldgam, p, r, rt1, rt2, rte, s, safmax, safmin,
     &                   sigma, ssfmax, ssfmin, rmax
      double precision   dlamch, dlanst, dlapy2
      end subroutine dsterf

      !! dstevd.f
      subroutine dstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,
     &                   liwork, info )
      character          jobz
      integer            info, ldz, liwork, lwork, n
      integer            iwork( * )
      double precision   d( * ), e( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, wantz
      integer            iscale, liwmin, lwmin
      double precision   bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tnrm
      logical            lsame
      double precision   dlamch, dlanst
      end subroutine dstevd

      !! dstev.f
      subroutine dstev( jobz, n, d, e, z, ldz, work, info )
      character          jobz
      integer            info, ldz, n
      double precision   d( * ), e( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            wantz
      integer            imax, iscale
      double precision   bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tnrm
      logical            lsame
      double precision   dlamch, dlanst
      end subroutine dstev

      !! dstevr.f
      subroutine dstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,
     &                   m, w, z, ldz, isuppz, work, lwork, iwork,
     &                   liwork, info )
      character          jobz, range
      integer            il, info, iu, ldz, liwork, lwork, m, n
      double precision   abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      logical            alleig, indeig, test, lquery, valeig, wantz,
     &                   tryrac
      character          order
      integer            i, ieeeok, imax, indibl, indifl, indisp,
     &                   indiwo, iscale, itmp1, j, jj, liwmin, lwmin,
     &                   nsplit
      double precision   bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tmp1, tnrm, vll, vuu
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlanst
      end subroutine dstevr

      !! dstevx.f
      subroutine dstevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,
     &                   m, w, z, ldz, work, iwork, ifail, info )
      character          jobz, range
      integer            il, info, iu, ldz, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            alleig, indeig, test, valeig, wantz
      character          order
      integer            i, imax, indibl, indisp, indiwo, indwrk,
     &                   iscale, itmp1, j, jj, nsplit
      double precision   bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tmp1, tnrm, vll, vuu
      logical            lsame
      double precision   dlamch, dlanst
      end subroutine dstevx

      !! dsycon.f
      subroutine dsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   iwork, info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine dsycon

      !! dsycon_rook.f
      subroutine dsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   iwork, info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine dsycon_rook

      !! dsyconv.f
      subroutine dsyconv( uplo, way, n, a, lda, ipiv, e, info )
      character          uplo, way
      integer            info, lda, n
      integer            ipiv( * )
      double precision   a( lda, * ), e( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lsame
      logical            upper, convert
      integer            i, ip, j
      double precision   temp
      end subroutine dsyconv

      !! dsyequb.f
      subroutine dsyequb( uplo, n, a, lda, s, scond, amax, work, info )
      integer            info, lda, n
      double precision   amax, scond
      character          uplo
      double precision   a( lda, * ), s( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            max_iter
      parameter          ( max_iter = 100 )
      integer            i, j, iter
      double precision   avg, std, tol, c0, c1, c2, t, u, si, d, base,
     &                   smin, smax, smlnum, bignum, scale, sumsq
      logical            up
      double precision   dlamch
      logical            lsame
      end subroutine dsyequb

      !! dsyevd.f
      subroutine dsyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,
     &                   liwork, info )
      character          jobz, uplo
      integer            info, lda, liwork, lwork, n
      integer            iwork( * )
      double precision   a( lda, * ), w( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lower, lquery, wantz
      integer            iinfo, inde, indtau, indwk2, indwrk, iscale,
     &                   liopt, liwmin, llwork, llwrk2, lopt, lwmin
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlansy
      end subroutine dsyevd

      !! dsyev.f
      subroutine dsyev( jobz, uplo, n, a, lda, w, work, lwork, info )
      character          jobz, uplo
      integer            info, lda, lwork, n
      double precision   a( lda, * ), w( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indtau, indwrk, iscale,
     &                   llwork, lwkopt, nb
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlansy
      end subroutine dsyev

      !! dsyevr.f
      subroutine dsyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, isuppz, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, liwork, lwork, m, n
      double precision   abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      double precision   a( lda, * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      logical            alleig, indeig, lower, lquery, valeig, wantz,
     &                   tryrac
      character          order
      integer            i, ieeeok, iinfo, imax, indd, inddd, inde,
     &                   indee, indibl, indifl, indisp, indiwo, indtau,
     &                   indwk, indwkn, iscale, j, jj, liwmin,
     &                   llwork, llwrkn, lwkopt, lwmin, nb, nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlansy
      end subroutine dsyevr

      !! dsyevx.f
      subroutine dsyevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, lwork, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, lwork, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   a( lda, * ), w( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            alleig, indeig, lower, lquery, test, valeig,
     &                   wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwo, indtau, indwkn, indwrk, iscale,
     &                   itmp1, j, jj, llwork, llwrkn, lwkmin,
     &                   lwkopt, nb, nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlansy
      end subroutine dsyevx

      !! dsygs2.f
      subroutine dsygs2( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      double precision   a( lda, * ), b( ldb, * )
      double precision   one, half
      parameter          ( one = 1.0d0, half = 0.5d0 )
      logical            upper
      integer            k
      double precision   akk, bkk, ct
      logical            lsame
      end subroutine dsygs2

      !! dsygst.f
      subroutine dsygst( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      double precision   a( lda, * ), b( ldb, * )
      double precision   one, half
      parameter          ( one = 1.0d0, half = 0.5d0 )
      logical            upper
      integer            k, kb, nb
      logical            lsame
      integer            ilaenv
      end subroutine dsygst

      !! dsygvd.f
      subroutine dsygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                   lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, liwork, lwork, n
      integer            iwork( * )
      double precision   a( lda, * ), b( ldb, * ), w( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lquery, upper, wantz
      character          trans
      integer            liopt, liwmin, lopt, lwmin
      logical            lsame
      end subroutine dsygvd

      !! dsygv.f
      subroutine dsygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                  lwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, lwork, n
      double precision   a( lda, * ), b( ldb, * ), w( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lquery, upper, wantz
      character          trans
      integer            lwkmin, lwkopt, nb, neig
      logical            lsame
      integer            ilaenv
      end subroutine dsygv

      !! dsygvx.f
      subroutine dsygvx( itype, jobz, range, uplo, n, a, lda, b, ldb,
     &                   vl, vu, il, iu, abstol, m, w, z, ldz, work,
     &                   lwork, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, lda, ldb, ldz, lwork, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   a( lda, * ), b( ldb, * ), w( * ), work( * ),
     &                   z( ldz, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            alleig, indeig, lquery, upper, valeig, wantz
      character          trans
      integer            lwkmin, lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine dsygvx

      !! dsyrfs.f
      subroutine dsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, iwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dsyrfs

      !! dsyrfsx.f
      subroutine dsyrfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    s, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type, n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, dlansy, dla_syrcond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine dsyrfsx

      !! dsysv.f
      subroutine dsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      double precision   a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine dsysv

      !! dsysv_rook.f
      subroutine dsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      double precision   a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine dsysv_rook

      !! dsysvx.f
      subroutine dsysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,
     &                   ldb, x, ldx, rcond, ferr, berr, work, lwork,
     &                   iwork, info )
      character          fact, uplo
      integer            info, lda, ldaf, ldb, ldx, lwork, n, nrhs
      double precision   rcond
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery, nofact
      integer            lwkopt, nb
      double precision   anorm
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlansy
      end subroutine dsysvx

      !! dsysvxx.f
      subroutine dsysvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, iwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      integer            ipiv( * ), iwork( * )
      double precision   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      double precision   amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      double precision   dlamch, dla_syrpvgrw
      end subroutine dsysvxx

      !! dsyswapr.f
      subroutine dsyswapr( uplo, n, a, lda, i1, i2)
      character        uplo
      integer          i1, i2, lda, n
      double precision a( lda, n )
      logical            upper
      integer            i
      double precision   tmp
      logical            lsame
      end subroutine dsyswapr

      !! dsytd2.f
      subroutine dsytd2( uplo, n, a, lda, d, e, tau, info )
      character          uplo
      integer            info, lda, n
      double precision   a( lda, * ), d( * ), e( * ), tau( * )
      double precision   one, zero, half
      parameter          ( one = 1.0d0, zero = 0.0d0,
     &                   half = 1.0d0 / 2.0d0 )
      logical            upper
      integer            i
      double precision   alpha, taui
      logical            lsame
      double precision   ddot
      end subroutine dsytd2

      !! dsytf2.f
      subroutine dsytf2( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      double precision   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kk, kp, kstep
      double precision   absakk, alpha, colmax, d11, d12, d21, d22, r1,
     &                   rowmax, t, wk, wkm1, wkp1
      logical            lsame, disnan
      integer            idamax
      end subroutine dsytf2

      !! dsytf2_rook.f
      subroutine dsytf2_rook( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      double precision   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            upper, done
      integer            i, imax, j, jmax, itemp, k, kk, kp, kstep,
     &                   p, ii
      double precision   absakk, alpha, colmax, d11, d12, d21, d22,
     &                   rowmax, dtemp, t, wk, wkm1, wkp1, sfmin
      logical            lsame
      integer            idamax
      double precision   dlamch
      end subroutine dsytf2_rook

      !! dsytrd.f
      subroutine dsytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      double precision   a( lda, * ), d( * ), e( * ), tau( * ),
     &                   work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lquery, upper
      integer            i, iinfo, iws, j, kk, ldwork, lwkopt, nb,
     &                   nbmin, nx
      logical            lsame
      integer            ilaenv
      end subroutine dsytrd

      !! dsytrf.f
      subroutine dsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      double precision   a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine dsytrf

      !! dsytrf_rook.f
      subroutine dsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      double precision   a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine dsytrf_rook

      !! dsytri2.f
      subroutine dsytri2( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      double precision   a( lda, * ), work( * )
      logical            upper, lquery
      integer            minsize, nbmax
      logical            lsame
      integer            ilaenv
      end subroutine dsytri2

      !! dsytri2x.f
      subroutine dsytri2x( uplo, n, a, lda, ipiv, work, nb, info )
      character          uplo
      integer            info, lda, n, nb
      integer            ipiv( * )
      double precision   a( lda, * ), work( n+nb+1,* )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, iinfo, ip, k, cut, nnb
      integer            count
      integer            j, u11, invd
      double precision   ak, akkp1, akp1, d, t
      double precision   u01_i_j, u01_ip1_j
      double precision   u11_i_j, u11_ip1_j
      logical            lsame
      end subroutine dsytri2x

      !! dsytri.f
      subroutine dsytri( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            k, kp, kstep
      double precision   ak, akkp1, akp1, d, t, temp
      logical            lsame
      double precision   ddot
      end subroutine dsytri

      !! dsytri_rook.f
      subroutine dsytri_rook( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            k, kp, kstep
      double precision   ak, akkp1, akp1, d, t, temp
      logical            lsame
      double precision   ddot
      end subroutine dsytri_rook

      !! dsytrs2.f
      subroutine dsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                    work, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      double precision   a( lda, * ), b( ldb, * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            i, iinfo, j, k, kp
      double precision   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine dsytrs2

      !! dsytrs.f
      subroutine dsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      double precision   a( lda, * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            j, k, kp
      double precision   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine dsytrs

      !! dsytrs_rook.f
      subroutine dsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                        info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      double precision   a( lda, * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            j, k, kp
      double precision   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine dsytrs_rook

      !! dtbcon.f
      subroutine dtbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,
     &                   iwork, info )
      character          diag, norm, uplo
      integer            info, kd, ldab, n
      double precision   rcond
      integer            iwork( * )
      double precision   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, anorm, scale, smlnum, xnorm
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch, dlantb
      end subroutine dtbcon

      !! dtbrfs.f
      subroutine dtbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, x, ldx, ferr, berr, work, iwork, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, ldx, n, nrhs
      integer            iwork( * )
      double precision   ab( ldab, * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            notran, nounit, upper
      character          transt
      integer            i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dtbrfs

      !! dtbtrs.f
      subroutine dtbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, n, nrhs
      double precision   ab( ldab, * ), b( ldb, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nounit, upper
      integer            j
      logical            lsame
      end subroutine dtbtrs

      !! dtfsm.f
      subroutine dtfsm( transr, side, uplo, trans, diag, m, n, alpha, a,
     &                  b, ldb )
      character          transr, diag, side, trans, uplo
      integer            ldb, m, n
      double precision   alpha
      double precision   a( 0: * ), b( 0: ldb-1, 0: * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            lower, lside, misodd, nisodd, normaltransr,
     &                   notrans
      integer            m1, m2, n1, n2, k, info, i, j
      logical            lsame
      end subroutine dtfsm

      !! dtftri.f
      subroutine dtftri( transr, uplo, diag, n, a, info )
      character          transr, uplo, diag
      integer            info, n
      double precision   a( 0: * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine dtftri

      !! dtfttp.f
      subroutine dtfttp( transr, uplo, n, arf, ap, info )
      character          transr, uplo
      integer            info, n
      double precision   ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine dtfttp

      !! dtfttr.f
      subroutine dtfttr( transr, uplo, n, arf, a, lda, info )
      character          transr, uplo
      integer            info, n, lda
      double precision   a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt, nx2, np1x2
      integer            i, j, l, ij
      logical            lsame
      end subroutine dtfttr

      !! dtgevc.f
      subroutine dtgevc( side, howmny, select, n, s, lds, p, ldp, vl,
     &                   ldvl, vr, ldvr, mm, m, work, info )
      character          howmny, side
      integer            info, ldp, lds, ldvl, ldvr, m, mm, n
      logical            select( * )
      double precision   p( ldp, * ), s( lds, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      double precision   zero, one, safety
      parameter          ( zero = 0.0d+0, one = 1.0d+0,
     &                   safety = 1.0d+2 )
      logical            compl, compr, il2by2, ilabad, ilall, ilback,
     &                   ilbbad, ilcomp, ilcplx, lsa, lsb
      integer            i, ibeg, ieig, iend, ihwmny, iinfo, im, iside,
     &                   j, ja, jc, je, jr, jw, na, nw
      double precision   acoef, acoefa, anorm, ascale, bcoefa, bcoefi,
     &                   bcoefr, big, bignum, bnorm, bscale, cim2a,
     &                   cim2b, cimaga, cimagb, cre2a, cre2b, creala,
     &                   crealb, dmin, safmin, salfar, sbeta, scale,
     &                   small, temp, temp2, temp2i, temp2r, ulp, xmax,
     &                   xscale
      double precision   bdiag( 2 ), sum( 2, 2 ), sums( 2, 2 ),
     &                   sump( 2, 2 )
      logical            lsame
      double precision   dlamch
      end subroutine dtgevc

      !! dtgex2.f
      subroutine dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, j1, n1, n2, work, lwork, info )
      logical            wantq, wantz
      integer            info, j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
      double precision   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   twenty
      parameter          ( twenty = 2.0d+01 )
      integer            ldst
      parameter          ( ldst = 4 )
      logical            wands
      parameter          ( wands = .true. )
      logical            dtrong, weak
      integer            i, idum, linfo, m
      double precision   bqra21, brqa21, ddum, dnorm, dscale, dsum, eps,
     &                   f, g, sa, sb, scale, smlnum, ss, thresh, ws
      integer            iwork( ldst )
      double precision   ai( 2 ), ar( 2 ), be( 2 ), ir( ldst, ldst ),
     &                   ircop( ldst, ldst ), li( ldst, ldst ),
     &                   licop( ldst, ldst ), s( ldst, ldst ),
     &                   scpy( ldst, ldst ), t( ldst, ldst ),
     &                   taul( ldst ), taur( ldst ), tcpy( ldst, ldst )
      double precision   dlamch
      end subroutine dtgex2

      !! dtgexc.f
      subroutine dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, ifst, ilst, work, lwork, info )
      logical            wantq, wantz
      integer            ifst, ilst, info, lda, ldb, ldq, ldz, lwork, n
      double precision   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery
      integer            here, lwmin, nbf, nbl, nbnext
      end subroutine dtgexc

      !! dtgsen.f
      subroutine dtgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,
     &                   alphar, alphai, beta, q, ldq, z, ldz, m, pl,
     &                   pr, dif, work, lwork, iwork, liwork, info )
      logical            wantq, wantz
      integer            ijob, info, lda, ldb, ldq, ldz, liwork, lwork,
     &                   m, n
      double precision   pl, pr
      logical            select( * )
      integer            iwork( * )
      double precision   a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), dif( * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      integer            idifjb
      parameter          ( idifjb = 3 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, pair, swap, wantd, wantd1, wantd2,
     &                   wantp
      integer            i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin,
     &                   mn2, n1, n2
      double precision   dscale, dsum, eps, rdscal, smlnum
      integer            isave( 3 )
      double precision   dlamch
      end subroutine dtgsen

      !! dtgsja.f
      subroutine dtgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,
     &                   ldb, tola, tolb, alpha, beta, u, ldu, v, ldv,
     &                   q, ldq, work, ncycle, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n,
     &                   ncycle, p
      double precision   tola, tolb
      double precision   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), q( ldq, * ), u( ldu, * ),
     &                   v( ldv, * ), work( * )
      integer            maxit
      parameter          ( maxit = 40 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            initq, initu, initv, upper, wantq, wantu, wantv
      integer            i, j, kcycle
      double precision   a1, a2, a3, b1, b2, b3, csq, csu, csv, error,
     &                   gamma, rwk, snq, snu, snv, ssmin
      logical            lsame
      end subroutine dtgsja

      !! dtgsna.f
      subroutine dtgsna( job, howmny, select, n, a, lda, b, ldb, vl,
     &                   ldvl, vr, ldvr, s, dif, mm, m, work, lwork,
     &                   iwork, info )
      character          howmny, job
      integer            info, lda, ldb, ldvl, ldvr, lwork, m, mm, n
      logical            select( * )
      integer            iwork( * )
      double precision   a( lda, * ), b( ldb, * ), dif( * ), s( * ),
     &                   vl( ldvl, * ), vr( ldvr, * ), work( * )
      integer            difdri
      parameter          ( difdri = 3 )
      double precision   zero, one, two, four
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0,
     &                   four = 4.0d+0 )
      logical            lquery, pair, somcon, wantbh, wantdf, wants
      integer            i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
      double precision   alphai, alphar, alprqt, beta, c1, c2, cond,
     &                   eps, lnrm, rnrm, root1, root2, scale, smlnum,
     &                   tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv,
     &                   uhbvi
      double precision   dummy( 1 ), dummy1( 1 )
      logical            lsame
      double precision   ddot, dlamch, dlapy2, dnrm2
      end subroutine dtgsna

      !! dtgsy2.f
      subroutine dtgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, rdsum, rdscal,
     &                   iwork, pq, info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf, m, n,
     &                   pq
      double precision   rdscal, rdsum, scale
      integer            iwork( * )
      double precision   a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * )
      integer            ldz
      parameter          ( ldz = 8 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            notran
      integer            i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1,
     &                   k, mb, nb, p, q, zdim
      double precision   alpha, scaloc
      integer            ipiv( ldz ), jpiv( ldz )
      double precision   rhs( ldz ), z( ldz, ldz )
      logical            lsame
      end subroutine dtgsy2

      !! dtgsyl.f
      subroutine dtgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, dif, work, lwork,
     &                   iwork, info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf,
     &                   lwork, m, n
      double precision   dif, scale
      integer            iwork( * )
      double precision   a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, notran
      integer            i, ie, ifunc, iround, is, isolve, j, je, js, k,
     &                   linfo, lwmin, mb, nb, p, ppqq, pq, q
      double precision   dscale, dsum, scale2, scaloc
      logical            lsame
      integer            ilaenv
      end subroutine dtgsyl

      !! dtpcon.f
      subroutine dtpcon( norm, uplo, diag, n, ap, rcond, work, iwork,
     &                   info )
      character          diag, norm, uplo
      integer            info, n
      double precision   rcond
      integer            iwork( * )
      double precision   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, anorm, scale, smlnum, xnorm
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch, dlantp
      end subroutine dtpcon

      !! dtpmqrt.f
      subroutine dtpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,
     &                    a, lda, b, ldb, work, info )
      character side, trans
      integer   info, k, ldv, lda, ldb, m, n, l, nb, ldt
      double precision   v( ldv, * ), a( lda, * ), b( ldb, * ),
     &                   t( ldt, * ), work( * )
      logical            left, right, tran, notran
      integer            i, ib, mb, lb, kf, ldaq, ldvq
      logical            lsame
      end subroutine dtpmqrt

      !! dtpqrt2.f
      subroutine dtpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
      integer   info, lda, ldb, ldt, n, m, l
      double precision   a( lda, * ), b( ldb, * ), t( ldt, * )
      double precision  one, zero
      parameter( one = 1.0, zero = 0.0 )
      integer   i, j, p, mp, np
      double precision   alpha
      end subroutine dtpqrt2

      !! dtpqrt.f
      subroutine dtpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,
     &                   info )
      integer info, lda, ldb, ldt, n, m, l, nb
      double precision a( lda, * ), b( ldb, * ), t( ldt, * ), work( * )
      integer    i, ib, lb, mb, iinfo
      end subroutine dtpqrt

      !! dtprfb.f
      subroutine dtprfb( side, trans, direct, storev, m, n, k, l,
     &                   v, ldv, t, ldt, a, lda, b, ldb, work, ldwork )
      character direct, side, storev, trans
      integer   k, l, lda, ldb, ldt, ldv, ldwork, m, n
      double precision   a( lda, * ), b( ldb, * ), t( ldt, * ),
     &          v( ldv, * ), work( ldwork, * )
      double precision   one, zero
      parameter ( one = 1.0, zero = 0.0 )
      integer   i, j, mp, np, kp
      logical   left, forward, column, right, backward, row
      logical   lsame
      end subroutine dtprfb

      !! dtprfs.f
      subroutine dtprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,
     &                   ferr, berr, work, iwork, info )
      character          diag, trans, uplo
      integer            info, ldb, ldx, n, nrhs
      integer            iwork( * )
      double precision   ap( * ), b( ldb, * ), berr( * ), ferr( * ),
     &                   work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            notran, nounit, upper
      character          transt
      integer            i, j, k, kase, kc, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dtprfs

      !! dtptri.f
      subroutine dtptri( uplo, diag, n, ap, info )
      character          diag, uplo
      integer            info, n
      double precision   ap( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, upper
      integer            j, jc, jclast, jj
      double precision   ajj
      logical            lsame
      end subroutine dtptri

      !! dtptrs.f
      subroutine dtptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
      character          diag, trans, uplo
      integer            info, ldb, n, nrhs
      double precision   ap( * ), b( ldb, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nounit, upper
      integer            j, jc
      logical            lsame
      end subroutine dtptrs

      !! dtpttf.f
      subroutine dtpttf( transr, uplo, n, ap, arf, info )
      character          transr, uplo
      integer            info, n
      double precision   ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine dtpttf

      !! dtpttr.f
      subroutine dtpttr( uplo, n, ap, a, lda, info )
      character          uplo
      integer            info, n, lda
      double precision   a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine dtpttr

      !! dtrcon.f
      subroutine dtrcon( norm, uplo, diag, n, a, lda, rcond, work,
     &                   iwork, info )
      character          diag, norm, uplo
      integer            info, lda, n
      double precision   rcond
      integer            iwork( * )
      double precision   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, anorm, scale, smlnum, xnorm
      integer            isave( 3 )
      logical            lsame
      integer            idamax
      double precision   dlamch, dlantr
      end subroutine dtrcon

      !! dtrevc.f
      subroutine dtrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, mm, m, work, info )
      character          howmny, side
      integer            info, ldt, ldvl, ldvr, m, mm, n
      logical            select( * )
      double precision   t( ldt, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            allv, bothv, leftv, over, pair, rightv, somev
      integer            i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
      double precision   beta, bignum, emax, ovfl, rec, remax, scale,
     &                   smin, smlnum, ulp, unfl, vcrit, vmax, wi, wr,
     &                   xnorm
      logical            lsame
      integer            idamax
      double precision   ddot, dlamch
      double precision   x( 2, 2 )
      end subroutine dtrevc

      !! dtrexc.f
      subroutine dtrexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,
     &                   info )
      character          compq
      integer            ifst, ilst, info, ldq, ldt, n
      double precision   q( ldq, * ), t( ldt, * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            wantq
      integer            here, nbf, nbl, nbnext
      logical            lsame
      end subroutine dtrexc

      !! dtrrfs.f
      subroutine dtrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,
     &                   ldx, ferr, berr, work, iwork, info )
      character          diag, trans, uplo
      integer            info, lda, ldb, ldx, n, nrhs
      integer            iwork( * )
      double precision   a( lda, * ), b( ldb, * ), berr( * ), ferr( * ),
     &                   work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            notran, nounit, upper
      character          transt
      integer            i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      end subroutine dtrrfs

      !! dtrsen.f
      subroutine dtrsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,
     &                   m, s, sep, work, lwork, iwork, liwork, info )
      character          compq, job
      integer            info, ldq, ldt, liwork, lwork, m, n
      double precision   s, sep
      logical            select( * )
      integer            iwork( * )
      double precision   q( ldq, * ), t( ldt, * ), wi( * ), work( * ),
     &                   wr( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, pair, swap, wantbh, wantq, wants,
     &                   wantsp
      integer            ierr, k, kase, kk, ks, liwmin, lwmin, n1, n2,
     &                   nn
      double precision   est, rnorm, scale
      integer            isave( 3 )
      logical            lsame
      double precision   dlange
      end subroutine dtrsen

      !! dtrsna.f
      subroutine dtrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, s, sep, mm, m, work, ldwork, iwork,
     &                   info )
      character          howmny, job
      integer            info, ldt, ldvl, ldvr, ldwork, m, mm, n
      logical            select( * )
      integer            iwork( * )
      double precision   s( * ), sep( * ), t( ldt, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( ldwork, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      logical            pair, somcon, wantbh, wants, wantsp
      integer            i, ierr, ifst, ilst, j, k, kase, ks, n2, nn
      double precision   bignum, cond, cs, delta, dumm, eps, est, lnrm,
     &                   mu, prod, prod1, prod2, rnrm, scale, smlnum, sn
      integer            isave( 3 )
      double precision   dummy( 1 )
      logical            lsame
      double precision   ddot, dlamch, dlapy2, dnrm2
      end subroutine dtrsna

      !! dtrsyl.f
      subroutine dtrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,
     &                   ldc, scale, info )
      character          trana, tranb
      integer            info, isgn, lda, ldb, ldc, m, n
      double precision   scale
      double precision   a( lda, * ), b( ldb, * ), c( ldc, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            notrna, notrnb
      integer            ierr, j, k, k1, k2, knext, l, l1, l2, lnext
      double precision   a11, bignum, da11, db, eps, scaloc, sgn, smin,
     &                   smlnum, suml, sumr, xnorm
      double precision   dum( 1 ), vec( 2, 2 ), x( 2, 2 )
      logical            lsame
      double precision   ddot, dlamch, dlange
      end subroutine dtrsyl

      !! dtrti2.f
      subroutine dtrti2( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      double precision   a( lda, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            nounit, upper
      integer            j
      double precision   ajj
      logical            lsame
      end subroutine dtrti2

      !! dtrtri.f
      subroutine dtrtri( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      double precision   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, upper
      integer            j, jb, nb, nn
      logical            lsame
      integer            ilaenv
      end subroutine dtrtri

      !! dtrtrs.f
      subroutine dtrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,
     &                   info )
      character          diag, trans, uplo
      integer            info, lda, ldb, n, nrhs
      double precision   a( lda, * ), b( ldb, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            nounit
      logical            lsame
      end subroutine dtrtrs

      !! dtrttf.f
      subroutine dtrttf( transr, uplo, n, a, lda, arf, info )
      character          transr, uplo
      integer            info, n, lda
      double precision   a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            i, ij, j, k, l, n1, n2, nt, nx2, np1x2
      logical            lsame
      end subroutine dtrttf

      !! dtrttp.f
      subroutine dtrttp( uplo, n, a, lda, ap, info )
      character          uplo
      integer            info, n, lda
      double precision   a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine dtrttp

      !! dtzrzf.f
      subroutine dtzrzf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      double precision   a( lda, * ), tau( * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery
      integer            i, ib, iws, ki, kk, ldwork, lwkmin, lwkopt,
     &                   m1, mu, nb, nbmin, nx
      integer            ilaenv
      end subroutine dtzrzf

      !! dzsum1.f
      double precision function dzsum1( n, cx, incx )
      integer            incx, n
      complex(kind=16)   cx( * )
      integer            i, nincx
      double precision   stemp
      end function dzsum1

      !! icmax1.f
      integer function icmax1( n, cx, incx )
      integer            incx, n
      complex            cx(*)
      real               smax
      integer            i, ix
      end function icmax1

      !! ieeeck.f
      integer          function ieeeck( ispec, zero, one )
      integer            ispec
      real               one, zero
      real               nan1, nan2, nan3, nan4, nan5, nan6, neginf,
     &                   negzro, newzro, posinf
      end function ieeeck

      !! ilaclc.f
      integer function ilaclc( m, n, a, lda )
      integer            m, n, lda
      complex            a( lda, * )
      complex          zero
      parameter ( zero = (0.0e+0, 0.0e+0) )
      integer i
      end function ilaclc

      !! ilaclr.f
      integer function ilaclr( m, n, a, lda )
      integer            m, n, lda
      complex            a( lda, * )
      complex          zero
      parameter ( zero = (0.0e+0, 0.0e+0) )
      integer i, j
      end function ilaclr

      !! iladiag.f
      integer function iladiag( diag )
      character          diag
      integer blas_non_unit_diag, blas_unit_diag
      parameter ( blas_non_unit_diag = 131, blas_unit_diag = 132 )
      logical            lsame
      end function iladiag

      !! iladlc.f
      integer function iladlc( m, n, a, lda )
      integer            m, n, lda
      double precision   a( lda, * )
      double precision zero
      parameter ( zero = 0.0d+0 )
      integer i
      end function iladlc

      !! iladlr.f
      integer function iladlr( m, n, a, lda )
      integer            m, n, lda
      double precision   a( lda, * )
      double precision zero
      parameter ( zero = 0.0d+0 )
      integer i, j
      end function iladlr

      !! ilaenv.f
      integer function ilaenv( ispec, name, opts, n1, n2, n3, n4 )
      character*( * )    name, opts
      integer            ispec, n1, n2, n3, n4
      integer            i, ic, iz, nb, nbmin, nx
      logical            cname, sname
      character          c1*1, c2*2, c4*2, c3*3, subnam*6
      integer            ieeeck, iparmq
      end function ilaenv

      !! ilaprec.f
      integer function ilaprec( prec )
      character          prec
      integer blas_prec_single, blas_prec_double, blas_prec_indigenous,
     &           blas_prec_extra
      parameter ( blas_prec_single = 211, blas_prec_double = 212,
     &     blas_prec_indigenous = 213, blas_prec_extra = 214 )
      logical            lsame
      end function ilaprec

      !! ilaslc.f
      integer function ilaslc( m, n, a, lda )
      integer            m, n, lda
      real               a( lda, * )
      real             zero
      parameter ( zero = 0.0d+0 )
      integer i
      end function ilaslc

      !! ilaslr.f
      integer function ilaslr( m, n, a, lda )
      integer            m, n, lda
      real               a( lda, * )
      real             zero
      parameter ( zero = 0.0e+0 )
      integer i, j
      end function ilaslr

      !! ilatrans.f
      integer function ilatrans( trans )
      character          trans
      integer blas_no_trans, blas_trans, blas_conj_trans
      parameter ( blas_no_trans = 111, blas_trans = 112,
     &     blas_conj_trans = 113 )
      logical            lsame
      end function ilatrans

      !! ilauplo.f
      integer function ilauplo( uplo )
      character          uplo
      integer blas_upper, blas_lower
      parameter ( blas_upper = 121, blas_lower = 122 )
      logical            lsame
      end function ilauplo

      !! ilaver.f
      subroutine ilaver( vers_major, vers_minor, vers_patch )
      integer vers_major, vers_minor, vers_patch
      end subroutine ilaver

      !! ilazlc.f
      integer function ilazlc( m, n, a, lda )
      integer            m, n, lda
      complex(kind=16)   a( lda, * )
      complex(kind=16) zero
      parameter ( zero = (0.0d+0, 0.0d+0) )
      integer i
      end function ilazlc

      !! ilazlr.f
      integer function ilazlr( m, n, a, lda )
      integer            m, n, lda
      complex(kind=16)   a( lda, * )
      complex(kind=16) zero
      parameter ( zero = (0.0d+0, 0.0d+0) )
      integer i, j
      end function ilazlr

      !! iparmq.f
      integer function iparmq( ispec, name, opts, n, ilo, ihi, lwork )
      integer            ihi, ilo, ispec, lwork, n
      character          name*( * ), opts*( * )
      integer            inmin, inwin, inibl, ishfts, iacc22
      parameter          ( inmin = 12, inwin = 13, inibl = 14,
     &                   ishfts = 15, iacc22 = 16 )
      integer            nmin, k22min, kacmin, nibble, knwswp
      parameter          ( nmin = 75, k22min = 14, kacmin = 14,
     &                   nibble = 14, knwswp = 500 )
      real               two
      parameter          ( two = 2.0 )
      integer            nh, ns
      integer            i, ic, iz
      character          subnam*6
      end function iparmq

      !! izmax1.f
      integer function izmax1( n, zx, incx )
      integer            incx, n
      complex(kind=16)   zx(*)
      double precision   dmax
      integer            i, ix
      end function izmax1

      !! lsamen.f
      logical          function lsamen( n, ca, cb )
      character*( * )    ca, cb
      integer            n
      integer            i
      logical            lsame
      end function lsamen

      !! sbbcsd.f
      subroutine sbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,
     &                   theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t,
     &                   v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,
     &                   b22d, b22e, work, lwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
      real               b11d( * ), b11e( * ), b12d( * ), b12e( * ),
     &                   b21d( * ), b21e( * ), b22d( * ), b22e( * ),
     &                   phi( * ), theta( * ), work( * )
      real               u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * )
      integer            maxitr
      parameter          ( maxitr = 6 )
      real               hundred, meighth, one, piover2, ten, zero
      parameter          ( hundred = 100.0e0, meighth = -0.125e0,
     &                     one = 1.0e0, piover2 = 1.57079632679489662e0,
     &                     ten = 10.0e0, zero = 0.0e0 )
      real               negone
      parameter          ( negone = -1.0e0 )
      logical            colmajor, lquery, restart11, restart12,
     &                   restart21, restart22, wantu1, wantu2, wantv1t,
     &                   wantv2t
      integer            i, imin, imax, iter, iu1cs, iu1sn, iu2cs,
     &                   iu2sn, iv1tcs, iv1tsn, iv2tcs, iv2tsn, j,
     &                   lworkmin, lworkopt, maxit, mini
      real               b11bulge, b12bulge, b21bulge, b22bulge, dummy,
     &                   eps, mu, nu, r, sigma11, sigma21,
     &                   temp, thetamax, thetamin, thresh, tol, tolmul,
     &                   unfl, x1, x2, y1, y2
      real               slamch
      logical            lsame
      end subroutine sbbcsd

      !! sbdsdc.f
      subroutine sbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,
     &                   work, iwork, info )
      character          compq, uplo
      integer            info, ldu, ldvt, n
      integer            iq( * ), iwork( * )
      real               d( * ), e( * ), q( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      integer            difl, difr, givcol, givnum, givptr, i, ic,
     &                   icompq, ierr, ii, is, iu, iuplo, ivt, j, k, kk,
     &                   mlvl, nm1, nsize, perm, poles, qstart, smlsiz,
     &                   smlszp, sqre, start, wstart, z
      real               cs, eps, orgnrm, p, r, sn
      logical            lsame
      integer            ilaenv
      real               slamch, slanst
      end subroutine sbdsdc

      !! sbdsqr.f
      subroutine sbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,
     &                   ldu, c, ldc, work, info )
      character          uplo
      integer            info, ldc, ldu, ldvt, n, ncc, ncvt, nru
      real               c( ldc, * ), d( * ), e( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               negone
      parameter          ( negone = -1.0e0 )
      real               hndrth
      parameter          ( hndrth = 0.01e0 )
      real               ten
      parameter          ( ten = 10.0e0 )
      real               hndrd
      parameter          ( hndrd = 100.0e0 )
      real               meigth
      parameter          ( meigth = -0.125e0 )
      integer            maxitr
      parameter          ( maxitr = 6 )
      logical            lower, rotate
      integer            i, idir, isub, iter, j, ll, lll, m, maxit, nm1,
     &                   nm12, nm13, oldll, oldm
      real               abse, abss, cosl, cosr, cs, eps, f, g, h, mu,
     &                   oldcs, oldsn, r, shift, sigmn, sigmx, sinl,
     &                   sinr, sll, smax, smin, sminl,  sminoa,
     &                   sn, thresh, tol, tolmul, unfl
      logical            lsame
      real               slamch
      end subroutine sbdsqr

      !! sbdsvdx.f
      subroutine sbdsvdx( uplo, jobz, range, n, d, e, vl, vu, il, iu,
     &                    ns, s, z, ldz, work, iwork, info)
      character          jobz, range, uplo
      integer            il, info, iu, ldz, n, ns
      real               vl, vu
      integer            iwork( * )
      real               d( * ), e( * ), s( * ), work( * ),
     &                   z( ldz, * )
      real               zero, one, ten, hndrd, meigth
      parameter          ( zero = 0.0e0, one = 1.0e0, ten = 10.0e0,
     &                     hndrd = 100.0e0, meigth = -0.1250e0 )
      real               fudge
      parameter          ( fudge = 2.0e0 )
      character          rngvx
      logical            allsv, indsv, lower, split, sveq0, valsv, wantz
      integer            i, icolz, idbeg, idend, idtgk, idptr, ieptr,
     &                   ietgk, iifail, iiwork, iltgk, irowu, irowv,
     &                   irowz, isbeg, isplt, itemp, iutgk, j, k,
     &                   ntgk, nru, nrv, nsl
      real               abstol, eps, emin, mu, nrmu, nrmv, ortol, smax,
     &                   smin, sqrt2, thresh, tol, ulp,
     &                   vltgk, vutgk, zjtji
      logical            lsame
      integer            isamax
      real               sdot, slamch, snrm2
      end subroutine sbdsvdx

      !! scsum1.f
      real             function scsum1( n, cx, incx )
      integer            incx, n
      complex            cx( * )
      integer            i, nincx
      real               stemp
      end function scsum1

      !! sdisna.f
      subroutine sdisna( job, m, n, d, sep, info )
      character          job
      integer            info, m, n
      real               d( * ), sep( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            decr, eigen, incr, left, right, sing
      integer            i, k
      real               anorm, eps, newgap, oldgap, safmin, thresh
      logical            lsame
      real               slamch
      end subroutine sdisna

      !! sgbbrd.f
      subroutine sgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,
     &                   ldq, pt, ldpt, c, ldc, work, info )
      character          vect
      integer            info, kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
      real               ab( ldab, * ), c( ldc, * ), d( * ), e( * ),
     &                   pt( ldpt, * ), q( ldq, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            wantb, wantc, wantpt, wantq
      integer            i, inca, j, j1, j2, kb, kb1, kk, klm, klu1,
     &                   kun, l, minmn, ml, ml0, mn, mu, mu0, nr, nrt
      real               ra, rb, rc, rs
      logical            lsame
      end subroutine sgbbrd

      !! sgbcon.f
      subroutine sgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,
     &                   work, iwork, info )
      character          norm
      integer            info, kl, ku, ldab, n
      real               anorm, rcond
      integer            ipiv( * ), iwork( * )
      real               ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            lnoti, onenrm
      character          normin
      integer            ix, j, jp, kase, kase1, kd, lm
      real               ainvnm, scale, smlnum, t
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               sdot, slamch
      end subroutine sgbcon

      !! sgbequb.f
      subroutine sgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                    amax, info )
      integer            info, kl, ku, ldab, m, n
      real               amax, colcnd, rowcnd
      real               ab( ldab, * ), c( * ), r( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, kd
      real               bignum, rcmax, rcmin, smlnum, radix, logrdx
      real               slamch
      end subroutine sgbequb

      !! sgbequ.f
      subroutine sgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, info )
      integer            info, kl, ku, ldab, m, n
      real               amax, colcnd, rowcnd
      real               ab( ldab, * ), c( * ), r( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, kd
      real               bignum, rcmax, rcmin, smlnum
      real               slamch
      end subroutine sgbequ

      !! sgbrfs.f
      subroutine sgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, iwork,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      real               ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            notran
      character          transt
      integer            count, i, j, k, kase, kk, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine sgbrfs

      !! sgbrfsx.f
      subroutine sgbrfsx( trans, equed, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, r, c, b, ldb, x, ldx, rcond,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, iwork,
     &                    info )
      character          trans, equed
      integer            info, ldab, ldafb, ldb, ldx, n, kl, ku, nrhs,
     &                   nparams, n_err_bnds
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran
      integer            j, trans_type, prec_type, ref_type
      integer            n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, slangb, sla_gbrcond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine sgbrfsx

      !! sgbsv.f
      subroutine sgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      real               ab( ldab, * ), b( ldb, * )
      end subroutine sgbsv

      !! sgbsvx.f
      subroutine sgbsvx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                   ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, iwork, info )
      character          equed, fact, trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), c( * ), ferr( * ), r( * ),
     &                   work( * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j, j1, j2
      real               amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      real               slamch, slangb, slantb
      end subroutine sgbsvx

      !! sgbsvxx.f
      subroutine sgbsvxx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                    rcond, rpvgrw, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          equed, fact, trans
      integer            info, ldab, ldafb, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            ipiv( * ), iwork( * )
      real               ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, i, j, kl, ku
      real               amax, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, smlnum
      logical            lsame
      real               slamch, sla_gbrpvgrw
      end subroutine sgbsvxx

      !! sgbtf2.f
      subroutine sgbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      real               ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, jp, ju, km, kv
      integer            isamax
      end subroutine sgbtf2

      !! sgbtrf.f
      subroutine sgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      real               ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            nbmax, ldwork
      parameter          ( nbmax = 64, ldwork = nbmax+1 )
      integer            i, i2, i3, ii, ip, j, j2, j3, jb, jj, jm, jp,
     &                   ju, k2, km, kv, nb, nw
      real               temp
      real               work13( ldwork, nbmax ),
     &                   work31( ldwork, nbmax )
      integer            ilaenv, isamax
      end subroutine sgbtrf

      !! sgbtrs.f
      subroutine sgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      real               ab( ldab, * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lnoti, notran
      integer            i, j, kd, l, lm
      logical            lsame
      end subroutine sgbtrs

      !! sgebak.f
      subroutine sgebak( job, side, n, ilo, ihi, scale, m, v, ldv,
     &                   info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      real               v( ldv, * ), scale( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            leftv, rightv
      integer            i, ii, k
      real               s
      logical            lsame
      end subroutine sgebak

      !! sgebal.f
      subroutine sgebal( job, n, a, lda, ilo, ihi, scale, info )
      character          job
      integer            ihi, ilo, info, lda, n
      real               a( lda, * ), scale( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               sclfac
      parameter          ( sclfac = 2.0e+0 )
      real               factor
      parameter          ( factor = 0.95e+0 )
      logical            noconv
      integer            i, ica, iexc, ira, j, k, l, m
      real               c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1,
     &                   sfmin2
      logical            sisnan, lsame
      integer            isamax
      real               slamch, snrm2
      end subroutine sgebal

      !! sgebd2.f
      subroutine sgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
      integer            info, lda, m, n
      real               a( lda, * ), d( * ), e( * ), taup( * ),
     &                   tauq( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i
      end subroutine sgebd2

      !! sgebrd.f
      subroutine sgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,
     &                   info )
      integer            info, lda, lwork, m, n
      real               a( lda, * ), d( * ), e( * ), taup( * ),
     &                   tauq( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lquery
      integer            i, iinfo, j, ldwrkx, ldwrky, lwkopt, minmn, nb,
     &                   nbmin, nx
      real               ws
      integer            ilaenv
      end subroutine sgebrd

      !! sgecon.f
      subroutine sgecon( norm, n, a, lda, anorm, rcond, work, iwork,
     &                   info )
      character          norm
      integer            info, lda, n
      real               anorm, rcond
      integer            iwork( * )
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            onenrm
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, scale, sl, smlnum, su
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch
      end subroutine sgecon

      !! sgeequb.f
      subroutine sgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                    info )
      integer            info, lda, m, n
      real               amax, colcnd, rowcnd
      real               a( lda, * ), c( * ), r( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               bignum, rcmax, rcmin, smlnum, radix, logrdx
      real               slamch
      end subroutine sgeequb

      !! sgeequ.f
      subroutine sgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   info )
      integer            info, lda, m, n
      real               amax, colcnd, rowcnd
      real               a( lda, * ), c( * ), r( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               bignum, rcmax, rcmin, smlnum
      real               slamch
      end subroutine sgeequ

      !! sgees.f
      subroutine sgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,
     &                  vs, ldvs, work, lwork, bwork, info )
      character          jobvs, sort
      integer            info, lda, ldvs, lwork, n, sdim
      logical            bwork( * )
      real               a( lda, * ), vs( ldvs, * ), wi( * ), work( * ),
     &                   wr( * )
      logical            select
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            cursl, lastsl, lquery, lst2sl, scalea, wantst,
     &                   wantvs
      integer            hswork, i, i1, i2, ibal, icond, ierr, ieval,
     &                   ihi, ilo, inxt, ip, itau, iwrk, maxwrk, minwrk
      real               anrm, bignum, cscale, eps, s, sep, smlnum
      integer            idum( 1 )
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sgees

      !! sgeesx.f
      subroutine sgeesx( jobvs, sort, select, sense, n, a, lda, sdim,
     &                   wr, wi, vs, ldvs, rconde, rcondv, work, lwork,
     &                   iwork, liwork, bwork, info )
      character          jobvs, sense, sort
      integer            info, lda, ldvs, liwork, lwork, n, sdim
      real               rconde, rcondv
      logical            bwork( * )
      integer            iwork( * )
      real               a( lda, * ), vs( ldvs, * ), wi( * ), work( * ),
     &                   wr( * )
      logical            select
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            cursl, lastsl, lquery, lst2sl, scalea, wantsb,
     &                   wantse, wantsn, wantst, wantsv, wantvs
      integer            hswork, i, i1, i2, ibal, icond, ierr, ieval,
     &                   ihi, ilo, inxt, ip, itau, iwrk, lwrk, liwrk,
     &                   maxwrk, minwrk
      real               anrm, bignum, cscale, eps, smlnum
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sgeesx

      !! sgeev.f
      subroutine sgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,
     &                  ldvr, work, lwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldvl, ldvr, lwork, n
      real               a( lda, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   wi( * ), work( * ), wr( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, scalea, wantvl, wantvr
      character          side
      integer            hswork, i, ibal, ierr, ihi, ilo, itau, iwrk, k,
     &                   maxwrk, minwrk, nout
      real               anrm, bignum, cs, cscale, eps, r, scl, smlnum,
     &                   sn
      logical            select( 1 )
      real               dum( 1 )
      logical            lsame
      integer            ilaenv, isamax
      real               slamch, slange, slapy2, snrm2
      end subroutine sgeev

      !! sgeevx.f
      subroutine sgeevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,
     &                   vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm,
     &                   rconde, rcondv, work, lwork, iwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldvl, ldvr, lwork, n
      real               abnrm
      integer            iwork( * )
      real               a( lda, * ), rconde( * ), rcondv( * ),
     &                   scale( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   wi( * ), work( * ), wr( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, scalea, wantvl, wantvr, wntsnb, wntsne,
     &                   wntsnn, wntsnv
      character          job, side
      integer            hswork, i, icond, ierr, itau, iwrk, k, maxwrk,
     &                   minwrk, nout
      real               anrm, bignum, cs, cscale, eps, r, scl, smlnum,
     &                   sn
      logical            select( 1 )
      real               dum( 1 )
      logical            lsame
      integer            ilaenv, isamax
      real               slamch, slange, slapy2, snrm2
      end subroutine sgeevx

      !! sgehd2.f
      subroutine sgehd2( n, ilo, ihi, a, lda, tau, work, info )
      integer            ihi, ilo, info, lda, n
      real               a( lda, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i
      real               aii
      end subroutine sgehd2

      !! sgehrd.f
      subroutine sgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      real              a( lda, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      real              zero, one
      parameter          ( zero = 0.0e+0,
     &                     one = 1.0e+0 )
      logical            lquery
      integer            i, ib, iinfo, iwt, j, ldwork, lwkopt, nb,
     &                   nbmin, nh, nx
      real              ei
      integer            ilaenv
      end subroutine sgehrd

      !! sgejsv.f
      subroutine sgejsv( joba, jobu, jobv, jobr, jobt, jobp,
     &                   m, n, a, lda, sva, u, ldu, v, ldv,
     &                   work, lwork, iwork, info )
      integer     info, lda, ldu, ldv, lwork, m, n
      real        a( lda, * ), sva( n ), u( ldu, * ), v( ldv, * ),
     &            work( lwork )
      integer     iwork( * )
      character(len=1) joba, jobp, jobr, jobt, jobu, jobv
      real        zero,         one
      parameter ( zero = 0.0e0, one = 1.0e0 )
      real    aapp,   aaqq,   aatmax, aatmin, big,    big1,   cond_ok,
     &        condr1, condr2, entra,  entrat, epsln,  maxprj, scalem,
     &        sconda, sfmin,  small,  temp1,  uscal1, uscal2, xsc
      integer ierr,   n1,     nr,     numrank,        p, q,   warning
      logical almort, defr,   errest, goscal, jracc,  kill,   lsvec,
     &        l2aber, l2kill, l2pert, l2rank, l2tran,
     &        noscal, rowpiv, rsvec,  transp
      real      slamch, snrm2
      integer   isamax
      logical   lsame
      end subroutine sgejsv

      !! sgelq2.f
      subroutine sgelq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i, k
      real               aii
      end subroutine sgelq2

      !! sgelqf.f
      subroutine sgelqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine sgelqf

      !! sgelsd.f
      subroutine sgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond,
     &                   rank, work, lwork, iwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      real               rcond
      integer            iwork( * )
      real               a( lda, * ), b( ldb, * ), s( * ), work( * )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      logical            lquery
      integer            iascl, ibscl, ie, il, itau, itaup, itauq,
     &                   ldwork, liwork, maxmn, maxwrk, minmn, minwrk,
     &                   mm, mnthr, nlvl, nwork, smlsiz, wlalsd
      real               anrm, bignum, bnrm, eps, sfmin, smlnum
      integer            ilaenv
      real               slamch, slange
      end subroutine sgelsd

      !! sgels.f
      subroutine sgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,
     &                  info )
      character          trans
      integer            info, lda, ldb, lwork, m, n, nrhs
      real               a( lda, * ), b( ldb, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, tpsd
      integer            brow, i, iascl, ibscl, j, mn, nb, scllen, wsize
      real               anrm, bignum, bnrm, smlnum
      real               rwork( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sgels

      !! sgelss.f
      subroutine sgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,
     &                   work, lwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      real               rcond
      real               a( lda, * ), b( ldb, * ), s( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery
      integer            bdspac, bl, chunk, i, iascl, ibscl, ie, il,
     &                   itau, itaup, itauq, iwork, ldwork, maxmn,
     &                   maxwrk, minmn, minwrk, mm, mnthr
      integer            lwork_sgeqrf, lwork_sormqr, lwork_sgebrd,
     &                   lwork_sormbr, lwork_sorgbr, lwork_sormlq
      real               anrm, bignum, bnrm, eps, sfmin, smlnum, thr
      real               dum( 1 )
      integer            ilaenv
      real               slamch, slange
      end subroutine sgelss

      !! sgelsy.f
      subroutine sgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,
     &                   work, lwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      real               rcond
      integer            jpvt( * )
      real               a( lda, * ), b( ldb, * ), work( * )
      integer            imax, imin
      parameter          ( imax = 1, imin = 2 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery
      integer            i, iascl, ibscl, ismax, ismin, j, lwkmin,
     &                   lwkopt, mn, nb, nb1, nb2, nb3, nb4
      real               anrm, bignum, bnrm, c1, c2, s1, s2, smax,
     &                   smaxpr, smin, sminpr, smlnum, wsize
      integer            ilaenv
      real               slamch, slange
      end subroutine sgelsy

      !! sgemqrt.f
      subroutine sgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,
     &                   c, ldc, work, info )
      character side, trans
      integer   info, k, ldv, ldc, m, n, nb, ldt
      real   v( ldv, * ), c( ldc, * ), t( ldt, * ), work( * )
      logical            left, right, tran, notran
      integer            i, ib, ldwork, kf, q
      logical            lsame
      end subroutine sgemqrt

      !! sgeql2.f
      subroutine sgeql2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i, k
      real               aii
      end subroutine sgeql2

      !! sgeqlf.f
      subroutine sgeqlf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine sgeqlf

      !! sgeqp3.f
      subroutine sgeqp3( m, n, a, lda, jpvt, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      integer            jpvt( * )
      real               a( lda, * ), tau( * ), work( * )
      integer            inb, inbmin, ixover
      parameter          ( inb = 1, inbmin = 2, ixover = 3 )
      logical            lquery
      integer            fjb, iws, j, jb, lwkopt, minmn, minws, na, nb,
     &                   nbmin, nfxd, nx, sm, sminmn, sn, topbmn
      integer            ilaenv
      real               snrm2
      end subroutine sgeqp3

      !! sgeqr2.f
      subroutine sgeqr2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i, k
      real               aii
      end subroutine sgeqr2

      !! sgeqr2p.f
      subroutine sgeqr2p( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i, k
      real               aii
      end subroutine sgeqr2p

      !! sgeqrf.f
      subroutine sgeqrf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine sgeqrf

      !! sgeqrfp.f
      subroutine sgeqrfp( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine sgeqrfp

      !! sgeqrt2.f
      subroutine sgeqrt2( m, n, a, lda, t, ldt, info )
      integer   info, lda, ldt, m, n
      real   a( lda, * ), t( ldt, * )
      real  one, zero
      parameter( one = 1.0, zero = 0.0 )
      integer   i, k
      real   aii, alpha
      end subroutine sgeqrt2

      !! sgeqrt3.f
      recursive subroutine sgeqrt3( m, n, a, lda, t, ldt, info )
      integer   info, lda, m, n, ldt
      real   a( lda, * ), t( ldt, * )
      real   one
      parameter ( one = 1.0 )
      integer   i, i1, j, j1, n1, n2, iinfo
      end subroutine sgeqrt3

      !! sgeqrt.f
      subroutine sgeqrt( m, n, nb, a, lda, t, ldt, work, info )
      integer info, lda, ldt, m, n, nb
      real a( lda, * ), t( ldt, * ), work( * )
      integer    i, ib, iinfo, k
      logical    use_recursive_qr
      parameter( use_recursive_qr=.true. )
      end subroutine sgeqrt

      !! sgerfs.f
      subroutine sgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, iwork, info )
      character          trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            notran
      character          transt
      integer            count, i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine sgerfs

      !! sgerfsx.f
      subroutine sgerfsx( trans, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          trans, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ), work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran
      integer            j, trans_type, prec_type, ref_type
      integer            n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, slange, sla_gercond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine sgerfsx

      !! sgerq2.f
      subroutine sgerq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i, k
      real               aii
      end subroutine sgerq2

      !! sgerqf.f
      subroutine sgerqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine sgerqf

      !! sgesc2.f
      subroutine sgesc2( n, a, lda, rhs, ipiv, jpiv, scale )
      integer            lda, n
      real               scale
      integer            ipiv( * ), jpiv( * )
      real               a( lda, * ), rhs( * )
      real               one, two
      parameter          ( one = 1.0e+0, two = 2.0e+0 )
      integer            i, j
      real               bignum, eps, smlnum, temp
      integer            isamax
      real               slamch
      end subroutine sgesc2

      !! sgesdd.f
      subroutine sgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work,
     &                   lwork, iwork, info )
      character          jobz
      integer            info, lda, ldu, ldvt, lwork, m, n
      integer            iwork( * )
      real               a( lda, * ), s( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, wntqa, wntqas, wntqn, wntqo, wntqs
      integer            bdspac, blk, chunk, i, ie, ierr, il,
     &                   ir, iscl, itau, itaup, itauq, iu, ivt, ldwkvt,
     &                   ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk,
     &                   mnthr, nwork, wrkbl
      real               anrm, bignum, eps, smlnum
      integer            idum( 1 )
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sgesdd

      !! sgesvd.f
      subroutine sgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,
     &                   work, lwork, info )
      character          jobu, jobvt
      integer            info, lda, ldu, ldvt, lwork, m, n
      real               a( lda, * ), s( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, wntua, wntuas, wntun, wntuo, wntus,
     &                   wntva, wntvas, wntvn, wntvo, wntvs
      integer            bdspac, blk, chunk, i, ie, ierr, ir, iscl,
     &                   itau, itaup, itauq, iu, iwork, ldwrkr, ldwrku,
     &                   maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru,
     &                   nrvt, wrkbl
      integer            lwork_sgeqrf, lwork_sorgqr_n, lwork_sorgqr_m,
     &                   lwork_sgebrd, lwork_sorgbr_p, lwork_sorgbr_q,
     &                   lwork_sgelqf, lwork_sorglq_n, lwork_sorglq_m
      real               anrm, bignum, eps, smlnum
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sgesvd

      !! sgesvdx.f
      subroutine sgesvdx( jobu, jobvt, range, m, n, a, lda, vl, vu,
     &                    il, iu, ns, s, u, ldu, vt, ldvt, work,
     &                    lwork, iwork, info )
      character          jobu, jobvt, range
      integer            il, info, iu, lda, ldu, ldvt, lwork, m, n, ns
      real               vl, vu
      integer            iwork( * )
      real               a( lda, * ), s( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      character          jobz, rngtgk
      logical            alls, inds, lquery, vals, wantu, wantvt
      integer            i, id, ie, ierr, ilqf, iltgk, iqrf, iscl,
     &                   itau, itaup, itauq, itemp, itgkz, iutgk,
     &                   j, maxwrk, minmn, minwrk, mnthr
      real               abstol, anrm, bignum, eps, smlnum
      real               dum( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange, snrm2
      end subroutine sgesvdx

      !! sgesv.f
      subroutine sgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      real               a( lda, * ), b( ldb, * )
      end subroutine sgesv

      !! sgesvj.f
      subroutine sgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,
     &                   ldv, work, lwork, info )
      integer            info, lda, ldv, lwork, m, mv, n
      character(len=1)   joba, jobu, jobv
      real               a( lda, * ), sva( n ), v( ldv, * ),
     &                   work( lwork )
      real               zero, half, one
      parameter          ( zero = 0.0e0, half = 0.5e0, one = 1.0e0)
      integer            nsweep
      parameter          ( nsweep = 30 )
      real               aapp, aapp0, aapq, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, ctol, epsln, large, mxaapq,
     &                   mxsinj, rootbig, rooteps, rootsfmin, roottol,
     &                   skl, sfmin, small, sn, t, temp1, theta,
     &                   thsign, tol
      integer            blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &                   iswrot, jbc, jgl, kbl, lkahead, mvl, n2, n34,
     &                   n4, nbl, notrot, p, pskipped, q, rowskip,
     &                   swband
      logical            applv, goscale, lower, lsvec, noscale, rotok,
     &                   rsvec, uctol, upper
      real               fastr( 5 )
      real               sdot, snrm2
      integer            isamax
      real               slamch
      logical            lsame
      end subroutine sgesvj

      !! sgesvx.f
      subroutine sgesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                   equed, r, c, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, iwork, info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), c( * ), ferr( * ), r( * ),
     &                   work( * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j
      real               amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      real               slamch, slange, slantr
      end subroutine sgesvx

      !! sgesvxx.f
      subroutine sgesvxx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, r, c, b, ldb, x, ldx, rcond, rpvgrw,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, iwork,
     &                    info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      real               r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, j
      real               amax, bignum, colcnd, rcmax, rcmin, rowcnd,
     &                   smlnum
      logical            lsame
      real               slamch, sla_gerpvgrw
      end subroutine sgesvxx

      !! sgetc2.f
      subroutine sgetc2( n, a, lda, ipiv, jpiv, info )
      integer            info, lda, n
      integer            ipiv( * ), jpiv( * )
      real               a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i, ip, ipv, j, jp, jpv
      real               bignum, eps, smin, smlnum, xmax
      real               slamch
      end subroutine sgetc2

      !! sgetf2.f
      subroutine sgetf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      real               a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      real               sfmin
      integer            i, j, jp
      real               slamch
      integer            isamax
      end subroutine sgetf2

      !! sgetrf2.f
      recursive subroutine sgetrf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      real               a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      real               sfmin, temp
      integer            i, iinfo, n1, n2
      real               slamch
      integer            isamax
      end subroutine sgetrf2

      !! sgetrf.f
      subroutine sgetrf( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      real               a( lda, * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i, iinfo, j, jb, nb
      integer            ilaenv
      end subroutine sgetrf

      !! sgetri.f
      subroutine sgetri( n, a, lda, ipiv, work, lwork, info )
      integer            info, lda, lwork, n
      integer            ipiv( * )
      real               a( lda, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery
      integer            i, iws, j, jb, jj, jp, ldwork, lwkopt, nb,
     &                   nbmin, nn
      integer            ilaenv
      end subroutine sgetri

      !! sgetrs.f
      subroutine sgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          trans
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      real               a( lda, * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            notran
      logical            lsame
      end subroutine sgetrs

      !! sggbak.f
      subroutine sggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,
     &                   ldv, info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      real               lscale( * ), rscale( * ), v( ldv, * )
      logical            leftv, rightv
      integer            i, k
      logical            lsame
      end subroutine sggbak

      !! sggbal.f
      subroutine sggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,
     &                   rscale, work, info )
      character          job
      integer            ihi, ilo, info, lda, ldb, n
      real               a( lda, * ), b( ldb, * ), lscale( * ),
     &                   rscale( * ), work( * )
      real               zero, half, one
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0 )
      real               three, sclfac
      parameter          ( three = 3.0e+0, sclfac = 1.0e+1 )
      integer            i, icab, iflow, ip1, ir, irab, it, j, jc, jp1,
     &                   k, kount, l, lcab, lm1, lrab, lsfmax, lsfmin,
     &                   m, nr, nrp2
      real               alpha, basl, beta, cab, cmax, coef, coef2,
     &                   coef5, cor, ew, ewc, gamma, pgamma, rab, sfmax,
     &                   sfmin, sum, t, ta, tb, tc
      logical            lsame
      integer            isamax
      real               sdot, slamch
      end subroutine sggbal

      !! sgges3.f
      subroutine sgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,
     &                   ldb, sdim, alphar, alphai, beta, vsl, ldvsl,
     &                   vsr, ldvsr, work, lwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      real               a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vsl( ldvsl, * ),
     &                   vsr( ldvsr, * ), work( * )
      logical            selctg
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, lst2sl, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, ip, iright, irows, itau, iwrk, lwkopt
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, safmax, safmin, smlnum
      integer            idum( 1 )
      real               dif( 2 )
      logical            lsame
      real               slamch, slange
      end subroutine sgges3

      !! sgges.f
      subroutine sgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,
     &                  sdim, alphar, alphai, beta, vsl, ldvsl, vsr,
     &                  ldvsr, work, lwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      real               a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vsl( ldvsl, * ),
     &                   vsr( ldvsr, * ), work( * )
      logical            selctg
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, lst2sl, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, ip, iright, irows, itau, iwrk, maxwrk,
     &                   minwrk
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, safmax, safmin, smlnum
      integer            idum( 1 )
      real               dif( 2 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sgges

      !! sggesx.f
      subroutine sggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,
     &                   b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl,
     &                   vsr, ldvsr, rconde, rcondv, work, lwork, iwork,
     &                   liwork, bwork, info )
      character          jobvsl, jobvsr, sense, sort
      integer            info, lda, ldb, ldvsl, ldvsr, liwork, lwork, n,
     &                   sdim
      logical            bwork( * )
      integer            iwork( * )
      real               a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), rconde( 2 ),
     &                   rcondv( 2 ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, lst2sl, wantsb, wantse, wantsn, wantst,
     &                   wantsv
      integer            i, icols, ierr, ihi, ijob, ijobvl, ijobvr,
     &                   ileft, ilo, ip, iright, irows, itau, iwrk,
     &                   liwmin, lwrk, maxwrk, minwrk
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps, pl,
     &                   pr, safmax, safmin, smlnum
      real               dif( 2 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sggesx

      !! sggev3.f
      subroutine sggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,
     &                   alphai, beta, vl, ldvl, vr, ldvr, work, lwork,
     &                   info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      real               a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, itau, iwrk, jc, jr, lwkopt
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      logical            ldumma( 1 )
      logical            lsame
      real               slamch, slange
      end subroutine sggev3

      !! sggev.f
      subroutine sggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,
     &                  beta, vl, ldvl, vr, ldvr, work, lwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      real               a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, itau, iwrk, jc, jr, maxwrk,
     &                   minwrk
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sggev

      !! sggevx.f
      subroutine sggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,
     &                   alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo,
     &                   ihi, lscale, rscale, abnrm, bbnrm, rconde,
     &                   rcondv, work, lwork, iwork, bwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldb, ldvl, ldvr, lwork, n
      real               abnrm, bbnrm
      logical            bwork( * )
      integer            iwork( * )
      real               a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), lscale( * ),
     &                   rconde( * ), rcondv( * ), rscale( * ),
     &                   vl( ldvl, * ), vr( ldvr, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl,
     &                   pair, wantsb, wantse, wantsn, wantsv
      character          chtemp
      integer            i, icols, ierr, ijobvl, ijobvr, in, irows,
     &                   itau, iwrk, iwrk1, j, jc, jr, m, maxwrk,
     &                   minwrk, mm
      real               anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch, slange
      end subroutine sggevx

      !! sggglm.f
      subroutine sggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      real               a( lda, * ), b( ldb, * ), d( * ), work( * ),
     &                   x( * ), y( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery
      integer            i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3,
     &                   nb4, np
      integer            ilaenv
      end subroutine sggglm

      !! sgghd3.f
      subroutine sgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, work, lwork, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n, lwork
      real               a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            blk22, initq, initz, lquery, wantq, wantz
      character(len=1)   compq2, compz2
      integer            cola, i, ierr, j, j0, jcol, jj, jrow, k,
     &                   kacc22, len, lwkopt, n2nb, nb, nblst, nbmin,
     &                   nh, nnb, nx, ppw, ppwo, pw, top, topq
      real               c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
      logical            lsame
      integer            ilaenv
      end subroutine sgghd3

      !! sgghrd.f
      subroutine sgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n
      real               a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            ilq, ilz
      integer            icompq, icompz, jcol, jrow
      real               c, s, temp
      logical            lsame
      end subroutine sgghrd

      !! sgglse.f
      subroutine sgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      real               a( lda, * ), b( ldb, * ), c( * ), d( * ),
     &                   work( * ), x( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lquery
      integer            lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3,
     &                   nb4, nr
      integer            ilaenv
      end subroutine sgglse

      !! sggqrf.f
      subroutine sggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      real               a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine sggqrf

      !! sggrqf.f
      subroutine sggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      real               a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine sggrqf

      !! sggsvd3.f
      subroutine sggsvd3( jobu, jobv, jobq, m, n, p, k, l, a, lda, b,
     &                    ldb, alpha, beta, u, ldu, v, ldv, q, ldq,
     &                    work, lwork, iwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      integer            iwork( * )
      real               a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), q( ldq, * ), u( ldu, * ),
     &                   v( ldv, * ), work( * )
      logical            wantq, wantu, wantv, lquery
      integer            i, ibnd, isub, j, ncycle, lwkopt
      real               anorm, bnorm, smax, temp, tola, tolb, ulp, unfl
      logical            lsame
      real               slamch, slange
      end subroutine sggsvd3

      !! sggsvp3.f
      subroutine sggsvp3( jobu, jobv, jobq, m, p, n, a, lda, b, ldb,
     &                    tola, tolb, k, l, u, ldu, v, ldv, q, ldq,
     &                    iwork, tau, work, lwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      real               tola, tolb
      integer            iwork( * )
      real               a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   tau( * ), u( ldu, * ), v( ldv, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            forwrd, wantq, wantu, wantv, lquery
      integer            i, j, lwkopt
      logical            lsame
      end subroutine sggsvp3

      !! sgsvj0.f
      subroutine sgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,
     &                   sfmin, tol, nsweep, work, lwork, info )
      integer            info, lda, ldv, lwork, m, mv, n, nsweep
      real               eps, sfmin, tol
      character(len=1)   jobv
      real               a( lda, * ), sva( n ), d( n ), v( ldv, * ),
     &                   work( lwork )
      real               zero, half, one
      parameter          ( zero = 0.0e0, half = 0.5e0, one = 1.0e0)
      real               aapp, aapp0, aapq, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, mxaapq, mxsinj, rootbig, rooteps,
     &                   rootsfmin, roottol, small, sn, t, temp1, theta,
     &                   thsign
      integer            blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &                   iswrot, jbc, jgl, kbl, lkahead, mvl, nbl,
     &                   notrot, p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      real               fastr( 5 )
      real               sdot, snrm2
      integer            isamax
      logical            lsame
      end subroutine sgsvj0

      !! sgsvj1.f
      subroutine sgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,
     &                   eps, sfmin, tol, nsweep, work, lwork, info )
      real               eps, sfmin, tol
      integer            info, lda, ldv, lwork, m, mv, n, n1, nsweep
      character(len=1)   jobv
      real               a( lda, * ), d( n ), sva( n ), v( ldv, * ),
     &                   work( lwork )
      real               zero, half, one
      parameter          ( zero = 0.0e0, half = 0.5e0, one = 1.0e0)
      real               aapp, aapp0, aapq, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, large, mxaapq, mxsinj, rootbig,
     &                   rooteps, rootsfmin, roottol, small, sn, t,
     &                   temp1, theta, thsign
      integer            blskip, emptsw, i, ibr, igl, ierr, ijblsk,
     &                   iswrot, jbc, jgl, kbl, mvl, notrot, nblc, nblr,
     &                   p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      real               fastr( 5 )
      real               sdot, snrm2
      integer            isamax
      logical            lsame
      end subroutine sgsvj1

      !! sgtcon.f
      subroutine sgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,
     &                   work, iwork, info )
      character          norm
      integer            info, n
      real               anorm, rcond
      integer            ipiv( * ), iwork( * )
      real               d( * ), dl( * ), du( * ), du2( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            onenrm
      integer            i, kase, kase1
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine sgtcon

      !! sgtrfs.f
      subroutine sgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, iwork,
     &                   info )
      character          trans
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      real               b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   dl( * ), dlf( * ), du( * ), du2( * ), duf( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine sgtrfs

      !! sgtsv.f
      subroutine sgtsv( n, nrhs, dl, d, du, b, ldb, info )
      integer            info, ldb, n, nrhs
      real               b( ldb, * ), d( * ), dl( * ), du( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            i, j
      real               fact, temp
      end subroutine sgtsv

      !! sgtsvx.f
      subroutine sgtsvx( fact, trans, n, nrhs, dl, d, du, dlf, df, duf,
     &                   du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, iwork, info )
      character          fact, trans
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   dl( * ), dlf( * ), du( * ), du2( * ), duf( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nofact, notran
      character          norm
      real               anorm
      logical            lsame
      real               slamch, slangt
      end subroutine sgtsvx

      !! sgttrf.f
      subroutine sgttrf( n, dl, d, du, du2, ipiv, info )
      integer            info, n
      integer            ipiv( * )
      real               d( * ), dl( * ), du( * ), du2( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            i
      real               fact, temp
      end subroutine sgttrf

      !! sgttrs.f
      subroutine sgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      real               b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      logical            notran
      integer            itrans, j, jb, nb
      integer            ilaenv
      end subroutine sgttrs

      !! sgtts2.f
      subroutine sgtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
      integer            itrans, ldb, n, nrhs
      integer            ipiv( * )
      real               b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      integer            i, ip, j
      real               temp
      end subroutine sgtts2

      !! shgeqz.f
      subroutine shgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,
     &                   alphar, alphai, beta, q, ldq, z, ldz, work,
     &                   lwork, info )
      character          compq, compz, job
      integer            ihi, ilo, info, ldh, ldq, ldt, ldz, lwork, n
      real               alphai( * ), alphar( * ), beta( * ),
     &                   h( ldh, * ), q( ldq, * ), t( ldt, * ),
     &                   work( * ), z( ldz, * )
      real               half, zero, one, safety
      parameter          ( half = 0.5e+0, zero = 0.0e+0, one = 1.0e+0,
     &                   safety = 1.0e+2 )
      logical            ilazr2, ilazro, ilpivt, ilq, ilschr, ilz,
     &                   lquery
      integer            icompq, icompz, ifirst, ifrstm, iiter, ilast,
     &                   ilastm, in, ischur, istart, j, jc, jch, jiter,
     &                   jr, maxit
      real               a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11,
     &                   ad11l, ad12, ad12l, ad21, ad21l, ad22, ad22l,
     &                   ad32l, an, anorm, ascale, atol, b11, b1a, b1i,
     &                   b1r, b22, b2a, b2i, b2r, bn, bnorm, bscale,
     &                   btol, c, c11i, c11r, c12, c21, c22i, c22r, cl,
     &                   cq, cr, cz, eshift, s, s1, s1inv, s2, safmax,
     &                   safmin, scale, sl, sqi, sqr, sr, szi, szr, t1,
     &                   tau, temp, temp2, tempi, tempr, u1, u12, u12l,
     &                   u2, ulp, vs, w11, w12, w21, w22, wabs, wi, wr,
     &                   wr2
      real               v( 3 )
      logical            lsame
      real               slamch, slanhs, slapy2, slapy3
      end subroutine shgeqz

      !! shsein.f
      subroutine shsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,
     &                   vl, ldvl, vr, ldvr, mm, m, work, ifaill,
     &                   ifailr, info )
      character          eigsrc, initv, side
      integer            info, ldh, ldvl, ldvr, m, mm, n
      logical            select( * )
      integer            ifaill( * ), ifailr( * )
      real               h( ldh, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   wi( * ), work( * ), wr( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            bothv, fromqr, leftv, noinit, pair, rightv
      integer            i, iinfo, k, kl, kln, kr, ksi, ksr, ldwork
      real               bignum, eps3, hnorm, smlnum, ulp, unfl, wki,
     &                   wkr
      logical            lsame, sisnan
      real               slamch, slanhs
      end subroutine shsein

      !! shseqr.f
      subroutine shseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,
     &                   ldz, work, lwork, info )
      integer            ihi, ilo, info, ldh, ldz, lwork, n
      character          compz, job
      real               h( ldh, * ), wi( * ), work( * ), wr( * ),
     &                   z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            nl
      parameter          ( nl = 49 )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      real               hl( nl, nl ), workl( nl )
      integer            i, kbot, nmin
      logical            initz, lquery, wantt, wantz
      integer            ilaenv
      logical            lsame
      end subroutine shseqr

      !! sisnan.f
      logical function sisnan( sin )
      real               sin
      logical slaisnan
      end function sisnan

      !! slabad.f
      subroutine slabad( small, large )
      real               large, small
      end subroutine slabad

      !! slabrd.f
      subroutine slabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,
     &                   ldy )
      integer            lda, ldx, ldy, m, n, nb
      real               a( lda, * ), d( * ), e( * ), taup( * ),
     &                   tauq( * ), x( ldx, * ), y( ldy, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      integer            i
      end subroutine slabrd

      !! slacn2.f
      subroutine slacn2( n, v, x, isgn, est, kase, isave )
      integer            kase, n
      real               est
      integer            isgn( * ), isave( 3 )
      real               v( * ), x( * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      integer            i, jlast
      real               altsgn, estold, temp
      integer            isamax
      real               sasum
      end subroutine slacn2

      !! slacon.f
      subroutine slacon( n, v, x, isgn, est, kase )
      integer            kase, n
      real               est
      integer            isgn( * )
      real               v( * ), x( * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      integer            i, iter, j, jlast, jump
      real               altsgn, estold, temp
      integer            isamax
      real               sasum
      end subroutine slacon

      !! slacpy.f
      subroutine slacpy( uplo, m, n, a, lda, b, ldb )
      character          uplo
      integer            lda, ldb, m, n
      real               a( lda, * ), b( ldb, * )
      integer            i, j
      logical            lsame
      end subroutine slacpy

      !! sladiv.f
      subroutine sladiv( a, b, c, d, p, q )
      real               a, b, c, d, p, q
      real               bs
      parameter          ( bs = 2.0e0 )
      real               half
      parameter          ( half = 0.5e0 )
      real               two
      parameter          ( two = 2.0e0 )
      real               aa, bb, cc, dd, ab, cd, s, ov, un, be, eps
      real               slamch
      end subroutine sladiv

      !! slae2.f
      subroutine slae2( a, b, c, rt1, rt2 )
      real               a, b, c, rt1, rt2
      real               one
      parameter          ( one = 1.0e0 )
      real               two
      parameter          ( two = 2.0e0 )
      real               zero
      parameter          ( zero = 0.0e0 )
      real               half
      parameter          ( half = 0.5e0 )
      real               ab, acmn, acmx, adf, df, rt, sm, tb
      end subroutine slae2

      !! slaebz.f
      subroutine slaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,
     &                   reltol, pivmin, d, e, e2, nval, ab, c, mout,
     &                   nab, work, iwork, info )
      integer            ijob, info, minp, mmax, mout, n, nbmin, nitmax
      real               abstol, pivmin, reltol
      integer            iwork( * ), nab( mmax, * ), nval( * )
      real               ab( mmax, * ), c( * ), d( * ), e( * ), e2( * ),
     &                   work( * )
      real               zero, two, half
      parameter          ( zero = 0.0e0, two = 2.0e0,
     &                   half = 1.0e0 / two )
      integer            itmp1, itmp2, j, ji, jit, jp, kf, kfnew, kl,
     &                   klnew
      real               tmp1, tmp2
      end subroutine slaebz

      !! slaed0.f
      subroutine slaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,
     &                   work, iwork, info )
      integer            icompq, info, ldq, ldqs, n, qsiz
      integer            iwork( * )
      real               d( * ), e( * ), q( ldq, * ), qstore( ldqs, * ),
     &                   work( * )
      real               zero, one, two
      parameter          ( zero = 0.e0, one = 1.e0, two = 2.e0 )
      integer            curlvl, curprb, curr, i, igivcl, igivnm,
     &                   igivpt, indxq, iperm, iprmpt, iq, iqptr, iwrem,
     &                   j, k, lgn, matsiz, msd2, smlsiz, smm1, spm1,
     &                   spm2, submat, subpbs, tlvls
      real               temp
      integer            ilaenv
      end subroutine slaed0

      !! slaed1.f
      subroutine slaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,
     &                   info )
      integer            cutpnt, info, ldq, n
      real               rho
      integer            indxq( * ), iwork( * )
      real               d( * ), q( ldq, * ), work( * )
      integer            coltyp, cpp1, i, idlmda, indx, indxc, indxp,
     &                   iq2, is, iw, iz, k, n1, n2
      end subroutine slaed1

      !! slaed2.f
      subroutine slaed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,
     &                   q2, indx, indxc, indxp, coltyp, info )
      integer            info, k, ldq, n, n1
      real               rho
      integer            coltyp( * ), indx( * ), indxc( * ), indxp( * ),
     &                   indxq( * )
      real               d( * ), dlamda( * ), q( ldq, * ), q2( * ),
     &                   w( * ), z( * )
      real               mone, zero, one, two, eight
      parameter          ( mone = -1.0e0, zero = 0.0e0, one = 1.0e0,
     &                   two = 2.0e0, eight = 8.0e0 )
      integer            ctot( 4 ), psm( 4 )
      integer            ct, i, imax, iq1, iq2, j, jmax, js, k2, n1p1,
     &                   n2, nj, pj
      real               c, eps, s, t, tau, tol
      integer            isamax
      real               slamch, slapy2
      end subroutine slaed2

      !! slaed3.f
      subroutine slaed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,
     &                   ctot, w, s, info )
      integer            info, k, ldq, n, n1
      real               rho
      integer            ctot( * ), indx( * )
      real               d( * ), dlamda( * ), q( ldq, * ), q2( * ),
     &                   s( * ), w( * )
      real               one, zero
      parameter          ( one = 1.0e0, zero = 0.0e0 )
      integer            i, ii, iq2, j, n12, n2, n23
      real               temp
      real               slamc3, snrm2
      end subroutine slaed3

      !! slaed4.f
      subroutine slaed4( n, i, d, z, delta, rho, dlam, info )
      integer            i, info, n
      real               dlam, rho
      real               d( * ), delta( * ), z( * )
      integer            maxit
      parameter          ( maxit = 30 )
      real               zero, one, two, three, four, eight, ten
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   three = 3.0e0, four = 4.0e0, eight = 8.0e0,
     &                   ten = 10.0e0 )
      logical            orgati, swtch, swtch3
      integer            ii, iim1, iip1, ip1, iter, j, niter
      real               a, b, c, del, dltlb, dltub, dphi, dpsi, dw,
     &                   eps, erretm, eta, midpt, phi, prew, psi,
     &                   rhoinv, tau, temp, temp1, w
      real               zz( 3 )
      real               slamch
      end subroutine slaed4

      !! slaed5.f
      subroutine slaed5( i, d, z, delta, rho, dlam )
      integer            i
      real               dlam, rho
      real               d( 2 ), delta( 2 ), z( 2 )
      real               zero, one, two, four
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   four = 4.0e0 )
      real               b, c, del, tau, temp, w
      end subroutine slaed5

      !! slaed6.f
      subroutine slaed6( kniter, orgati, rho, d, z, finit, tau, info )
      logical            orgati
      integer            info, kniter
      real               finit, rho, tau
      real               d( 3 ), z( 3 )
      integer            maxit
      parameter          ( maxit = 40 )
      real               zero, one, two, three, four, eight
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   three = 3.0e0, four = 4.0e0, eight = 8.0e0 )
      real               slamch
      real               dscale( 3 ), zscale( 3 )
      logical            scale
      integer            i, iter, niter
      real               a, b, base, c, ddf, df, eps, erretm, eta, f,
     &                   fc, sclfac, sclinv, small1, small2, sminv1,
     &                   sminv2, temp, temp1, temp2, temp3, temp4,
     &                   lbd, ubd
      end subroutine slaed6

      !! slaed7.f
      subroutine slaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,
     &                   ldq, indxq, rho, cutpnt, qstore, qptr, prmptr,
     &                   perm, givptr, givcol, givnum, work, iwork,
     &                   info )
      integer            curlvl, curpbm, cutpnt, icompq, info, ldq, n,
     &                   qsiz, tlvls
      real               rho
      integer            givcol( 2, * ), givptr( * ), indxq( * ),
     &                   iwork( * ), perm( * ), prmptr( * ), qptr( * )
      real               d( * ), givnum( 2, * ), q( ldq, * ),
     &                   qstore( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e0, zero = 0.0e0 )
      integer            coltyp, curr, i, idlmda, indx, indxc, indxp,
     &                   iq2, is, iw, iz, k, ldq2, n1, n2, ptr
      end subroutine slaed7

      !! slaed8.f
      subroutine slaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,
     &                   cutpnt, z, dlamda, q2, ldq2, w, perm, givptr,
     &                   givcol, givnum, indxp, indx, info )
      integer            cutpnt, givptr, icompq, info, k, ldq, ldq2, n,
     &                   qsiz
      real               rho
      integer            givcol( 2, * ), indx( * ), indxp( * ),
     &                   indxq( * ), perm( * )
      real               d( * ), dlamda( * ), givnum( 2, * ),
     &                   q( ldq, * ), q2( ldq2, * ), w( * ), z( * )
      real               mone, zero, one, two, eight
      parameter          ( mone = -1.0e0, zero = 0.0e0, one = 1.0e0,
     &                   two = 2.0e0, eight = 8.0e0 )
      integer            i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
      real               c, eps, s, t, tau, tol
      integer            isamax
      real               slamch, slapy2
      end subroutine slaed8

      !! slaed9.f
      subroutine slaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,
     &                   s, lds, info )
      integer            info, k, kstart, kstop, ldq, lds, n
      real               rho
      real               d( * ), dlamda( * ), q( ldq, * ), s( lds, * ),
     &                   w( * )
      integer            i, j
      real               temp
      real               slamc3, snrm2
      end subroutine slaed9

      !! slaeda.f
      subroutine slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,
     &                   givcol, givnum, q, qptr, z, ztemp, info )
      integer            curlvl, curpbm, info, n, tlvls
      integer            givcol( 2, * ), givptr( * ), perm( * ),
     &                   prmptr( * ), qptr( * )
      real               givnum( 2, * ), q( * ), z( * ), ztemp( * )
      real               zero, half, one
      parameter          ( zero = 0.0e0, half = 0.5e0, one = 1.0e0 )
      integer            bsiz1, bsiz2, curr, i, k, mid, psiz1, psiz2,
     &                   ptr, zptr1
      end subroutine slaeda

      !! slaein.f
      subroutine slaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,
     &                   ldb, work, eps3, smlnum, bignum, info )
      logical            noinit, rightv
      integer            info, ldb, ldh, n
      real               bignum, eps3, smlnum, wi, wr
      real               b( ldb, * ), h( ldh, * ), vi( * ), vr( * ),
     &                   work( * )
      real               zero, one, tenth
      parameter          ( zero = 0.0e+0, one = 1.0e+0, tenth = 1.0e-1 )
      character          normin, trans
      integer            i, i1, i2, i3, ierr, its, j
      real               absbii, absbjj, ei, ej, growto, norm, nrmsml,
     &                   rec, rootn, scale, temp, vcrit, vmax, vnorm, w,
     &                   w1, x, xi, xr, y
      integer            isamax
      real               sasum, slapy2, snrm2
      end subroutine slaein

      !! slaev2.f
      subroutine slaev2( a, b, c, rt1, rt2, cs1, sn1 )
      real               a, b, c, cs1, rt1, rt2, sn1
      real               one
      parameter          ( one = 1.0e0 )
      real               two
      parameter          ( two = 2.0e0 )
      real               zero
      parameter          ( zero = 0.0e0 )
      real               half
      parameter          ( half = 0.5e0 )
      integer            sgn1, sgn2
      real               ab, acmn, acmx, acs, adf, cs, ct, df, rt, sm,
     &                   tb, tn
      end subroutine slaev2

      !! slaexc.f
      subroutine slaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,
     &                   info )
      logical            wantq
      integer            info, j1, ldq, ldt, n, n1, n2
      real               q( ldq, * ), t( ldt, * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               ten
      parameter          ( ten = 1.0e+1 )
      integer            ldd, ldx
      parameter          ( ldd = 4, ldx = 2 )
      integer            ierr, j2, j3, j4, k, nd
      real               cs, dnorm, eps, scale, smlnum, sn, t11, t22,
     &                   t33, tau, tau1, tau2, temp, thresh, wi1, wi2,
     &                   wr1, wr2, xnorm
      real               d( ldd, 4 ), u( 3 ), u1( 3 ), u2( 3 ),
     &                   x( ldx, 2 )
      real               slamch, slange
      end subroutine slaexc

      !! slag2d.f
      subroutine slag2d( m, n, sa, ldsa, a, lda, info )
      integer            info, lda, ldsa, m, n
      real               sa( ldsa, * )
      double precision   a( lda, * )
      integer            i, j
      end subroutine slag2d

      !! slag2.f
      subroutine slag2( a, lda, b, ldb, safmin, scale1, scale2, wr1,
     &                  wr2, wi )
      integer            lda, ldb
      real               safmin, scale1, scale2, wi, wr1, wr2
      real               a( lda, * ), b( ldb, * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      real               half
      parameter          ( half = one / two )
      real               fuzzy1
      parameter          ( fuzzy1 = one+1.0e-5 )
      real               a11, a12, a21, a22, abi22, anorm, as11, as12,
     &                   as22, ascale, b11, b12, b22, binv11, binv22,
     &                   bmin, bnorm, bscale, bsize, c1, c2, c3, c4, c5,
     &                   diff, discr, pp, qq, r, rtmax, rtmin, s1, s2,
     &                   safmax, shift, ss, sum, wabs, wbig, wdet,
     &                   wscale, wsize, wsmall
      end subroutine slag2

      !! sla_gbamv.f
      subroutine sla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,
     &                      incx, beta, y, incy )
      real               alpha, beta
      integer            incx, incy, ldab, m, n, kl, ku, trans
      real               ab( ldab, * ), x( * ), y( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            symb_zero
      real               temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny, kd, ke
      real               slamch
      integer            ilatrans
      end subroutine sla_gbamv

      !! sla_gbrcond.f
      real function sla_gbrcond( trans, n, kl, ku, ab, ldab, afb, ldafb,
     &                           ipiv, cmode, c, info, work, iwork )
      character          trans
      integer            n, ldab, ldafb, info, kl, ku, cmode
      integer            iwork( * ), ipiv( * )
      real               ab( ldab, * ), afb( ldafb, * ), work( * ),
     &                   c( * )
      logical            notrans
      integer            kase, i, j, kd, ke
      real               ainvnm, tmp
      integer            isave( 3 )
      logical            lsame
      end function sla_gbrcond

      !! sla_gbrfsx_extended.f
      subroutine sla_gbrfsx_extended( prec_type, trans_type, n, kl, ku,
     &                                nrhs, ab, ldab, afb, ldafb, ipiv,
     &                                colequ, c, b, ldb, y, ldy,
     &                                berr_out, n_norms, err_bnds_norm,
     &                                err_bnds_comp, res, ayb, dy,
     &                                y_tail, rcond, ithresh, rthresh,
     &                                dz_ub, ignore_cwise, info )
      integer            info, ldab, ldafb, ldb, ldy, n, kl, ku, nrhs,
     &                   prec_type, trans_type, n_norms, ithresh
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      integer            ipiv( * )
      real               ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   y( ldy, * ), res(*), dy(*), y_tail(*)
      real               c( * ), ayb(*), rcond, berr_out(*),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      character          trans
      integer            cnt, i, j, m, x_state, z_state, y_prec_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      real               slamch
      character          chla_transtype
      end subroutine sla_gbrfsx_extended

      !! sla_gbrpvgrw.f
      real function sla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,
     &                            ldafb )
      integer            n, kl, ku, ncols, ldab, ldafb
      real               ab( ldab, * ), afb( ldafb, * )
      integer            i, j, kd
      real               amax, umax, rpvgrw
      end function sla_gbrpvgrw

      !! sla_geamv.f
      subroutine sla_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,
     &                       y, incy )
      real               alpha, beta
      integer            incx, incy, lda, m, n, trans
      real               a( lda, * ), x( * ), y( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            symb_zero
      real               temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny
      real               slamch
      integer            ilatrans
      end subroutine sla_geamv

      !! sla_gercond.f
      real function sla_gercond ( trans, n, a, lda, af, ldaf, ipiv,
     &                            cmode, c, info, work, iwork )
      character          trans
      integer            n, lda, ldaf, info, cmode
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), work( * ),
     &                   c( * )
      logical            notrans
      integer            kase, i, j
      real               ainvnm, tmp
      integer            isave( 3 )
      logical            lsame
      end function sla_gercond

      !! sla_gerfsx_extended.f
      subroutine sla_gerfsx_extended( prec_type, trans_type, n, nrhs, a,
     &                                lda, af, ldaf, ipiv, colequ, c, b,
     &                                ldb, y, ldy, berr_out, n_norms,
     &                                errs_n, errs_c, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   trans_type, n_norms, ithresh
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      integer            ipiv( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb( * ), rcond, berr_out( * ),
     &                   errs_n( nrhs, * ),
     &                   errs_c( nrhs, * )
      character          trans
      integer            cnt, i, j, x_state, z_state, y_prec_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      real               slamch
      character          chla_transtype
      end subroutine sla_gerfsx_extended

      !! sla_gerpvgrw.f
      real function sla_gerpvgrw( n, ncols, a, lda, af, ldaf )
      integer            n, ncols, lda, ldaf
      real               a( lda, * ), af( ldaf, * )
      integer            i, j
      real               amax, umax, rpvgrw
      end function sla_gerpvgrw

      !! slags2.f
      subroutine slags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,
     &                   snv, csq, snq )
      logical            upper
      real               a1, a2, a3, b1, b2, b3, csq, csu, csv, snq,
     &                   snu, snv
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               a, aua11, aua12, aua21, aua22, avb11, avb12,
     &                   avb21, avb22, csl, csr, d, s1, s2, snl,
     &                   snr, ua11r, ua22r, vb11r, vb22r, b, c, r, ua11,
     &                   ua12, ua21, ua22, vb11, vb12, vb21, vb22
      end subroutine slags2

      !! slagtf.f
      subroutine slagtf( n, a, lambda, b, c, tol, d, in, info )
      integer            info, n
      real               lambda, tol
      integer            in( * )
      real               a( * ), b( * ), c( * ), d( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            k
      real               eps, mult, piv1, piv2, scale1, scale2, temp, tl
      real               slamch
      end subroutine slagtf

      !! slagtm.f
      subroutine slagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,
     &                   b, ldb )
      character          trans
      integer            ldb, ldx, n, nrhs
      real               alpha, beta
      real               b( ldb, * ), d( * ), dl( * ), du( * ),
     &                   x( ldx, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      logical            lsame
      end subroutine slagtm

      !! slagts.f
      subroutine slagts( job, n, a, b, c, d, in, y, tol, info )
      integer            info, job, n
      real               tol
      integer            in( * )
      real               a( * ), b( * ), c( * ), d( * ), y( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            k
      real               absak, ak, bignum, eps, pert, sfmin, temp
      real               slamch
      end subroutine slagts

      !! slagv2.f
      subroutine slagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,
     &                   csr, snr )
      integer            lda, ldb
      real               csl, csr, snl, snr
      real               a( lda, * ), alphai( 2 ), alphar( 2 ),
     &                   b( ldb, * ), beta( 2 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               anorm, ascale, bnorm, bscale, h1, h2, h3, qq,
     &                   r, rr, safmin, scale1, scale2, t, ulp, wi, wr1,
     &                   wr2
      real               slamch, slapy2
      end subroutine slagv2

      !! slahqr.f
      subroutine slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,
     &                   iloz, ihiz, z, ldz, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, n
      logical            wantt, wantz
      real               h( ldh, * ), wi( * ), wr( * ), z( ldz, * )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      real               dat1, dat2
      parameter          ( dat1 = 3.0e0 / 4.0e0, dat2 = -0.4375e0 )
      real               aa, ab, ba, bb, cs, det, h11, h12, h21, h21s,
     &                   h22, rt1i, rt1r, rt2i, rt2r, rtdisc, s, safmax,
     &                   safmin, smlnum, sn, sum, t1, t2, t3, tr, tst,
     &                   ulp, v2, v3
      integer            i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz
      real               v( 3 )
      real               slamch
      end subroutine slahqr

      !! slahr2.f
      subroutine slahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
      integer            k, lda, ldt, ldy, n, nb
      real              a( lda, * ), t( ldt, nb ), tau( nb ),
     &                   y( ldy, nb )
      real              zero, one
      parameter          ( zero = 0.0e+0,
     &                     one = 1.0e+0 )
      integer            i
      real              ei
      end subroutine slahr2

      !! slaic1.f
      subroutine slaic1( job, j, x, sest, w, gamma, sestpr, s, c )
      integer            j, job
      real               c, gamma, s, sest, sestpr
      real               w( j ), x( j )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      real               half, four
      parameter          ( half = 0.5e0, four = 4.0e0 )
      real               absalp, absest, absgam, alpha, b, cosine, eps,
     &                   norma, s1, s2, sine, t, test, tmp, zeta1, zeta2
      real               sdot, slamch
      end subroutine slaic1

      !! slaisnan.f
      logical function slaisnan( sin1, sin2 )
      real               sin1, sin2
      end function slaisnan

      !! sla_lin_berr.f
      subroutine sla_lin_berr ( n, nz, nrhs, res, ayb, berr )
      integer            n, nz, nrhs
      real               ayb( n, nrhs ), berr( nrhs )
      real               res( n, nrhs )
      real               tmp
      integer            i, j
      real               slamch
      real               safe1
      end subroutine sla_lin_berr

      !! slaln2.f
      subroutine slaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,
     &                   ldb, wr, wi, x, ldx, scale, xnorm, info )
      logical            ltrans
      integer            info, lda, ldb, ldx, na, nw
      real               ca, d1, d2, scale, smin, wi, wr, xnorm
      real               a( lda, * ), b( ldb, * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      real               two
      parameter          ( two = 2.0e0 )
      integer            icmax, j
      real               bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21,
     &                   ci22, cmax, cnorm, cr21, cr22, csi, csr, li21,
     &                   lr21, smini, smlnum, temp, u22abs, ui11, ui11r,
     &                   ui12, ui12s, ui22, ur11, ur11r, ur12, ur12s,
     &                   ur22, xi1, xi2, xr1, xr2
      logical            cswap( 4 ), rswap( 4 )
      integer            ipivot( 4, 4 )
      real               ci( 2, 2 ), civ( 4 ), cr( 2, 2 ), crv( 4 )
      real               slamch
      end subroutine slaln2

      !! slals0.f
      subroutine slals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,
     &                   perm, givptr, givcol, ldgcol, givnum, ldgnum,
     &                   poles, difl, difr, z, k, c, s, work, info )
      integer            givptr, icompq, info, k, ldb, ldbx, ldgcol,
     &                   ldgnum, nl, nr, nrhs, sqre
      real               c, s
      integer            givcol( ldgcol, * ), perm( * )
      real               b( ldb, * ), bx( ldbx, * ), difl( * ),
     &                   difr( ldgnum, * ), givnum( ldgnum, * ),
     &                   poles( ldgnum, * ), work( * ), z( * )
      real               one, zero, negone
      parameter          ( one = 1.0e0, zero = 0.0e0, negone = -1.0e0 )
      integer            i, j, m, n, nlp1
      real               diflj, difrj, dj, dsigj, dsigjp, temp
      real               slamc3, snrm2
      end subroutine slals0

      !! slalsa.f
      subroutine slalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,
     &                   ldu, vt, k, difl, difr, z, poles, givptr,
     &                   givcol, ldgcol, perm, givnum, c, s, work,
     &                   iwork, info )
      integer            icompq, info, ldb, ldbx, ldgcol, ldu, n, nrhs,
     &                   smlsiz
      integer            givcol( ldgcol, * ), givptr( * ), iwork( * ),
     &                   k( * ), perm( ldgcol, * )
      real               b( ldb, * ), bx( ldbx, * ), c( * ),
     &                   difl( ldu, * ), difr( ldu, * ),
     &                   givnum( ldu, * ), poles( ldu, * ), s( * ),
     &                   u( ldu, * ), vt( ldu, * ), work( * ),
     &                   z( ldu, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      integer            i, i1, ic, im1, inode, j, lf, ll, lvl, lvl2,
     &                   nd, ndb1, ndiml, ndimr, nl, nlf, nlp1, nlvl,
     &                   nr, nrf, nrp1, sqre
      end subroutine slalsa

      !! slalsd.f
      subroutine slalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,
     &                   rank, work, iwork, info )
      character          uplo
      integer            info, ldb, n, nrhs, rank, smlsiz
      real               rcond
      integer            iwork( * )
      real               b( ldb, * ), d( * ), e( * ), work( * )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      integer            bx, bxst, c, difl, difr, givcol, givnum,
     &                   givptr, i, icmpq1, icmpq2, iwk, j, k, nlvl,
     &                   nm1, nsize, nsub, nwork, perm, poles, s, sizei,
     &                   smlszp, sqre, st, st1, u, vt, z
      real               cs, eps, orgnrm, r, rcnd, sn, tol
      integer            isamax
      real               slamch, slanst
      end subroutine slalsd

      !! slamrg.f
      subroutine slamrg( n1, n2, a, strd1, strd2, index )
      integer            n1, n2, strd1, strd2
      integer            index( * )
      real               a( * )
      integer            i, ind1, ind2, n1sv, n2sv
      end subroutine slamrg

      !! slaneg.f
      integer function slaneg( n, d, lld, sigma, pivmin, r )
      integer            n, r
      real               pivmin, sigma
      real               d( * ), lld( * )
      real               zero, one
      parameter        ( zero = 0.0e0, one = 1.0e0 )
      integer blklen
      parameter ( blklen = 128 )
      integer            bj, j, neg1, neg2, negcnt
      real               bsav, dminus, dplus, gamma, p, t, tmp
      logical sawnan
      logical sisnan
      end function slaneg

      !! slangb.f
      real             function slangb( norm, n, kl, ku, ab, ldab,
     &                 work )
      character          norm
      integer            kl, ku, ldab, n
      real               ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, k, l
      real               scale, sum, value, temp
      logical            lsame, sisnan
      end function slangb

      !! slange.f
      real             function slange( norm, m, n, a, lda, work )
      character          norm
      integer            lda, m, n
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               scale, sum, value, temp
      logical            lsame, sisnan
      end function slange

      !! slangt.f
      real             function slangt( norm, n, dl, d, du )
      character          norm
      integer            n
      real               d( * ), dl( * ), du( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i
      real               anorm, scale, sum, temp
      logical            lsame, sisnan
      end function slangt

      !! slanhs.f
      real             function slanhs( norm, n, a, lda, work )
      character          norm
      integer            lda, n
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               scale, sum, value
      logical            lsame, sisnan
      end function slanhs

      !! slansb.f
      real             function slansb( norm, uplo, n, k, ab, ldab,
     &                 work )
      character          norm, uplo
      integer            k, ldab, n
      real               ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, l
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function slansb

      !! slansf.f
      real function slansf( norm, transr, uplo, n, a, work )
      character          norm, transr, uplo
      integer            n
      real               a( 0: * ), work( 0: * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, ifm, ilu, noe, n1, k, l, lda
      real               scale, s, value, aa, temp
      logical            lsame, sisnan
      end function slansf

      !! slansp.f
      real             function slansp( norm, uplo, n, ap, work )
      character          norm, uplo
      integer            n
      real               ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, k
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function slansp

      !! slanst.f
      real             function slanst( norm, n, d, e )
      character          norm
      integer            n
      real               d( * ), e( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i
      real               anorm, scale, sum
      logical            lsame, sisnan
      end function slanst

      !! slansy.f
      real             function slansy( norm, uplo, n, a, lda, work )
      character          norm, uplo
      integer            lda, n
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j
      real               absa, scale, sum, value
      logical            lsame, sisnan
      end function slansy

      !! slantb.f
      real             function slantb( norm, uplo, diag, n, k, ab,
     &                 ldab, work )
      character          diag, norm, uplo
      integer            k, ldab, n
      real               ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            udiag
      integer            i, j, l
      real               scale, sum, value
      logical            lsame, sisnan
      end function slantb

      !! slantp.f
      real             function slantp( norm, uplo, diag, n, ap, work )
      character          diag, norm, uplo
      integer            n
      real               ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            udiag
      integer            i, j, k
      real               scale, sum, value
      logical            lsame, sisnan
      end function slantp

      !! slantr.f
      real             function slantr( norm, uplo, diag, m, n, a, lda,
     &                 work )
      character          diag, norm, uplo
      integer            lda, m, n
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            udiag
      integer            i, j
      real               scale, sum, value
      logical            lsame, sisnan
      end function slantr

      !! slanv2.f
      subroutine slanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
      real               a, b, c, cs, d, rt1i, rt1r, rt2i, rt2r, sn
      real               zero, half, one
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0 )
      real               multpl
      parameter          ( multpl = 4.0e+0 )
      real               aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab,
     &                   sac, scale, sigma, sn1, tau, temp, z
      real               slamch, slapy2
      end subroutine slanv2

      !! slapll.f
      subroutine slapll( n, x, incx, y, incy, ssmin )
      integer            incx, incy, n
      real               ssmin
      real               x( * ), y( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               a11, a12, a22, c, ssmax, tau
      real               sdot
      end subroutine slapll

      !! slapmr.f
      subroutine slapmr( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      real               x( ldx, * )
      integer            i, in, j, jj
      real               temp
      end subroutine slapmr

      !! slapmt.f
      subroutine slapmt( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      real               x( ldx, * )
      integer            i, ii, j, in
      real               temp
      end subroutine slapmt

      !! sla_porcond.f
      real function sla_porcond( uplo, n, a, lda, af, ldaf, cmode, c,
     &                           info, work, iwork )
      character          uplo
      integer            n, lda, ldaf, info, cmode
      real               a( lda, * ), af( ldaf, * ), work( * ),
     &                   c( * )
      integer            iwork( * )
      integer            kase, i, j
      real               ainvnm, tmp
      logical            up
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      end function sla_porcond

      !! sla_porfsx_extended.f
      subroutine sla_porfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, colequ, c, b, ldb, y,
     &                                ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb(*), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      integer           unstable_state, working_state, conv_state,
     &                  noprog_state, y_prec_state, base_residual,
     &                  extra_residual, extra_y
      parameter         ( unstable_state = 0, working_state = 1,
     &                  conv_state = 2, noprog_state = 3 )
      parameter         ( base_residual = 0, extra_residual = 1,
     &                  extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      real              slamch
      end subroutine sla_porfsx_extended

      !! sla_porpvgrw.f
      real function sla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
      character(len=1)   uplo
      integer            ncols, lda, ldaf
      real               a( lda, * ), af( ldaf, * ), work( * )
      integer            i, j
      real               amax, umax, rpvgrw
      logical            upper
      logical            lsame
      end function sla_porpvgrw

      !! slapy2.f
      real             function slapy2( x, y )
      real               x, y
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               w, xabs, yabs, z
      end function slapy2

      !! slapy3.f
      real             function slapy3( x, y, z )
      real               x, y, z
      real               zero
      parameter          ( zero = 0.0e0 )
      real               w, xabs, yabs, zabs
      end function slapy3

      !! slaqgb.f
      subroutine slaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, equed )
      character          equed
      integer            kl, ku, ldab, m, n
      real               amax, colcnd, rowcnd
      real               ab( ldab, * ), c( * ), r( * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      real               slamch
      end subroutine slaqgb

      !! slaqge.f
      subroutine slaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   equed )
      character          equed
      integer            lda, m, n
      real               amax, colcnd, rowcnd
      real               a( lda, * ), c( * ), r( * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      real               slamch
      end subroutine slaqge

      !! slaqp2.f
      subroutine slaqp2( m, n, offset, a, lda, jpvt, tau, vn1, vn2,
     &                   work )
      integer            lda, m, n, offset
      integer            jpvt( * )
      real               a( lda, * ), tau( * ), vn1( * ), vn2( * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i, itemp, j, mn, offpi, pvt
      real               aii, temp, temp2, tol3z
      integer            isamax
      real               slamch, snrm2
      end subroutine slaqp2

      !! slaqps.f
      subroutine slaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,
     &                   vn2, auxv, f, ldf )
      integer            kb, lda, ldf, m, n, nb, offset
      integer            jpvt( * )
      real               a( lda, * ), auxv( * ), f( ldf, * ), tau( * ),
     &                   vn1( * ), vn2( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            itemp, j, k, lastrk, lsticc, pvt, rk
      real               akk, temp, temp2, tol3z
      integer            isamax
      real               slamch, snrm2
      end subroutine slaqps

      !! slaqr0.f
      subroutine slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,
     &                   iloz, ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      real               h( ldh, * ), wi( * ), work( * ), wr( * ),
     &                   z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      real               wilk1, wilk2
      parameter          ( wilk1 = 0.75e0, wilk2 = -0.4375e0 )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      real               aa, bb, cc, cs, dd, sn, ss, swap
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      real               zdum( 1, 1 )
      end subroutine slaqr0

      !! slaqr1.f
      subroutine slaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
      real               si1, si2, sr1, sr2
      integer            ldh, n
      real               h( ldh, * ), v( * )
      real               zero
      parameter          ( zero = 0.0e0 )
      real               h21s, h31s, s
      end subroutine slaqr1

      !! slaqr2.f
      subroutine slaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t,
     &                   ldt, nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      real               h( ldh, * ), si( * ), sr( * ), t( ldt, * ),
     &                   v( ldv, * ), work( * ), wv( ldwv, * ),
     &                   z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      real               aa, bb, beta, cc, cs, dd, evi, evk, foo, s,
     &                   safmax, safmin, smlnum, sn, tau, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, k, kcol,
     &                   kend, kln, krow, kwtop, ltop, lwk1, lwk2,
     &                   lwkopt
      logical            bulge, sorted
      real               slamch
      end subroutine slaqr2

      !! slaqr3.f
      subroutine slaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sr, si, v, ldv, nh, t,
     &                   ldt, nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      real               h( ldh, * ), si( * ), sr( * ), t( ldt, * ),
     &                   v( ldv, * ), work( * ), wv( ldwv, * ),
     &                   z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      real               aa, bb, beta, cc, cs, dd, evi, evk, foo, s,
     &                   safmax, safmin, smlnum, sn, tau, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, k, kcol,
     &                   kend, kln, krow, kwtop, ltop, lwk1, lwk2, lwk3,
     &                   lwkopt, nmin
      logical            bulge, sorted
      real               slamch
      integer            ilaenv
      end subroutine slaqr3

      !! slaqr4.f
      subroutine slaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,
     &                   iloz, ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      real               h( ldh, * ), wi( * ), work( * ), wr( * ),
     &                   z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      real               wilk1, wilk2
      parameter          ( wilk1 = 0.75e0, wilk2 = -0.4375e0 )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      real               aa, bb, cc, cs, dd, sn, ss, swap
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      real               zdum( 1, 1 )
      end subroutine slaqr4

      !! slaqr5.f
      subroutine slaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,
     &                   sr, si, h, ldh, iloz, ihiz, z, ldz, v, ldv, u,
     &                   ldu, nv, wv, ldwv, nh, wh, ldwh )
      integer            ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv,
     &                   ldwh, ldwv, ldz, n, nh, nshfts, nv
      logical            wantt, wantz
      real               h( ldh, * ), si( * ), sr( * ), u( ldu, * ),
     &                   v( ldv, * ), wh( ldwh, * ), wv( ldwv, * ),
     &                   z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      real               alpha, beta, h11, h12, h21, h22, refsum,
     &                   safmax, safmin, scl, smlnum, swap, tst1, tst2,
     &                   ulp
      integer            i, i2, i4, incol, j, j2, j4, jbot, jcol, jlen,
     &                   jrow, jtop, k, k1, kdu, kms, knz, krcol, kzs,
     &                   m, m22, mbot, mend, mstart, mtop, nbmps, ndcol,
     &                   ns, nu
      logical            accum, blk22, bmp22
      real               slamch
      real               vt( 3 )
      end subroutine slaqr5

      !! slaqsb.f
      subroutine slaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
      character          equed, uplo
      integer            kd, ldab, n
      real               amax, scond
      real               ab( ldab, * ), s( * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine slaqsb

      !! slaqsp.f
      subroutine slaqsp( uplo, n, ap, s, scond, amax, equed )
      character          equed, uplo
      integer            n
      real               amax, scond
      real               ap( * ), s( * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j, jc
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine slaqsp

      !! slaqsy.f
      subroutine slaqsy( uplo, n, a, lda, s, scond, amax, equed )
      character          equed, uplo
      integer            lda, n
      real               amax, scond
      real               a( lda, * ), s( * )
      real               one, thresh
      parameter          ( one = 1.0e+0, thresh = 0.1e+0 )
      integer            i, j
      real               cj, large, small
      logical            lsame
      real               slamch
      end subroutine slaqsy

      !! slaqtr.f
      subroutine slaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,
     &                   info )
      logical            lreal, ltran
      integer            info, ldt, n
      real               scale, w
      real               b( * ), t( ldt, * ), work( * ), x( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            notran
      integer            i, ierr, j, j1, j2, jnext, k, n1, n2
      real               bignum, eps, rec, scaloc, si, smin, sminw,
     &                   smlnum, sr, tjj, tmp, xj, xmax, xnorm, z
      real               d( 2, 2 ), v( 2, 2 )
      integer            isamax
      real               sasum, sdot, slamch, slange
      end subroutine slaqtr

      !! slar1v.f
      subroutine slar1v( n, b1, bn, lambda, d, l, ld, lld,
     &           pivmin, gaptol, z, wantnc, negcnt, ztz, mingma,
     &           r, isuppz, nrminv, resid, rqcorr, work )
      logical            wantnc
      integer   b1, bn, n, negcnt, r
      real               gaptol, lambda, mingma, nrminv, pivmin, resid,
     &                   rqcorr, ztz
      integer            isuppz( * )
      real               d( * ), l( * ), ld( * ), lld( * ),
     &                  work( * )
      real             z( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            sawnan1, sawnan2
      integer            i, indlpl, indp, inds, indumn, neg1, neg2, r1,
     &                   r2
      real               dminus, dplus, eps, s, tmp
      logical sisnan
      real               slamch
      end subroutine slar1v

      !! slar2v.f
      subroutine slar2v( n, x, y, z, incx, c, s, incc )
      integer            incc, incx, n
      real               c( * ), s( * ), x( * ), y( * ), z( * )
      integer            i, ic, ix
      real               ci, si, t1, t2, t3, t4, t5, t6, xi, yi, zi
      end subroutine slar2v

      !! slarfb.f
      subroutine slarfb( side, trans, direct, storev, m, n, k, v, ldv,
     &                   t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, ldc, ldt, ldv, ldwork, m, n
      real               c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      real               one
      parameter          ( one = 1.0e+0 )
      character          transt
      integer            i, j
      logical            lsame
      end subroutine slarfb

      !! slarf.f
      subroutine slarf( side, m, n, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, ldc, m, n
      real               tau
      real               c( ldc, * ), v( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            applyleft
      integer            i, lastv, lastc
      logical            lsame
      integer            ilaslr, ilaslc
      end subroutine slarf

      !! slarfg.f
      subroutine slarfg( n, alpha, x, incx, tau )
      integer            incx, n
      real               alpha, tau
      real               x( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            j, knt
      real               beta, rsafmn, safmin, xnorm
      real               slamch, slapy2, snrm2
      end subroutine slarfg

      !! slarfgp.f
      subroutine slarfgp( n, alpha, x, incx, tau )
      integer            incx, n
      real               alpha, tau
      real               x( * )
      real               two, one, zero
      parameter          ( two = 2.0e+0, one = 1.0e+0, zero = 0.0e+0 )
      integer            j, knt
      real               beta, bignum, savealpha, smlnum, xnorm
      real               slamch, slapy2, snrm2
      end subroutine slarfgp

      !! slarft.f
      subroutine slarft( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      real               t( ldt, * ), tau( * ), v( ldv, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, prevlastv, lastv
      logical            lsame
      end subroutine slarft

      !! slarfx.f
      subroutine slarfx( side, m, n, v, tau, c, ldc, work )
      character          side
      integer            ldc, m, n
      real               tau
      real               c( ldc, * ), v( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            j
      real               sum, t1, t10, t2, t3, t4, t5, t6, t7, t8, t9,
     &                   v1, v10, v2, v3, v4, v5, v6, v7, v8, v9
      logical            lsame
      end subroutine slarfx

      !! slargv.f
      subroutine slargv( n, x, incx, y, incy, c, incc )
      integer            incc, incx, incy, n
      real               c( * ), x( * ), y( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i, ic, ix, iy
      real               f, g, t, tt
      end subroutine slargv

      !! slarnv.f
      subroutine slarnv( idist, iseed, n, x )
      integer            idist, n
      integer            iseed( 4 )
      real               x( * )
      real               one, two
      parameter          ( one = 1.0e+0, two = 2.0e+0 )
      integer            lv
      parameter          ( lv = 128 )
      real               twopi
      parameter          ( twopi = 6.2831853071795864769252867663e+0 )
      integer            i, il, il2, iv
      real               u( lv )
      end subroutine slarnv

      !! slarra.f
      subroutine slarra( n, d, e, e2, spltol, tnrm,
     &                    nsplit, isplit, info )
      integer            info, n, nsplit
      real                spltol, tnrm
      integer            isplit( * )
      real               d( * ), e( * ), e2( * )
      real               zero
      parameter          ( zero = 0.0e0 )
      integer            i
      real               eabs, tmp1
      end subroutine slarra

      !! slarrb.f
      subroutine slarrb( n, d, lld, ifirst, ilast, rtol1,
     &                   rtol2, offset, w, wgap, werr, work, iwork,
     &                   pivmin, spdiam, twist, info )
      integer            ifirst, ilast, info, n, offset, twist
      real               pivmin, rtol1, rtol2, spdiam
      integer            iwork( * )
      real               d( * ), lld( * ), w( * ),
     &                   werr( * ), wgap( * ), work( * )
      real               zero, two, half
      parameter        ( zero = 0.0e0, two = 2.0e0,
     &                   half = 0.5e0 )
      integer   maxitr
      integer            i, i1, ii, ip, iter, k, negcnt, next, nint,
     &                   olnint, prev, r
      real               back, cvrgd, gap, left, lgap, mid, mnwdth,
     &                   rgap, right, tmp, width
      integer            slaneg
      end subroutine slarrb

      !! slarrc.f
      subroutine slarrc( jobt, n, vl, vu, d, e, pivmin,
     &                            eigcnt, lcnt, rcnt, info )
      character          jobt
      integer            eigcnt, info, lcnt, n, rcnt
      real               pivmin, vl, vu
      real               d( * ), e( * )
      real               zero
      parameter          ( zero = 0.0e0 )
      integer            i
      logical            matt
      real               lpivot, rpivot, sl, su, tmp, tmp2
      logical            lsame
      end subroutine slarrc

      !! slarrd.f
      subroutine slarrd( range, order, n, vl, vu, il, iu, gers,
     &                    reltol, d, e, e2, pivmin, nsplit, isplit,
     &                    m, w, werr, wl, wu, iblock, indexw,
     &                    work, iwork, info )
      character          order, range
      integer            il, info, iu, m, n, nsplit
      real                pivmin, reltol, vl, vu, wl, wu
      integer            iblock( * ), indexw( * ),
     &                   isplit( * ), iwork( * )
      real               d( * ), e( * ), e2( * ),
     &                   gers( * ), w( * ), werr( * ), work( * )
      real               zero, one, two, half, fudge
      parameter          ( zero = 0.0e0, one = 1.0e0,
     &                     two = 2.0e0, half = one/two,
     &                     fudge = two )
      integer   allrng, valrng, indrng
      parameter ( allrng = 1, valrng = 2, indrng = 3 )
      logical            ncnvrg, toofew
      integer            i, ib, ibegin, idiscl, idiscu, ie, iend, iinfo,
     &                   im, in, ioff, iout, irange, itmax, itmp1,
     &                   itmp2, iw, iwoff, j, jblk, jdisc, je, jee, nb,
     &                   nwl, nwu
      real               atoli, eps, gl, gu, rtoli, tmp1, tmp2,
     &                   tnorm, uflow, wkill, wlu, wul
      integer            idumma( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch
      end subroutine slarrd

      !! slarre.f
      subroutine slarre( range, n, vl, vu, il, iu, d, e, e2,
     &                    rtol1, rtol2, spltol, nsplit, isplit, m,
     &                    w, werr, wgap, iblock, indexw, gers, pivmin,
     &                    work, iwork, info )
      character          range
      integer            il, info, iu, m, n, nsplit
      real               pivmin, rtol1, rtol2, spltol, vl, vu
      integer            iblock( * ), isplit( * ), iwork( * ),
     &                   indexw( * )
      real               d( * ), e( * ), e2( * ), gers( * ),
     &                   w( * ),werr( * ), wgap( * ), work( * )
      real               fac, four, fourth, fudge, half, hndrd,
     &                   maxgrowth, one, pert, two, zero
      parameter          ( zero = 0.0e0, one = 1.0e0,
     &                     two = 2.0e0, four=4.0e0,
     &                     hndrd = 100.0e0,
     &                     pert = 4.0e0,
     &                     half = one/two, fourth = one/four, fac= half,
     &                     maxgrowth = 64.0e0, fudge = 2.0e0 )
      integer            maxtry, allrng, indrng, valrng
      parameter          ( maxtry = 6, allrng = 1, indrng = 2,
     &                     valrng = 3 )
      logical            forceb, norep, usedqd
      integer            cnt, cnt1, cnt2, i, ibegin, idum, iend, iinfo,
     &                   in, indl, indu, irange, j, jblk, mb, mm,
     &                   wbegin, wend
      real               avgap, bsrtol, clwdth, dmax, dpivot, eabs,
     &                   emax, eold, eps, gl, gu, isleft, isrght, rtl,
     &                   rtol, s1, s2, safmin, sgndef, sigma, spdiam,
     &                   tau, tmp, tmp1
      integer            iseed( 4 )
      logical            lsame
      real                        slamch
      end subroutine slarre

      !! slarrf.f
      subroutine slarrf( n, d, l, ld, clstrt, clend,
     &                   w, wgap, werr,
     &                   spdiam, clgapl, clgapr, pivmin, sigma,
     &                   dplus, lplus, work, info )
      integer            clstrt, clend, info, n
      real               clgapl, clgapr, pivmin, sigma, spdiam
      real               d( * ), dplus( * ), l( * ), ld( * ),
     &          lplus( * ), w( * ), wgap( * ), werr( * ), work( * )
      real               maxgrowth1, maxgrowth2, one, quart, two
      parameter          ( one = 1.0e0, two = 2.0e0,
     &                     quart = 0.25e0,
     &                     maxgrowth1 = 8.e0,
     &                     maxgrowth2 = 8.e0 )
      logical   dorrr1, forcer, nofail, sawnan1, sawnan2, tryrrr1
      integer            i, indx, ktry, ktrymax, sleft, sright, shift
      parameter          ( ktrymax = 1, sleft = 1, sright = 2 )
      real               avgap, bestshift, clwdth, eps, fact, fail,
     &                   fail2, growthbound, ldelta, ldmax, lsigma,
     &                   max1, max2, mingap, oldp, prod, rdelta, rdmax,
     &                   rrr1, rrr2, rsigma, s, smlgrowth, tmp, znm2
      logical sisnan
      real               slamch
      end subroutine slarrf

      !! slarrj.f
      subroutine slarrj( n, d, e2, ifirst, ilast,
     &                   rtol, offset, w, werr, work, iwork,
     &                   pivmin, spdiam, info )
      integer            ifirst, ilast, info, n, offset
      real               pivmin, rtol, spdiam
      integer            iwork( * )
      real               d( * ), e2( * ), w( * ),
     &                   werr( * ), work( * )
      real               zero, one, two, half
      parameter        ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   half = 0.5e0 )
      integer   maxitr
      integer            cnt, i, i1, i2, ii, iter, j, k, next, nint,
     &                   olnint, p, prev, savi1
      real               dplus, fac, left, mid, right, s, tmp, width
      end subroutine slarrj

      !! slarrk.f
      subroutine slarrk( n, iw, gl, gu,
     &                    d, e2, pivmin, reltol, w, werr, info)
      integer   info, iw, n
      real                pivmin, reltol, gl, gu, w, werr
      real               d( * ), e2( * )
      real               fudge, half, two, zero
      parameter          ( half = 0.5e0, two = 2.0e0,
     &                     fudge = two, zero = 0.0e0 )
      integer   i, it, itmax, negcnt
      real               atoli, eps, left, mid, right, rtoli, tmp1,
     &                   tmp2, tnorm
      real               slamch
      end subroutine slarrk

      !! slarrr.f
      subroutine slarrr( n, d, e, info )
      integer            n, info
      real               d( * ), e( * )
      real               zero, relcond
      parameter          ( zero = 0.0e0,
     &                     relcond = 0.999e0 )
      integer            i
      logical            yesrel
      real               eps, safmin, smlnum, rmin, tmp, tmp2,
     &          offdig, offdig2
      real               slamch
      end subroutine slarrr

      !! slarrv.f
      subroutine slarrv( n, vl, vu, d, l, pivmin,
     &                   isplit, m, dol, dou, minrgp,
     &                   rtol1, rtol2, w, werr, wgap,
     &                   iblock, indexw, gers, z, ldz, isuppz,
     &                   work, iwork, info )
      integer            dol, dou, info, ldz, m, n
      real               minrgp, pivmin, rtol1, rtol2, vl, vu
      integer            iblock( * ), indexw( * ), isplit( * ),
     &                   isuppz( * ), iwork( * )
      real               d( * ), gers( * ), l( * ), w( * ), werr( * ),
     &                   wgap( * ), work( * )
      real              z( ldz, * )
      integer            maxitr
      parameter          ( maxitr = 10 )
      real               zero, one, two, three, four, half
      parameter          ( zero = 0.0e0, one = 1.0e0,
     &                     two = 2.0e0, three = 3.0e0,
     &                     four = 4.0e0, half = 0.5e0)
      logical            eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
      integer            done, i, ibegin, idone, iend, ii, iindc1,
     &                   iindc2, iindr, iindwk, iinfo, im, in, indeig,
     &                   indld, indlld, indwrk, isupmn, isupmx, iter,
     &                   itmp1, j, jblk, k, miniwsize, minwsize, nclus,
     &                   ndepth, negcnt, newcls, newfst, newftt, newlst,
     &                   newsiz, offset, oldcls, oldfst, oldien, oldlst,
     &                   oldncl, p, parity, q, wbegin, wend, windex,
     &                   windmn, windpl, zfrom, zto, zusedl, zusedu,
     &                   zusedw
      real               bstres, bstw, eps, fudge, gap, gaptol, gl, gu,
     &                   lambda, left, lgap, mingma, nrminv, resid,
     &                   rgap, right, rqcorr, rqtol, savgap, sgndef,
     &                   sigma, spdiam, ssigma, tau, tmp, tol, ztz
      real              slamch
      end subroutine slarrv

      !! slarscl2.f
      subroutine slarscl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      real               d( * ), x( ldx, * )
      integer            i, j
      end subroutine slarscl2

      !! slartg.f
      subroutine slartg( f, g, cs, sn, r )
      real               cs, f, g, r, sn
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               two
      parameter          ( two = 2.0e0 )
      integer            count, i
      real               eps, f1, g1, safmin, safmn2, safmx2, scale
      real               slamch
      end subroutine slartg

      !! slartgp.f
      subroutine slartgp( f, g, cs, sn, r )
      real               cs, f, g, r, sn
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               two
      parameter          ( two = 2.0e0 )
      integer            count, i
      real               eps, f1, g1, safmin, safmn2, safmx2, scale
      real               slamch
      end subroutine slartgp

      !! slartgs.f
      subroutine slartgs( x, y, sigma, cs, sn )
      real                    cs, sigma, sn, x, y
      real                    negone, one, zero
      parameter          ( negone = -1.0e0, one = 1.0e0, zero = 0.0e0 )
      real                    r, s, thresh, w, z
      real                    slamch
      end subroutine slartgs

      !! slartv.f
      subroutine slartv( n, x, incx, y, incy, c, s, incc )
      integer            incc, incx, incy, n
      real               c( * ), s( * ), x( * ), y( * )
      integer            i, ic, ix, iy
      real               xi, yi
      end subroutine slartv

      !! slaruv.f
      subroutine slaruv( iseed, n, x )
      integer            n
      integer            iseed( 4 )
      real               x( n )
      real               one
      parameter          ( one = 1.0e0 )
      integer            lv, ipw2
      real               r
      parameter          ( lv = 128, ipw2 = 4096, r = one / ipw2 )
      integer            i, i1, i2, i3, i4, it1, it2, it3, it4, j
      integer            mm( lv, 4 )
      end subroutine slaruv

      !! slarzb.f
      subroutine slarzb( side, trans, direct, storev, m, n, k, l, v,
     &                   ldv, t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, l, ldc, ldt, ldv, ldwork, m, n
      real               c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      real               one
      parameter          ( one = 1.0e+0 )
      character          transt
      integer            i, info, j
      logical            lsame
      end subroutine slarzb

      !! slarz.f
      subroutine slarz( side, m, n, l, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, l, ldc, m, n
      real               tau
      real               c( ldc, * ), v( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            lsame
      end subroutine slarz

      !! slarzt.f
      subroutine slarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      real               t( ldt, * ), tau( * ), v( ldv, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            i, info, j
      logical            lsame
      end subroutine slarzt

      !! slas2.f
      subroutine slas2( f, g, h, ssmin, ssmax )
      real               f, g, h, ssmax, ssmin
      real               zero
      parameter          ( zero = 0.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               two
      parameter          ( two = 2.0e0 )
      real               as, at, au, c, fa, fhmn, fhmx, ga, ha
      end subroutine slas2

      !! slascl2.f
      subroutine slascl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      real               d( * ), x( ldx, * )
      integer            i, j
      end subroutine slascl2

      !! slascl.f
      subroutine slascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
      character          type
      integer            info, kl, ku, lda, m, n
      real               cfrom, cto
      real               a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            done
      integer            i, itype, j, k1, k2, k3, k4
      real               bignum, cfrom1, cfromc, cto1, ctoc, mul, smlnum
      logical            lsame, sisnan
      real               slamch
      end subroutine slascl

      !! slasd0.f
      subroutine slasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,
     &                   work, info )
      integer            info, ldu, ldvt, n, smlsiz, sqre
      integer            iwork( * )
      real               d( * ), e( * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      integer            i, i1, ic, idxq, idxqc, im1, inode, itemp, iwk,
     &                   j, lf, ll, lvl, m, ncc, nd, ndb1, ndiml, ndimr,
     &                   nl, nlf, nlp1, nlvl, nr, nrf, nrp1, sqrei
      real               alpha, beta
      end subroutine slasd0

      !! slasd1.f
      subroutine slasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,
     &                   idxq, iwork, work, info )
      integer            info, ldu, ldvt, nl, nr, sqre
      real               alpha, beta
      integer            idxq( * ), iwork( * )
      real               d( * ), u( ldu, * ), vt( ldvt, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            coltyp, i, idx, idxc, idxp, iq, isigma, iu2,
     &                   ivt2, iz, k, ldq, ldu2, ldvt2, m, n, n1, n2
      real               orgnrm
      end subroutine slasd1

      !! slasd2.f
      subroutine slasd2( nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt,
     &                   ldvt, dsigma, u2, ldu2, vt2, ldvt2, idxp, idx,
     &                   idxc, idxq, coltyp, info )
      integer            info, k, ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
      real               alpha, beta
      integer            coltyp( * ), idx( * ), idxc( * ), idxp( * ),
     &                   idxq( * )
      real               d( * ), dsigma( * ), u( ldu, * ),
     &                   u2( ldu2, * ), vt( ldvt, * ), vt2( ldvt2, * ),
     &                   z( * )
      real               zero, one, two, eight
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0,
     &                   eight = 8.0e+0 )
      integer            ctot( 4 ), psm( 4 )
      integer            ct, i, idxi, idxj, idxjp, j, jp, jprev, k2, m,
     &                   n, nlp1, nlp2
      real               c, eps, hlftol, s, tau, tol, z1
      real               slamch, slapy2
      end subroutine slasd2

      !! slasd3.f
      subroutine slasd3( nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2,
     &                   ldu2, vt, ldvt, vt2, ldvt2, idxc, ctot, z,
     &                   info )
      integer            info, k, ldq, ldu, ldu2, ldvt, ldvt2, nl, nr,
     &                   sqre
      integer            ctot( * ), idxc( * )
      real               d( * ), dsigma( * ), q( ldq, * ), u( ldu, * ),
     &                   u2( ldu2, * ), vt( ldvt, * ), vt2( ldvt2, * ),
     &                   z( * )
      real               one, zero, negone
      parameter          ( one = 1.0e+0, zero = 0.0e+0,
     &                     negone = -1.0e+0 )
      integer            ctemp, i, j, jc, ktemp, m, n, nlp1, nlp2, nrp1
      real               rho, temp
      real               slamc3, snrm2
      end subroutine slasd3

      !! slasd4.f
      subroutine slasd4( n, i, d, z, delta, rho, sigma, work, info )
      integer            i, info, n
      real   rho, sigma
      real   d( * ), delta( * ), work( * ), z( * )
      integer            maxit
      parameter          ( maxit = 400 )
      real               zero, one, two, three, four, eight, ten
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0,
     &                   three = 3.0e+0, four = 4.0e+0, eight = 8.0e+0,
     &                   ten = 10.0e+0 )
      logical            orgati, swtch, swtch3, geomavg
      integer            ii, iim1, iip1, ip1, iter, j, niter
      real               a, b, c, delsq, delsq2, sq2, dphi, dpsi, dtiim,
     &                   dtiip, dtipsq, dtisq, dtnsq, dtnsq1, dw, eps,
     &                   erretm, eta, phi, prew, psi, rhoinv, sglb,
     &                   sgub, tau, tau2, temp, temp1, temp2, w
      real               dd( 3 ), zz( 3 )
      real               slamch
      end subroutine slasd4

      !! slasd5.f
      subroutine slasd5( i, d, z, delta, rho, dsigma, work )
      integer            i
      real               dsigma, rho
      real               d( 2 ), delta( 2 ), work( 2 ), z( 2 )
      real               zero, one, two, three, four
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0,
     &                   three = 3.0e+0, four = 4.0e+0 )
      real               b, c, del, delsq, tau, w
      end subroutine slasd5

      !! slasd6.f
      subroutine slasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,
     &                   idxq, perm, givptr, givcol, ldgcol, givnum,
     &                   ldgnum, poles, difl, difr, z, k, c, s, work,
     &                   iwork, info )
      integer            givptr, icompq, info, k, ldgcol, ldgnum, nl,
     &                   nr, sqre
      real               alpha, beta, c, s
      integer            givcol( ldgcol, * ), idxq( * ), iwork( * ),
     &                   perm( * )
      real               d( * ), difl( * ), difr( * ),
     &                   givnum( ldgnum, * ), poles( ldgnum, * ),
     &                   vf( * ), vl( * ), work( * ), z( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, idx, idxc, idxp, isigma, ivfw, ivlw, iw, m,
     &                   n, n1, n2
      real               orgnrm
      end subroutine slasd6

      !! slasd7.f
      subroutine slasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,
     &                   vlw, alpha, beta, dsigma, idx, idxp, idxq,
     &                   perm, givptr, givcol, ldgcol, givnum, ldgnum,
     &                   c, s, info )
      integer            givptr, icompq, info, k, ldgcol, ldgnum, nl,
     &                   nr, sqre
      real               alpha, beta, c, s
      integer            givcol( ldgcol, * ), idx( * ), idxp( * ),
     &                   idxq( * ), perm( * )
      real               d( * ), dsigma( * ), givnum( ldgnum, * ),
     &                   vf( * ), vfw( * ), vl( * ), vlw( * ), z( * ),
     &                   zw( * )
      real               zero, one, two, eight
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0,
     &                   eight = 8.0e+0 )
      integer            i, idxi, idxj, idxjp, j, jp, jprev, k2, m, n,
     &                   nlp1, nlp2
      real               eps, hlftol, tau, tol, z1
      real               slamch, slapy2
      end subroutine slasd7

      !! slasd8.f
      subroutine slasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,
     &                   dsigma, work, info )
      integer            icompq, info, k, lddifr
      real               d( * ), difl( * ), difr( lddifr, * ),
     &                   dsigma( * ), vf( * ), vl( * ), work( * ),
     &                   z( * )
      real               one
      parameter          ( one = 1.0e+0 )
      integer            i, iwk1, iwk2, iwk2i, iwk3, iwk3i, j
      real               diflj, difrj, dj, dsigj, dsigjp, rho, temp
      real               sdot, slamc3, snrm2
      end subroutine slasd8

      !! slasda.f
      subroutine slasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,
     &                   difl, difr, z, poles, givptr, givcol, ldgcol,
     &                   perm, givnum, c, s, work, iwork, info )
      integer            icompq, info, ldgcol, ldu, n, smlsiz, sqre
      integer            givcol( ldgcol, * ), givptr( * ), iwork( * ),
     &                   k( * ), perm( ldgcol, * )
      real               c( * ), d( * ), difl( ldu, * ), difr( ldu, * ),
     &                   e( * ), givnum( ldu, * ), poles( ldu, * ),
     &                   s( * ), u( ldu, * ), vt( ldu, * ), work( * ),
     &                   z( ldu, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i, i1, ic, idxq, idxqi, im1, inode, itemp, iwk,
     &                   j, lf, ll, lvl, lvl2, m, ncc, nd, ndb1, ndiml,
     &                   ndimr, nl, nlf, nlp1, nlvl, nr, nrf, nrp1, nru,
     &                   nwork1, nwork2, smlszp, sqrei, vf, vfi, vl, vli
      real               alpha, beta
      end subroutine slasda

      !! slasdq.f
      subroutine slasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,
     &                   u, ldu, c, ldc, work, info )
      character          uplo
      integer            info, ldc, ldu, ldvt, n, ncc, ncvt, nru, sqre
      real               c( ldc, * ), d( * ), e( * ), u( ldu, * ),
     &                   vt( ldvt, * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            rotate
      integer            i, isub, iuplo, j, np1, sqre1
      real               cs, r, smin, sn
      logical            lsame
      end subroutine slasdq

      !! slasdt.f
      subroutine slasdt( n, lvl, nd, inode, ndiml, ndimr, msub )
      integer            lvl, msub, n, nd
      integer            inode( * ), ndiml( * ), ndimr( * )
      real               two
      parameter          ( two = 2.0e+0 )
      integer            i, il, ir, llst, maxn, ncrnt, nlvl
      real               temp
      end subroutine slasdt

      !! slaset.f
      subroutine slaset( uplo, m, n, alpha, beta, a, lda )
      character          uplo
      integer            lda, m, n
      real               alpha, beta
      real               a( lda, * )
      integer            i, j
      logical            lsame
      end subroutine slaset

      !! slasq1.f
      subroutine slasq1( n, d, e, work, info )
      integer            info, n
      real               d( * ), e( * ), work( * )
      real               zero
      parameter          ( zero = 0.0e0 )
      integer            i, iinfo
      real               eps, scale, safmin, sigmn, sigmx
      real               slamch
      end subroutine slasq1

      !! slasq2.f
      subroutine slasq2( n, z, info )
      integer            info, n
      real               z( * )
      real               cbias
      parameter          ( cbias = 1.50e0 )
      real               zero, half, one, two, four, hundrd
      parameter          ( zero = 0.0e0, half = 0.5e0, one = 1.0e0,
     &                     two = 2.0e0, four = 4.0e0, hundrd = 100.0e0 )
      logical            ieee
      integer            i0, i4, iinfo, ipn4, iter, iwhila, iwhilb, k,
     &                   kmin, n0, nbig, ndiv, nfail, pp, splt, ttype,
     &                   i1, n1
      real               d, dee, deemin, desig, dmin, dmin1, dmin2, dn,
     &                   dn1, dn2, e, emax, emin, eps, g, oldemn, qmax,
     &                   qmin, s, safmin, sigma, t, tau, temp, tol,
     &                   tol2, trace, zmax, tempe, tempq
      integer            ilaenv
      real               slamch
      end subroutine slasq2

      !! slasq3.f
      subroutine slasq3( i0, n0, z, pp, dmin, sigma, desig, qmax, nfail,
     &                   iter, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1,
     &                   dn2, g, tau )
      logical            ieee
      integer            i0, iter, n0, ndiv, nfail, pp
      real               desig, dmin, dmin1, dmin2, dn, dn1, dn2, g,
     &                   qmax, sigma, tau
      real               z( * )
      real               cbias
      parameter          ( cbias = 1.50e0 )
      real               zero, qurtr, half, one, two, hundrd
      parameter          ( zero = 0.0e0, qurtr = 0.250e0, half = 0.5e0,
     &                     one = 1.0e0, two = 2.0e0, hundrd = 100.0e0 )
      integer            ipn4, j4, n0in, nn, ttype
      real               eps, s, t, temp, tol, tol2
      real               slamch
      logical            sisnan
      end subroutine slasq3

      !! slasq4.f
      subroutine slasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,
     &                   dn1, dn2, tau, ttype, g )
      integer            i0, n0, n0in, pp, ttype
      real               dmin, dmin1, dmin2, dn, dn1, dn2, g, tau
      real               z( * )
      real               cnst1, cnst2, cnst3
      parameter          ( cnst1 = 0.5630e0, cnst2 = 1.010e0,
     &                   cnst3 = 1.050e0 )
      real               qurtr, third, half, zero, one, two, hundrd
      parameter          ( qurtr = 0.250e0, third = 0.3330e0,
     &                   half = 0.50e0, zero = 0.0e0, one = 1.0e0,
     &                   two = 2.0e0, hundrd = 100.0e0 )
      integer            i4, nn, np
      real               a2, b1, b2, gam, gap1, gap2, s
      end subroutine slasq4

      !! slasq5.f
      subroutine slasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,
     &                   dn, dnm1, dnm2, ieee, eps )
      logical            ieee
      integer            i0, n0, pp
      real               dmin, dmin1, dmin2, dn, dnm1, dnm2, tau,
     &                   sigma, eps
      real               z( * )
      real               zero, half
      parameter          ( zero = 0.0e0, half = 0.5 )
      integer            j4, j4p2
      real               d, emin, temp, dthresh
      end subroutine slasq5

      !! slasq6.f
      subroutine slasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,
     &                   dnm1, dnm2 )
      integer            i0, n0, pp
      real               dmin, dmin1, dmin2, dn, dnm1, dnm2
      real               z( * )
      real               zero
      parameter          ( zero = 0.0e0 )
      integer            j4, j4p2
      real               d, emin, safmin, temp
      real               slamch
      end subroutine slasq6

      !! slasr.f
      subroutine slasr( side, pivot, direct, m, n, c, s, a, lda )
      character          direct, pivot, side
      integer            lda, m, n
      real               a( lda, * ), c( * ), s( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, info, j
      real               ctemp, stemp, temp
      logical            lsame
      end subroutine slasr

      !! slasrt.f
      subroutine slasrt( id, n, d, info )
      character          id
      integer            info, n
      real               d( * )
      integer            select
      parameter          ( select = 20 )
      integer            dir, endd, i, j, start, stkpnt
      real               d1, d2, d3, dmnmx, tmp
      integer            stack( 2, 32 )
      logical            lsame
      end subroutine slasrt

      !! slassq.f
      subroutine slassq( n, x, incx, scale, sumsq )
      integer            incx, n
      real               scale, sumsq
      real               x( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            ix
      real               absxi
      logical            sisnan
      end subroutine slassq

      !! slasv2.f
      subroutine slasv2( f, g, h, ssmin, ssmax, snr, csr, snl, csl )
      real               csl, csr, f, g, h, snl, snr, ssmax, ssmin
      real               zero
      parameter          ( zero = 0.0e0 )
      real               half
      parameter          ( half = 0.5e0 )
      real               one
      parameter          ( one = 1.0e0 )
      real               two
      parameter          ( two = 2.0e0 )
      real               four
      parameter          ( four = 4.0e0 )
      logical            gasmal, swap
      integer            pmax
      real               a, clt, crt, d, fa, ft, ga, gt, ha, ht, l, m,
     &                   mm, r, s, slt, srt, t, temp, tsign, tt
      real               slamch
      end subroutine slasv2

      !! slaswp.f
      subroutine slaswp( n, a, lda, k1, k2, ipiv, incx )
      integer            incx, k1, k2, lda, n
      integer            ipiv( * )
      real               a( lda, * )
      integer            i, i1, i2, inc, ip, ix, ix0, j, k, n32
      real               temp
      end subroutine slaswp

      !! slasy2.f
      subroutine slasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,
     &                   ldtr, b, ldb, scale, x, ldx, xnorm, info )
      logical            ltranl, ltranr
      integer            info, isgn, ldb, ldtl, ldtr, ldx, n1, n2
      real               scale, xnorm
      real               b( ldb, * ), tl( ldtl, * ), tr( ldtr, * ),
     &                   x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               two, half, eight
      parameter          ( two = 2.0e+0, half = 0.5e+0, eight = 8.0e+0 )
      logical            bswap, xswap
      integer            i, ip, ipiv, ipsv, j, jp, jpsv, k
      real               bet, eps, gam, l21, sgn, smin, smlnum, tau1,
     &                   temp, u11, u12, u22, xmax
      logical            bswpiv( 4 ), xswpiv( 4 )
      integer            jpiv( 4 ), locl21( 4 ), locu12( 4 ),
     &                   locu22( 4 )
      real               btmp( 4 ), t16( 4, 4 ), tmp( 4 ), x2( 2 )
      integer            isamax
      real               slamch
      end subroutine slasy2

      !! sla_syamv.f
      subroutine sla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,
     &                      incy )
      real               alpha, beta
      integer            incx, incy, lda, n, uplo
      real               a( lda, * ), x( * ), y( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            symb_zero
      real               temp, safe1
      integer            i, info, iy, j, jx, kx, ky
      real               slamch
      integer            ilauplo
      end subroutine sla_syamv

      !! slasyf.f
      subroutine slasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      real               a( lda, * ), w( ldw, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      integer            imax, j, jb, jj, jmax, jp, k, kk, kkw, kp,
     &                   kstep, kw
      real               absakk, alpha, colmax, d11, d21, d22, r1,
     &                   rowmax, t
      logical            lsame
      integer            isamax
      end subroutine slasyf

      !! slasyf_rook.f
      subroutine slasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,
     &                        info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      real               a( lda, * ), w( ldw, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            done
      integer            imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk,
     &                   kw, kkw, kp, kstep, p, ii
      real               absakk, alpha, colmax, d11, d12, d21, d22,
     &                   stemp, r1, rowmax, t, sfmin
      logical            lsame
      integer            isamax
      real               slamch
      end subroutine slasyf_rook

      !! sla_syrcond.f
      real function sla_syrcond( uplo, n, a, lda, af, ldaf, ipiv, cmode,
     &                           c, info, work, iwork )
      character          uplo
      integer            n, lda, ldaf, info, cmode
      integer            iwork( * ), ipiv( * )
      real               a( lda, * ), af( ldaf, * ), work( * ), c( * )
      character          normin
      integer            kase, i, j
      real               ainvnm, smlnum, tmp
      logical            up
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch
      end function sla_syrcond

      !! sla_syrfsx_extended.f
      subroutine sla_syrfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, ipiv, colequ, c, b, ldb,
     &                                y, ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      real               rthresh, dz_ub
      integer            ipiv( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      real               c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state
      real               yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec, upper
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, y_prec_state, base_residual,
     &                   extra_residual, extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      real               slamch
      end subroutine sla_syrfsx_extended

      !! sla_syrpvgrw.f
      real function sla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,
     &                            work )
      character(len=1)   uplo
      integer            n, info, lda, ldaf
      integer            ipiv( * )
      real               a( lda, * ), af( ldaf, * ), work( * )
      integer            ncols, i, j, k, kp
      real               amax, umax, rpvgrw, tmp
      logical            upper
      logical            lsame
      end function sla_syrpvgrw

      !! slatbs.f
      subroutine slatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,
     &                   scale, cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, kd, ldab, n
      real               scale
      real               ab( ldab, * ), cnorm( * ), x( * )
      real               zero, half, one
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast, jlen, maind
      real               bignum, grow, rec, smlnum, sumj, tjj, tjjs,
     &                   tmax, tscal, uscal, xbnd, xj, xmax
      logical            lsame
      integer            isamax
      real               sasum, sdot, slamch
      end subroutine slatbs

      !! slatdf.f
      subroutine slatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,
     &                   jpiv )
      integer            ijob, ldz, n
      real               rdscal, rdsum
      integer            ipiv( * ), jpiv( * )
      real               rhs( * ), z( ldz, * )
      integer            maxdim
      parameter          ( maxdim = 8 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i, info, j, k
      real               bm, bp, pmone, sminu, splus, temp
      integer            iwork( maxdim )
      real               work( 4*maxdim ), xm( maxdim ), xp( maxdim )
      real               sasum, sdot
      end subroutine slatdf

      !! slatps.f
      subroutine slatps( uplo, trans, diag, normin, n, ap, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, n
      real               scale
      real               ap( * ), cnorm( * ), x( * )
      real               zero, half, one
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0 )
      logical            notran, nounit, upper
      integer            i, imax, ip, j, jfirst, jinc, jlast, jlen
      real               bignum, grow, rec, smlnum, sumj, tjj, tjjs,
     &                   tmax, tscal, uscal, xbnd, xj, xmax
      logical            lsame
      integer            isamax
      real               sasum, sdot, slamch
      end subroutine slatps

      !! slatrd.f
      subroutine slatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
      character          uplo
      integer            lda, ldw, n, nb
      real               a( lda, * ), e( * ), tau( * ), w( ldw, * )
      real               zero, one, half
      parameter          ( zero = 0.0e+0, one = 1.0e+0, half = 0.5e+0 )
      integer            i, iw
      real               alpha
      logical            lsame
      real               sdot
      end subroutine slatrd

      !! slatrs.f
      subroutine slatrs( uplo, trans, diag, normin, n, a, lda, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, lda, n
      real               scale
      real               a( lda, * ), cnorm( * ), x( * )
      real               zero, half, one
      parameter          ( zero = 0.0e+0, half = 0.5e+0, one = 1.0e+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast
      real               bignum, grow, rec, smlnum, sumj, tjj, tjjs,
     &                   tmax, tscal, uscal, xbnd, xj, xmax
      logical            lsame
      integer            isamax
      real               sasum, sdot, slamch
      end subroutine slatrs

      !! slatrz.f
      subroutine slatrz( m, n, l, a, lda, tau, work )
      integer            l, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            i
      end subroutine slatrz

      !! slauu2.f
      subroutine slauu2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      real               a( lda, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            i
      real               aii
      logical            lsame
      real               sdot
      end subroutine slauu2

      !! slauum.f
      subroutine slauum( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      real               a( lda, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            i, ib, nb
      logical            lsame
      integer            ilaenv
      end subroutine slauum

      !! sla_wwaddw.f
      subroutine sla_wwaddw( n, x, y, w )
      integer            n
      real               x( * ), y( * ), w( * )
      real               s
      integer            i
      end subroutine sla_wwaddw

      !! sopgtr.f
      subroutine sopgtr( uplo, n, ap, tau, q, ldq, work, info )
      character          uplo
      integer            info, ldq, n
      real               ap( * ), q( ldq, * ), tau( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            upper
      integer            i, iinfo, ij, j
      logical            lsame
      end subroutine sopgtr

      !! sopmtr.f
      subroutine sopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,
     &                   info )
      character          side, trans, uplo
      integer            info, ldc, m, n
      real               ap( * ), c( ldc, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            forwrd, left, notran, upper
      integer            i, i1, i2, i3, ic, ii, jc, mi, ni, nq
      real               aii
      logical            lsame
      end subroutine sopmtr

      !! sorbdb1.f
      subroutine sorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      real               taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      real               one
      parameter          ( one = 1.0e0 )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      real               snrm2
      end subroutine sorbdb1

      !! sorbdb2.f
      subroutine sorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      real               taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      real               negone, one
      parameter          ( negone = -1.0e0, one = 1.0e0 )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      real               snrm2
      end subroutine sorbdb2

      !! sorbdb3.f
      subroutine sorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      real               taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      real               one
      parameter          ( one = 1.0e0 )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      real               snrm2
      end subroutine sorbdb3

      !! sorbdb4.f
      subroutine sorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, phantom, work, lwork,
     &                    info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      real               phi(*), theta(*)
      real               phantom(*), taup1(*), taup2(*), tauq1(*),
     &                   work(*), x11(ldx11,*), x21(ldx21,*)
      real               negone, one, zero
      parameter          ( negone = -1.0e0, one = 1.0e0, zero = 0.0e0 )
      real               c, s
      integer            childinfo, i, ilarf, iorbdb5, j, llarf,
     &                   lorbdb5, lworkmin, lworkopt
      logical            lquery
      real               snrm2
      end subroutine sorbdb4

      !! sorbdb5.f
      subroutine sorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      real               q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      real               one, zero
      parameter          ( one = 1.0e0, zero = 0.0e0 )
      integer            childinfo, i, j
      real               snrm2
      end subroutine sorbdb5

      !! sorbdb6.f
      subroutine sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      real               q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      real               alphasq, realone, realzero
      parameter          ( alphasq = 0.01e0, realone = 1.0e0,
     &                     realzero = 0.0e0 )
      real               negone, one, zero
      parameter          ( negone = -1.0e0, one = 1.0e0, zero = 0.0e0 )
      integer            i
      real               normsq1, normsq2, scl1, scl2, ssq1, ssq2
      end subroutine sorbdb6

      !! sorbdb.f
      subroutine sorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,
     &                   x21, ldx21, x22, ldx22, theta, phi, taup1,
     &                   taup2, tauq1, tauq2, work, lwork, info )
      character          signs, trans
      integer            info, ldx11, ldx12, ldx21, ldx22, lwork, m, p,
     &                   q
      real               phi( * ), theta( * )
      real               taup1( * ), taup2( * ), tauq1( * ), tauq2( * ),
     &                   work( * ), x11( ldx11, * ), x12( ldx12, * ),
     &                   x21( ldx21, * ), x22( ldx22, * )
      real               realone
      parameter          ( realone = 1.0e0 )
      real               one
      parameter          ( one = 1.0e0 )
      logical            colmajor, lquery
      integer            i, lworkmin, lworkopt
      real               z1, z2, z3, z4
      real               snrm2
      logical            lsame
      end subroutine sorbdb

      !! sorcsd2by1.f
      subroutine sorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,
     &                       x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t,
     &                       ldv1t, work, lwork, iwork, info )
      character          jobu1, jobu2, jobv1t
      integer            info, ldu1, ldu2, ldv1t, lwork, ldx11, ldx21,
     &                   m, p, q
      real               theta(*)
      real               u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      integer            iwork(*)
      real               one, zero
      parameter          ( one = 1.0e0, zero = 0.0e0 )
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   j, lbbcsd, lorbdb, lorglq, lorglqmin,
     &                   lorglqopt, lorgqr, lorgqrmin, lorgqropt,
     &                   lworkmin, lworkopt, r
      logical            lquery, wantu1, wantu2, wantv1t
      logical            lsame
      end subroutine sorcsd2by1

      !! sorcsd.f
      recursive subroutine sorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,
     &                             signs, m, p, q, x11, ldx11, x12,
     &                             ldx12, x21, ldx21, x22, ldx22, theta,
     &                             u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,
     &                             ldv2t, work, lwork, iwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, signs, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12,
     &                   ldx21, ldx22, lwork, m, p, q
      integer            iwork( * )
      real               theta( * )
      real               u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * ), work( * ), x11( ldx11, * ),
     &                   x12( ldx12, * ), x21( ldx21, * ), x22( ldx22,
     &                   * )
      real               one, zero
      parameter          ( one = 1.0e+0,
     &                     zero = 0.0e+0 )
      real               dummy(1)
      character          transt, signst
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   itauq2, j, lbbcsdwork, lbbcsdworkmin,
     &                   lbbcsdworkopt, lorbdbwork, lorbdbworkmin,
     &                   lorbdbworkopt, lorglqwork, lorglqworkmin,
     &                   lorglqworkopt, lorgqrwork, lorgqrworkmin,
     &                   lorgqrworkopt, lworkmin, lworkopt
      logical            colmajor, defaultsigns, lquery, wantu1, wantu2,
     &                   wantv1t, wantv2t
      logical            lsame
      end subroutine sorcsd

      !! sorg2l.f
      subroutine sorg2l( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, ii, j, l
      end subroutine sorg2l

      !! sorg2r.f
      subroutine sorg2r( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, l
      end subroutine sorg2r

      !! sorgbr.f
      subroutine sorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
      character          vect
      integer            info, k, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, wantq
      integer            i, iinfo, j, lwkopt, mn
      logical            lsame
      integer            ilaenv
      end subroutine sorgbr

      !! sorghr.f
      subroutine sorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery
      integer            i, iinfo, j, lwkopt, nb, nh
      integer            ilaenv
      end subroutine sorghr

      !! sorgl2.f
      subroutine sorgl2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, j, l
      end subroutine sorgl2

      !! sorglq.f
      subroutine sorglq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine sorglq

      !! sorgql.f
      subroutine sorgql( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery
      integer            i, ib, iinfo, iws, j, kk, l, ldwork, lwkopt,
     &                   nb, nbmin, nx
      integer            ilaenv
      end subroutine sorgql

      !! sorgqr.f
      subroutine sorgqr( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine sorgqr

      !! sorgr2.f
      subroutine sorgr2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, ii, j, l
      end subroutine sorgr2

      !! sorgrq.f
      subroutine sorgrq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery
      integer            i, ib, ii, iinfo, iws, j, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine sorgrq

      !! sorgtr.f
      subroutine sorgtr( uplo, n, a, lda, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, upper
      integer            i, iinfo, j, lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine sorgtr

      !! sorm22.f
      subroutine sorm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            m, n, n1, n2, ldq, ldc, lwork, info
      real               q( ldq, * ), c( ldc, * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            left, lquery, notran
      integer            i, ldwork, len, lwkopt, nb, nq, nw
      logical            lsame
      end subroutine sorm22

      !! sorm2l.f
      subroutine sorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      real               aii
      logical            lsame
      end subroutine sorm2l

      !! sorm2r.f
      subroutine sorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      real               aii
      logical            lsame
      end subroutine sorm2r

      !! sormbr.f
      subroutine sormbr( vect, side, trans, m, n, k, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans, vect
      integer            info, k, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      logical            applyq, left, lquery, notran
      character          transt
      integer            i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormbr

      !! sormhr.f
      subroutine sormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans
      integer            ihi, ilo, info, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      logical            left, lquery
      integer            i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormhr

      !! sorml2.f
      subroutine sorml2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      real               aii
      logical            lsame
      end subroutine sorml2

      !! sormlq.f
      subroutine sormlq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormlq

      !! sormql.f
      subroutine sormql( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormql

      !! sormqr.f
      subroutine sormqr( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormqr

      !! sormr2.f
      subroutine sormr2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      real               aii
      logical            lsame
      end subroutine sormr2

      !! sormr3.f
      subroutine sormr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, l, lda, ldc, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, notran
      integer            i, i1, i2, i3, ic, ja, jc, mi, ni, nq
      logical            lsame
      end subroutine sormr3

      !! sormrq.f
      subroutine sormrq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormrq

      !! sormrz.f
      subroutine sormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, l, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, ja, jc,
     &                   ldwork, lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormrz

      !! sormtr.f
      subroutine sormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans, uplo
      integer            info, lda, ldc, lwork, m, n
      real               a( lda, * ), c( ldc, * ), tau( * ),
     &                   work( * )
      logical            left, lquery, upper
      integer            i1, i2, iinfo, lwkopt, mi, ni, nb, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine sormtr

      !! spbcon.f
      subroutine spbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,
     &                   iwork, info )
      character          uplo
      integer            info, kd, ldab, n
      real               anorm, rcond
      integer            iwork( * )
      real               ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      character          normin
      integer            ix, kase
      real               ainvnm, scale, scalel, scaleu, smlnum
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch
      end subroutine spbcon

      !! spbequ.f
      subroutine spbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
      character          uplo
      integer            info, kd, ldab, n
      real               amax, scond
      real               ab( ldab, * ), s( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            upper
      integer            i, j
      real               smin
      logical            lsame
      end subroutine spbequ

      !! spbrfs.f
      subroutine spbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,
     &                   ldb, x, ldx, ferr, berr, work, iwork, info )
      character          uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      integer            iwork( * )
      real               ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, j, k, kase, l, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine spbrfs

      !! spbstf.f
      subroutine spbstf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      real               ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            j, kld, km, m
      real               ajj
      logical            lsame
      end subroutine spbstf

      !! spbsv.f
      subroutine spbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      real               ab( ldab, * ), b( ldb, * )
      logical            lsame
      end subroutine spbsv

      !! spbsvx.f
      subroutine spbsvx( fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb,
     &                   equed, s, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, iwork, info )
      character          equed, fact, uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      real               rcond
      integer            iwork( * )
      real               ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), s( * ), work( * ),
     &                   x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            equil, nofact, rcequ, upper
      integer            i, infequ, j, j1, j2
      real               amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      real               slamch, slansb
      end subroutine spbsvx

      !! spbtf2.f
      subroutine spbtf2( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      real               ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            j, kld, kn
      real               ajj
      logical            lsame
      end subroutine spbtf2

      !! spbtrf.f
      subroutine spbtrf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      real               ab( ldab, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            nbmax, ldwork
      parameter          ( nbmax = 32, ldwork = nbmax+1 )
      integer            i, i2, i3, ib, ii, j, jj, nb
      real               work( ldwork, nbmax )
      logical            lsame
      integer            ilaenv
      end subroutine spbtrf

      !! spbtrs.f
      subroutine spbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      real               ab( ldab, * ), b( ldb, * )
      logical            upper
      integer            j
      logical            lsame
      end subroutine spbtrs

      !! spftrf.f
      subroutine spftrf( transr, uplo, n, a, info )
      character          transr, uplo
      integer            n, info
      real               a( 0: * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine spftrf

      !! spftri.f
      subroutine spftri( transr, uplo, n, a, info )
      character          transr, uplo
      integer            info, n
      real               a( 0: * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine spftri

      !! spftrs.f
      subroutine spftrs( transr, uplo, n, nrhs, a, b, ldb, info )
      character          transr, uplo
      integer            info, ldb, n, nrhs
      real               a( 0: * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lower, normaltransr
      logical            lsame
      end subroutine spftrs

      !! spocon.f
      subroutine spocon( uplo, n, a, lda, anorm, rcond, work, iwork,
     &                   info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      integer            iwork( * )
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      character          normin
      integer            ix, kase
      real               ainvnm, scale, scalel, scaleu, smlnum
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch
      end subroutine spocon

      !! spoequb.f
      subroutine spoequb( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      real               amax, scond
      real               a( lda, * ), s( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i
      real               smin, base, tmp
      real               slamch
      end subroutine spoequb

      !! spoequ.f
      subroutine spoequ( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      real               amax, scond
      real               a( lda, * ), s( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            i
      real               smin
      end subroutine spoequ

      !! sporfs.f
      subroutine sporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,
     &                   ldx, ferr, berr, work, iwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine sporfs

      !! sporfsx.f
      subroutine sporfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, s, b,
     &                    ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond
      integer            iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, slansy, sla_porcond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine sporfsx

      !! sposv.f
      subroutine sposv( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      real               a( lda, * ), b( ldb, * )
      logical            lsame
      end subroutine sposv

      !! sposvx.f
      subroutine sposvx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                   s, b, ldb, x, ldx, rcond, ferr, berr, work,
     &                   iwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      real               rcond
      integer            iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), s( * ), work( * ),
     &                   x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      real               amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      real               slamch, slansy
      end subroutine sposvx

      !! sposvxx.f
      subroutine sposvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                    s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, iwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      real               amax, bignum, smin, smax,
     &                   scond, smlnum
      logical            lsame
      real               slamch, sla_porpvgrw
      end subroutine sposvxx

      !! spotf2.f
      subroutine spotf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      real               a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            j
      real               ajj
      logical            lsame, sisnan
      real               sdot
      end subroutine spotf2

      !! spotrf2.f
      recursive subroutine spotrf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      real               a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero=0.0e+0 )
      logical            upper
      integer            n1, n2, iinfo
      logical            lsame, sisnan
      end subroutine spotrf2

      !! spotrf.f
      subroutine spotrf( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      real               a( lda, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            j, jb, nb
      logical            lsame
      integer            ilaenv
      end subroutine spotrf

      !! spotri.f
      subroutine spotri( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      real               a( lda, * )
      logical            lsame
      end subroutine spotri

      !! spotrs.f
      subroutine spotrs( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      real               a( lda, * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      logical            lsame
      end subroutine spotrs

      !! sppcon.f
      subroutine sppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
      character          uplo
      integer            info, n
      real               anorm, rcond
      integer            iwork( * )
      real               ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      character          normin
      integer            ix, kase
      real               ainvnm, scale, scalel, scaleu, smlnum
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch
      end subroutine sppcon

      !! sppequ.f
      subroutine sppequ( uplo, n, ap, s, scond, amax, info )
      character          uplo
      integer            info, n
      real               amax, scond
      real               ap( * ), s( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, jj
      real               smin
      logical            lsame
      end subroutine sppequ

      !! spprfs.f
      subroutine spprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,
     &                   berr, work, iwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            iwork( * )
      real               afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine spprfs

      !! sppsv.f
      subroutine sppsv( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      real               ap( * ), b( ldb, * )
      logical            lsame
      end subroutine sppsv

      !! sppsvx.f
      subroutine sppsvx( fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb,
     &                   x, ldx, rcond, ferr, berr, work, iwork, info )
      character          equed, fact, uplo
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      integer            iwork( * )
      real               afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), s( * ), work( * ), x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      real               amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      real               slamch, slansp
      end subroutine sppsvx

      !! spptrf.f
      subroutine spptrf( uplo, n, ap, info )
      character          uplo
      integer            info, n
      real               ap( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            j, jc, jj
      real               ajj
      logical            lsame
      real               sdot
      end subroutine spptrf

      !! spptri.f
      subroutine spptri( uplo, n, ap, info )
      character          uplo
      integer            info, n
      real               ap( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            j, jc, jj, jjn
      real               ajj
      logical            lsame
      real               sdot
      end subroutine spptri

      !! spptrs.f
      subroutine spptrs( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      real               ap( * ), b( ldb, * )
      logical            upper
      integer            i
      logical            lsame
      end subroutine spptrs

      !! spstf2.f
      subroutine spstf2( uplo, n, a, lda, piv, rank, tol, work, info )
      real               tol
      integer            info, lda, n, rank
      character          uplo
      real               a( lda, * ), work( 2*n )
      integer            piv( n )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      real               ajj, sstop, stemp
      integer            i, itemp, j, pvt
      logical            upper
      real               slamch
      logical            lsame, sisnan
      end subroutine spstf2

      !! spstrf.f
      subroutine spstrf( uplo, n, a, lda, piv, rank, tol, work, info )
      real               tol
      integer            info, lda, n, rank
      character          uplo
      real               a( lda, * ), work( 2*n )
      integer            piv( n )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      real               ajj, sstop, stemp
      integer            i, itemp, j, jb, k, nb, pvt
      logical            upper
      real               slamch
      integer            ilaenv
      logical            lsame, sisnan
      end subroutine spstrf

      !! sptcon.f
      subroutine sptcon( n, d, e, anorm, rcond, work, info )
      integer            info, n
      real               anorm, rcond
      real               d( * ), e( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            i, ix
      real               ainvnm
      integer            isamax
      end subroutine sptcon

      !! spteqr.f
      subroutine spteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      real               d( * ), e( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lsame
      real               c( 1, 1 ), vt( 1, 1 )
      integer            i, icompz, nru
      end subroutine spteqr

      !! sptrfs.f
      subroutine sptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,
     &                   berr, work, info )
      integer            info, ldb, ldx, n, nrhs
      real               b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   e( * ), ef( * ), ferr( * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      integer            count, i, ix, j, nz
      real               bi, cx, dx, eps, ex, lstres, s, safe1, safe2,
     &                   safmin
      integer            isamax
      real               slamch
      end subroutine sptrfs

      !! sptsv.f
      subroutine sptsv( n, nrhs, d, e, b, ldb, info )
      integer            info, ldb, n, nrhs
      real               b( ldb, * ), d( * ), e( * )
      end subroutine sptsv

      !! sptsvx.f
      subroutine sptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, info )
      character          fact
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      real               b( ldb, * ), berr( * ), d( * ), df( * ),
     &                   e( * ), ef( * ), ferr( * ), work( * ),
     &                   x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nofact
      real               anorm
      logical            lsame
      real               slamch, slanst
      end subroutine sptsvx

      !! spttrf.f
      subroutine spttrf( n, d, e, info )
      integer            info, n
      real               d( * ), e( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      integer            i, i4
      real               ei
      end subroutine spttrf

      !! spttrs.f
      subroutine spttrs( n, nrhs, d, e, b, ldb, info )
      integer            info, ldb, n, nrhs
      real               b( ldb, * ), d( * ), e( * )
      integer            j, jb, nb
      integer            ilaenv
      end subroutine spttrs

      !! sptts2.f
      subroutine sptts2( n, nrhs, d, e, b, ldb )
      integer            ldb, n, nrhs
      real               b( ldb, * ), d( * ), e( * )
      integer            i, j
      end subroutine sptts2

      !! srscl.f
      subroutine srscl( n, sa, sx, incx )
      integer            incx, n
      real               sa
      real               sx( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            done
      real               bignum, cden, cden1, cnum, cnum1, mul, smlnum
      real               slamch
      end subroutine srscl

      !! ssbevd.f
      subroutine ssbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                   lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, liwork, lwork, n
      integer            iwork( * )
      real               ab( ldab, * ), w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lower, lquery, wantz
      integer            iinfo, inde, indwk2, indwrk, iscale, liwmin,
     &                   llwrk2, lwmin
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               slamch, slansb
      end subroutine ssbevd

      !! ssbev.f
      subroutine ssbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                  info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, n
      real               ab( ldab, * ), w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lower, wantz
      integer            iinfo, imax, inde, indwrk, iscale
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               slamch, slansb
      end subroutine ssbev

      !! ssbevx.f
      subroutine ssbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,
     &                   vu, il, iu, abstol, m, w, z, ldz, work, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, kd, ldab, ldq, ldz, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               ab( ldab, * ), q( ldq, * ), w( * ), work( * ),
     &                   z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            alleig, indeig, lower, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwo, indwrk, iscale, itmp1, j, jj,
     &                   nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      real               slamch, slansb
      end subroutine ssbevx

      !! ssbgst.f
      subroutine ssbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,
     &                   ldx, work, info )
      character          uplo, vect
      integer            info, ka, kb, ldab, ldbb, ldx, n
      real               ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   x( ldx, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            update, upper, wantx
      integer            i, i0, i1, i2, inca, j, j1, j1t, j2, j2t, k,
     &                   ka1, kb1, kbt, l, m, nr, nrt, nx
      real               bii, ra, ra1, t
      logical            lsame
      end subroutine ssbgst

      !! ssbgvd.f
      subroutine ssbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,
     &                   z, ldz, work, lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, liwork, lwork, n
      integer            iwork( * )
      real               ab( ldab, * ), bb( ldbb, * ), w( * ),
     &                   work( * ), z( ldz, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            lquery, upper, wantz
      character          vect
      integer            iinfo, inde, indwk2, indwrk, liwmin, llwrk2,
     &                   lwmin
      logical            lsame
      end subroutine ssbgvd

      !! ssbgv.f
      subroutine ssbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,
     &                  ldz, work, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, n
      real               ab( ldab, * ), bb( ldbb, * ), w( * ),
     &                   work( * ), z( ldz, * )
      logical            upper, wantz
      character          vect
      integer            iinfo, inde, indwrk
      logical            lsame
      end subroutine ssbgv

      !! ssbgvx.f
      subroutine ssbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,
     &                   ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z,
     &                   ldz, work, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, ka, kb, ldab, ldbb, ldq, ldz, m,
     &                   n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               ab( ldab, * ), bb( ldbb, * ), q( ldq, * ),
     &                   w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            alleig, indeig, test, upper, valeig, wantz
      character          order, vect
      integer            i, iinfo, indd, inde, indee, indibl, indisp,
     &                   indiwo, indwrk, itmp1, j, jj, nsplit
      real               tmp1
      logical            lsame
      end subroutine ssbgvx

      !! ssbtrd.f
      subroutine ssbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,
     &                   work, info )
      character          uplo, vect
      integer            info, kd, ldab, ldq, n
      real               ab( ldab, * ), d( * ), e( * ), q( ldq, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            initq, upper, wantq
      integer            i, i2, ibl, inca, incx, iqaend, iqb, iqend, j,
     &                   j1, j1end, j1inc, j2, jend, jin, jinc, k, kd1,
     &                   kdm1, kdn, l, last, lend, nq, nr, nrt
      real               temp
      logical            lsame
      end subroutine ssbtrd

      !! ssfrk.f
      subroutine ssfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,
     &                  c )
      real               alpha, beta
      integer            k, lda, n
      character          trans, transr, uplo
      real               a( lda, * ), c( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            lower, normaltransr, nisodd, notrans
      integer            info, nrowa, j, nk, n1, n2
      logical            lsame
      end subroutine ssfrk

      !! sspcon.f
      subroutine sspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,
     &                   info )
      character          uplo
      integer            info, n
      real               anorm, rcond
      integer            ipiv( * ), iwork( * )
      real               ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, ip, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine sspcon

      !! sspevd.f
      subroutine sspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, uplo
      integer            info, ldz, liwork, lwork, n
      integer            iwork( * )
      real               ap( * ), w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, wantz
      integer            iinfo, inde, indtau, indwrk, iscale, liwmin,
     &                   llwork, lwmin
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               slamch, slansp
      end subroutine sspevd

      !! sspev.f
      subroutine sspev( jobz, uplo, n, ap, w, z, ldz, work, info )
      character          jobz, uplo
      integer            info, ldz, n
      real               ap( * ), w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            wantz
      integer            iinfo, imax, inde, indtau, indwrk, iscale
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      real               slamch, slansp
      end subroutine sspev

      !! sspevx.f
      subroutine sspevx( jobz, range, uplo, n, ap, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, iwork, ifail,
     &                   info )
      character          jobz, range, uplo
      integer            il, info, iu, ldz, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               ap( * ), w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            alleig, indeig, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwo, indtau, indwrk, iscale, itmp1,
     &                   j, jj, nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      real               slamch, slansp
      end subroutine sspevx

      !! sspgst.f
      subroutine sspgst( itype, uplo, n, ap, bp, info )
      character          uplo
      integer            info, itype, n
      real               ap( * ), bp( * )
      real               one, half
      parameter          ( one = 1.0, half = 0.5 )
      logical            upper
      integer            j, j1, j1j1, jj, k, k1, k1k1, kk
      real               ajj, akk, bjj, bkk, ct
      logical            lsame
      real               sdot
      end subroutine sspgst

      !! sspgvd.f
      subroutine sspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                   lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, ldz, liwork, lwork, n
      integer            iwork( * )
      real               ap( * ), bp( * ), w( * ), work( * ),
     &                   z( ldz, * )
      logical            lquery, upper, wantz
      character          trans
      integer            j, liwmin, lwmin, neig
      logical            lsame
      end subroutine sspgvd

      !! sspgv.f
      subroutine sspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                  info )
      character          jobz, uplo
      integer            info, itype, ldz, n
      real               ap( * ), bp( * ), w( * ), work( * ),
     &                   z( ldz, * )
      logical            upper, wantz
      character          trans
      integer            j, neig
      logical            lsame
      end subroutine sspgv

      !! sspgvx.f
      subroutine sspgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,
     &                   il, iu, abstol, m, w, z, ldz, work, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, ldz, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               ap( * ), bp( * ), w( * ), work( * ),
     &                   z( ldz, * )
      logical            alleig, indeig, upper, valeig, wantz
      character          trans
      integer            j
      logical            lsame
      end subroutine sspgvx

      !! ssprfs.f
      subroutine ssprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,
     &                   ferr, berr, work, iwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      real               afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine ssprfs

      !! sspsv.f
      subroutine sspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      real               ap( * ), b( ldb, * )
      logical            lsame
      end subroutine sspsv

      !! sspsvx.f
      subroutine sspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,
     &                   ldx, rcond, ferr, berr, work, iwork, info )
      character          fact, uplo
      integer            info, ldb, ldx, n, nrhs
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               afp( * ), ap( * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nofact
      real               anorm
      logical            lsame
      real               slamch, slansp
      end subroutine sspsvx

      !! ssptrd.f
      subroutine ssptrd( uplo, n, ap, d, e, tau, info )
      character          uplo
      integer            info, n
      real               ap( * ), d( * ), e( * ), tau( * )
      real               one, zero, half
      parameter          ( one = 1.0, zero = 0.0, half = 1.0 / 2.0 )
      logical            upper
      integer            i, i1, i1i1, ii
      real               alpha, taui
      logical            lsame
      real               sdot
      end subroutine ssptrd

      !! ssptrf.f
      subroutine ssptrf( uplo, n, ap, ipiv, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      real               ap( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kc, kk, knc, kp, kpc,
     &                   kstep, kx, npp
      real               absakk, alpha, colmax, d11, d12, d21, d22, r1,
     &                   rowmax, t, wk, wkm1, wkp1
      logical            lsame
      integer            isamax
      end subroutine ssptrf

      !! ssptri.f
      subroutine ssptri( uplo, n, ap, ipiv, work, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      real               ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            j, k, kc, kcnext, kp, kpc, kstep, kx, npp
      real               ak, akkp1, akp1, d, t, temp
      logical            lsame
      real               sdot
      end subroutine ssptri

      !! ssptrs.f
      subroutine ssptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      real               ap( * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            j, k, kc, kp
      real               ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine ssptrs

      !! sstebz.f
      subroutine sstebz( range, order, n, vl, vu, il, iu, abstol, d, e,
     &                   m, nsplit, w, iblock, isplit, work, iwork,
     &                   info )
      character          order, range
      integer            il, info, iu, m, n, nsplit
      real               abstol, vl, vu
      integer            iblock( * ), isplit( * ), iwork( * )
      real               d( * ), e( * ), w( * ), work( * )
      real               zero, one, two, half
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   half = 1.0e0 / two )
      real               fudge, relfac
      parameter          ( fudge = 2.1e0, relfac = 2.0e0 )
      logical            ncnvrg, toofew
      integer            ib, ibegin, idiscl, idiscu, ie, iend, iinfo,
     &                   im, in, ioff, iorder, iout, irange, itmax,
     &                   itmp1, iw, iwoff, j, jb, jdisc, je, nb, nwl,
     &                   nwu
      real               atoli, bnorm, gl, gu, pivmin, rtoli, safemn,
     &                   tmp1, tmp2, tnorm, ulp, wkill, wl, wlu, wu, wul
      integer            idumma( 1 )
      logical            lsame
      integer            ilaenv
      real               slamch
      end subroutine sstebz

      !! sstedc.f
      subroutine sstedc( compz, n, d, e, z, ldz, work, lwork, iwork,
     &                   liwork, info )
      character          compz
      integer            info, ldz, liwork, lwork, n
      integer            iwork( * )
      real               d( * ), e( * ), work( * ), z( ldz, * )
      real               zero, one, two
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0 )
      logical            lquery
      integer            finish, i, icompz, ii, j, k, lgn, liwmin,
     &                   lwmin, m, smlsiz, start, storez, strtrw
      real               eps, orgnrm, p, tiny
      logical            lsame
      integer            ilaenv
      real               slamch, slanst
      end subroutine sstedc

      !! sstegr.f
      subroutine sstegr( jobz, range, n, d, e, vl, vu, il, iu,
     &           abstol, m, w, z, ldz, isuppz, work, lwork, iwork,
     &           liwork, info )
      character          jobz, range
      integer            il, info, iu, ldz, liwork, lwork, m, n
      real             abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      real               d( * ), e( * ), w( * ), work( * )
      real               z( ldz, * )
      logical tryrac
      end subroutine sstegr

      !! sstein.f
      subroutine sstein( n, d, e, m, w, iblock, isplit, z, ldz, work,
     &                   iwork, ifail, info )
      integer            info, ldz, m, n
      integer            iblock( * ), ifail( * ), isplit( * ),
     &                   iwork( * )
      real               d( * ), e( * ), w( * ), work( * ), z( ldz, * )
      real               zero, one, ten, odm3, odm1
      parameter          ( zero = 0.0e+0, one = 1.0e+0, ten = 1.0e+1,
     &                   odm3 = 1.0e-3, odm1 = 1.0e-1 )
      integer            maxits, extra
      parameter          ( maxits = 5, extra = 2 )
      integer            b1, blksiz, bn, gpind, i, iinfo, indrv1,
     &                   indrv2, indrv3, indrv4, indrv5, its, j, j1,
     &                   jblk, jmax, nblk, nrmchk
      real               ctr, eps, eps1, nrm, onenrm, ortol, pertol,
     &                   scl, sep, stpcrt, tol, xj, xjm
      integer            iseed( 4 )
      integer            isamax
      real               sasum, sdot, slamch, snrm2
      end subroutine sstein

      !! sstemr.f
      subroutine sstemr( jobz, range, n, d, e, vl, vu, il, iu,
     &                   m, w, z, ldz, nzc, isuppz, tryrac, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, range
      logical            tryrac
      integer            il, info, iu, ldz, nzc, liwork, lwork, m, n
      real               vl, vu
      integer            isuppz( * ), iwork( * )
      real               d( * ), e( * ), w( * ), work( * )
      real               z( ldz, * )
      real               zero, one, four, minrgp
      parameter          ( zero = 0.0e0, one = 1.0e0,
     &                     four = 4.0e0,
     &                     minrgp = 3.0e-3 )
      logical            alleig, indeig, lquery, valeig, wantz, zquery
      integer            i, ibegin, iend, ifirst, iil, iindbl, iindw,
     &                   iindwk, iinfo, iinspl, iiu, ilast, in, indd,
     &                   inde2, inderr, indgp, indgrs, indwrk, itmp,
     &                   itmp2, j, jblk, jj, liwmin, lwmin, nsplit,
     &                   nzcmin, offset, wbegin, wend
      real               bignum, cs, eps, pivmin, r1, r2, rmax, rmin,
     &                   rtol1, rtol2, safmin, scale, smlnum, sn,
     &                   thresh, tmp, tnrm, wl, wu
      logical            lsame
      real               slamch, slanst
      end subroutine sstemr

      !! ssteqr.f
      subroutine ssteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      real               d( * ), e( * ), work( * ), z( ldz, * )
      real               zero, one, two, three
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   three = 3.0e0 )
      integer            maxit
      parameter          ( maxit = 30 )
      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
     &                   nm1, nmaxit
      real               anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
     &                   s, safmax, safmin, ssfmax, ssfmin, tst
      logical            lsame
      real               slamch, slanst, slapy2
      end subroutine ssteqr

      !! ssterf.f
      subroutine ssterf( n, d, e, info )
      integer            info, n
      real               d( * ), e( * )
      real               zero, one, two, three
      parameter          ( zero = 0.0e0, one = 1.0e0, two = 2.0e0,
     &                   three = 3.0e0 )
      integer            maxit
      parameter          ( maxit = 30 )
      integer            i, iscale, jtot, l, l1, lend, lendsv, lsv, m,
     &                   nmaxit
      real               alpha, anorm, bb, c, eps, eps2, gamma, oldc,
     &                   oldgam, p, r, rt1, rt2, rte, s, safmax, safmin,
     &                   sigma, ssfmax, ssfmin
      real               slamch, slanst, slapy2
      end subroutine ssterf

      !! sstevd.f
      subroutine sstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,
     &                   liwork, info )
      character          jobz
      integer            info, ldz, liwork, lwork, n
      integer            iwork( * )
      real               d( * ), e( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lquery, wantz
      integer            iscale, liwmin, lwmin
      real               bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tnrm
      logical            lsame
      real               slamch, slanst
      end subroutine sstevd

      !! sstev.f
      subroutine sstev( jobz, n, d, e, z, ldz, work, info )
      character          jobz
      integer            info, ldz, n
      real               d( * ), e( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            wantz
      integer            imax, iscale
      real               bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tnrm
      logical            lsame
      real               slamch, slanst
      end subroutine sstev

      !! sstevr.f
      subroutine sstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,
     &                   m, w, z, ldz, isuppz, work, lwork, iwork,
     &                   liwork, info )
      character          jobz, range
      integer            il, info, iu, ldz, liwork, lwork, m, n
      real               abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      real               d( * ), e( * ), w( * ), work( * ), z( ldz, * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      logical            alleig, indeig, test, lquery, valeig, wantz,
     &                   tryrac
      character          order
      integer            i, ieeeok, imax, indibl, indifl, indisp,
     &                   indiwo, iscale, j, jj, liwmin, lwmin, nsplit
      real               bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tmp1, tnrm, vll, vuu
      logical            lsame
      integer            ilaenv
      real               slamch, slanst
      end subroutine sstevr

      !! sstevx.f
      subroutine sstevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,
     &                   m, w, z, ldz, work, iwork, ifail, info )
      character          jobz, range
      integer            il, info, iu, ldz, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               d( * ), e( * ), w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            alleig, indeig, test, valeig, wantz
      character          order
      integer            i, imax, indibl, indisp, indiwo, indwrk,
     &                   iscale, itmp1, j, jj, nsplit
      real               bignum, eps, rmax, rmin, safmin, sigma, smlnum,
     &                   tmp1, tnrm, vll, vuu
      logical            lsame
      real               slamch, slanst
      end subroutine sstevx

      !! ssycon.f
      subroutine ssycon( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   iwork, info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine ssycon

      !! ssycon_rook.f
      subroutine ssycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   iwork, info )
      character          uplo
      integer            info, lda, n
      real               anorm, rcond
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, kase
      real               ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine ssycon_rook

      !! ssyconv.f
      subroutine ssyconv( uplo, way, n, a, lda, ipiv, e, info )
      character          uplo, way
      integer            info, lda, n
      integer            ipiv( * )
      real               a( lda, * ), e( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lsame
      logical            upper, convert
      integer            i, ip, j
      real               temp
      end subroutine ssyconv

      !! ssyequb.f
      subroutine ssyequb( uplo, n, a, lda, s, scond, amax, work, info )
      integer            info, lda, n
      real               amax, scond
      character          uplo
      real               a( lda, * ), s( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      integer            max_iter
      parameter          ( max_iter = 100 )
      integer            i, j, iter
      real               avg, std, tol, c0, c1, c2, t, u, si, d, base,
     &                   smin, smax, smlnum, bignum, scale, sumsq
      logical            up
      real               slamch
      logical            lsame
      end subroutine ssyequb

      !! ssyevd.f
      subroutine ssyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,
     &                   liwork, info )
      character          jobz, uplo
      integer            info, lda, liwork, lwork, n
      integer            iwork( * )
      real               a( lda, * ), w( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lower, lquery, wantz
      integer            iinfo, inde, indtau, indwk2, indwrk, iscale,
     &                   liopt, liwmin, llwork, llwrk2, lopt, lwmin
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      real               slamch, slansy
      end subroutine ssyevd

      !! ssyev.f
      subroutine ssyev( jobz, uplo, n, a, lda, w, work, lwork, info )
      character          jobz, uplo
      integer            info, lda, lwork, n
      real               a( lda, * ), w( * ), work( * )
      real               zero, one
      parameter          ( zero = 0.0e0, one = 1.0e0 )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indtau, indwrk, iscale,
     &                   llwork, lwkopt, nb
      real               anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      real               slamch, slansy
      end subroutine ssyev

      !! ssyevr.f
      subroutine ssyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, isuppz, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, liwork, lwork, m, n
      real               abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      real               a( lda, * ), w( * ), work( * ), z( ldz, * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      logical            alleig, indeig, lower, lquery, test, valeig,
     &                   wantz, tryrac
      character          order
      integer            i, ieeeok, iinfo, imax, indd, inddd, inde,
     &                   indee, indibl, indifl, indisp, indiwo, indtau,
     &                   indwk, indwkn, iscale, j, jj, liwmin,
     &                   llwork, llwrkn, lwkopt, lwmin, nb, nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      real               slamch, slansy
      end subroutine ssyevr

      !! ssyevx.f
      subroutine ssyevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, lwork, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, lwork, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               a( lda, * ), w( * ), work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            alleig, indeig, lower, lquery, test, valeig,
     &                   wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwo, indtau, indwkn, indwrk, iscale,
     &                   itmp1, j, jj, llwork, llwrkn, lwkmin,
     &                   lwkopt, nb, nsplit
      real               abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      real               slamch, slansy
      end subroutine ssyevx

      !! ssygs2.f
      subroutine ssygs2( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      real               a( lda, * ), b( ldb, * )
      real               one, half
      parameter          ( one = 1.0, half = 0.5 )
      logical            upper
      integer            k
      real               akk, bkk, ct
      logical            lsame
      end subroutine ssygs2

      !! ssygst.f
      subroutine ssygst( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      real               a( lda, * ), b( ldb, * )
      real               one, half
      parameter          ( one = 1.0, half = 0.5 )
      logical            upper
      integer            k, kb, nb
      logical            lsame
      integer            ilaenv
      end subroutine ssygst

      !! ssygvd.f
      subroutine ssygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                   lwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, liwork, lwork, n
      integer            iwork( * )
      real               a( lda, * ), b( ldb, * ), w( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lquery, upper, wantz
      character          trans
      integer            liopt, liwmin, lopt, lwmin
      logical            lsame
      end subroutine ssygvd

      !! ssygv.f
      subroutine ssygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                  lwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, lwork, n
      real               a( lda, * ), b( ldb, * ), w( * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lquery, upper, wantz
      character          trans
      integer            lwkmin, lwkopt, nb, neig
      logical            lsame
      integer            ilaenv
      end subroutine ssygv

      !! ssygvx.f
      subroutine ssygvx( itype, jobz, range, uplo, n, a, lda, b, ldb,
     &                   vl, vu, il, iu, abstol, m, w, z, ldz, work,
     &                   lwork, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, lda, ldb, ldz, lwork, m, n
      real               abstol, vl, vu
      integer            ifail( * ), iwork( * )
      real               a( lda, * ), b( ldb, * ), w( * ), work( * ),
     &                   z( ldz, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            alleig, indeig, lquery, upper, valeig, wantz
      character          trans
      integer            lwkmin, lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine ssygvx

      !! ssyrfs.f
      subroutine ssyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, iwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      real               two
      parameter          ( two = 2.0e+0 )
      real               three
      parameter          ( three = 3.0e+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine ssyrfs

      !! ssyrfsx.f
      subroutine ssyrfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    s, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, iwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               itref_default, ithresh_default,
     &                   componentwise_default
      real               rthresh_default, dzthresh_default
      parameter          ( itref_default = 1.0 )
      parameter          ( ithresh_default = 10.0 )
      parameter          ( componentwise_default = 1.0 )
      parameter          ( rthresh_default = 0.5 )
      parameter          ( dzthresh_default = 0.25 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type, n_norms
      real               anorm, rcond_tmp
      real               illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      real               rthresh, unstable_thresh
      real               slamch, slansy, sla_syrcond
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine ssyrfsx

      !! ssysv.f
      subroutine ssysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      real               a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine ssysv

      !! ssysv_rook.f
      subroutine ssysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      real               a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine ssysv_rook

      !! ssysvx.f
      subroutine ssysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,
     &                   ldb, x, ldx, rcond, ferr, berr, work, lwork,
     &                   iwork, info )
      character          fact, uplo
      integer            info, lda, ldaf, ldb, ldx, lwork, n, nrhs
      real               rcond
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   berr( * ), ferr( * ), work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery, nofact
      integer            lwkopt, nb
      real               anorm
      logical            lsame
      integer            ilaenv
      real               slamch, slansy
      end subroutine ssysvx

      !! ssysvxx.f
      subroutine ssysvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, iwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      real               rcond, rpvgrw
      integer            ipiv( * ), iwork( * )
      real               a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      real               s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      real               amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      real               slamch, sla_syrpvgrw
      end subroutine ssysvxx

      !! ssyswapr.f
      subroutine ssyswapr( uplo, n, a, lda, i1, i2)
      character        uplo
      integer          i1, i2, lda, n
      real             a( lda, n )
      logical            upper
      integer            i
      real               tmp
      logical            lsame
      end subroutine ssyswapr

      !! ssytd2.f
      subroutine ssytd2( uplo, n, a, lda, d, e, tau, info )
      character          uplo
      integer            info, lda, n
      real               a( lda, * ), d( * ), e( * ), tau( * )
      real               one, zero, half
      parameter          ( one = 1.0, zero = 0.0, half = 1.0 / 2.0 )
      logical            upper
      integer            i
      real               alpha, taui
      logical            lsame
      real               sdot
      end subroutine ssytd2

      !! ssytf2.f
      subroutine ssytf2( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      real               a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kk, kp, kstep
      real               absakk, alpha, colmax, d11, d12, d21, d22, r1,
     &                   rowmax, t, wk, wkm1, wkp1
      logical            lsame, sisnan
      integer            isamax
      end subroutine ssytf2

      !! ssytf2_rook.f
      subroutine ssytf2_rook( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      real               a( lda, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               eight, sevten
      parameter          ( eight = 8.0e+0, sevten = 17.0e+0 )
      logical            upper, done
      integer            i, imax, j, jmax, itemp, k, kk, kp, kstep,
     &                   p, ii
      real               absakk, alpha, colmax, d11, d12, d21, d22,
     &                   rowmax, stemp, t, wk, wkm1, wkp1, sfmin
      logical            lsame
      integer            isamax
      real               slamch
      end subroutine ssytf2_rook

      !! ssytrd.f
      subroutine ssytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      real               a( lda, * ), d( * ), e( * ), tau( * ),
     &                   work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lquery, upper
      integer            i, iinfo, iws, j, kk, ldwork, lwkopt, nb,
     &                   nbmin, nx
      logical            lsame
      integer            ilaenv
      end subroutine ssytrd

      !! ssytrf.f
      subroutine ssytrf( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      real               a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine ssytrf

      !! ssytrf_rook.f
      subroutine ssytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      real               a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine ssytrf_rook

      !! ssytri2.f
      subroutine ssytri2( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      real               a( lda, * ), work( * )
      logical            upper, lquery
      integer            minsize, nbmax
      logical            lsame
      integer            ilaenv
      end subroutine ssytri2

      !! ssytri2x.f
      subroutine ssytri2x( uplo, n, a, lda, ipiv, work, nb, info )
      character          uplo
      integer            info, lda, n, nb
      integer            ipiv( * )
      real               a( lda, * ), work( n+nb+1,* )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            i, iinfo, ip, k, cut, nnb
      integer            count
      integer            j, u11, invd
      real               ak, akkp1, akp1, d, t
      real               u01_i_j, u01_ip1_j
      real               u11_i_j, u11_ip1_j
      logical            lsame
      end subroutine ssytri2x

      !! ssytri.f
      subroutine ssytri( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            k, kp, kstep
      real               ak, akkp1, akp1, d, t, temp
      logical            lsame
      real               sdot
      end subroutine ssytri

      !! ssytri_rook.f
      subroutine ssytri_rook( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            upper
      integer            k, kp, kstep
      real               ak, akkp1, akp1, d, t, temp
      logical            lsame
      real               sdot
      end subroutine ssytri_rook

      !! ssytrs2.f
      subroutine ssytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                    work, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      real               a( lda, * ), b( ldb, * ), work( * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            i, iinfo, j, k, kp
      real               ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine ssytrs2

      !! ssytrs.f
      subroutine ssytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      real               a( lda, * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            j, k, kp
      real               ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine ssytrs

      !! ssytrs_rook.f
      subroutine ssytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                        info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      real               a( lda, * ), b( ldb, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            upper
      integer            j, k, kp
      real               ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine ssytrs_rook

      !! stbcon.f
      subroutine stbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,
     &                   iwork, info )
      character          diag, norm, uplo
      integer            info, kd, ldab, n
      real               rcond
      integer            iwork( * )
      real               ab( ldab, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, anorm, scale, smlnum, xnorm
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch, slantb
      end subroutine stbcon

      !! stbrfs.f
      subroutine stbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, x, ldx, ferr, berr, work, iwork, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, ldx, n, nrhs
      integer            iwork( * )
      real               ab( ldab, * ), b( ldb, * ), berr( * ),
     &                   ferr( * ), work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            notran, nounit, upper
      character          transt
      integer            i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine stbrfs

      !! stbtrs.f
      subroutine stbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, n, nrhs
      real               ab( ldab, * ), b( ldb, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nounit, upper
      integer            j
      logical            lsame
      end subroutine stbtrs

      !! stfsm.f
      subroutine stfsm( transr, side, uplo, trans, diag, m, n, alpha, a,
     &                  b, ldb )
      character          transr, diag, side, trans, uplo
      integer            ldb, m, n
      real               alpha
      real               a( 0: * ), b( 0: ldb-1, 0: * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            lower, lside, misodd, nisodd, normaltransr,
     &                   notrans
      integer            m1, m2, n1, n2, k, info, i, j
      logical            lsame
      end subroutine stfsm

      !! stftri.f
      subroutine stftri( transr, uplo, diag, n, a, info )
      character          transr, uplo, diag
      integer            info, n
      real               a( 0: * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine stftri

      !! stfttp.f
      subroutine stfttp( transr, uplo, n, arf, ap, info )
      character          transr, uplo
      integer            info, n
      real               ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine stfttp

      !! stfttr.f
      subroutine stfttr( transr, uplo, n, arf, a, lda, info )
      character          transr, uplo
      integer            info, n, lda
      real               a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt, nx2, np1x2
      integer            i, j, l, ij
      logical            lsame
      end subroutine stfttr

      !! stgevc.f
      subroutine stgevc( side, howmny, select, n, s, lds, p, ldp, vl,
     &                   ldvl, vr, ldvr, mm, m, work, info )
      character          howmny, side
      integer            info, ldp, lds, ldvl, ldvr, m, mm, n
      logical            select( * )
      real               p( ldp, * ), s( lds, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      real               zero, one, safety
      parameter          ( zero = 0.0e+0, one = 1.0e+0,
     &                   safety = 1.0e+2 )
      logical            compl, compr, il2by2, ilabad, ilall, ilback,
     &                   ilbbad, ilcomp, ilcplx, lsa, lsb
      integer            i, ibeg, ieig, iend, ihwmny, iinfo, im, iside,
     &                   j, ja, jc, je, jr, jw, na, nw
      real               acoef, acoefa, anorm, ascale, bcoefa, bcoefi,
     &                   bcoefr, big, bignum, bnorm, bscale, cim2a,
     &                   cim2b, cimaga, cimagb, cre2a, cre2b, creala,
     &                   crealb, dmin, safmin, salfar, sbeta, scale,
     &                   small, temp, temp2, temp2i, temp2r, ulp, xmax,
     &                   xscale
      real               bdiag( 2 ), sum( 2, 2 ), sums( 2, 2 ),
     &                   sump( 2, 2 )
      logical            lsame
      real               slamch
      end subroutine stgevc

      !! stgex2.f
      subroutine stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, j1, n1, n2, work, lwork, info )
      logical            wantq, wantz
      integer            info, j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
      real               a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      real               twenty
      parameter          ( twenty = 2.0e+01 )
      integer            ldst
      parameter          ( ldst = 4 )
      logical            wands
      parameter          ( wands = .true. )
      logical            strong, weak
      integer            i, idum, linfo, m
      real               bqra21, brqa21, ddum, dnorm, dscale, dsum, eps,
     &                   f, g, sa, sb, scale, smlnum, ss, thresh, ws
      integer            iwork( ldst )
      real               ai( 2 ), ar( 2 ), be( 2 ), ir( ldst, ldst ),
     &                   ircop( ldst, ldst ), li( ldst, ldst ),
     &                   licop( ldst, ldst ), s( ldst, ldst ),
     &                   scpy( ldst, ldst ), t( ldst, ldst ),
     &                   taul( ldst ), taur( ldst ), tcpy( ldst, ldst )
      real               slamch
      end subroutine stgex2

      !! stgexc.f
      subroutine stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, ifst, ilst, work, lwork, info )
      logical            wantq, wantz
      integer            ifst, ilst, info, lda, ldb, ldq, ldz, lwork, n
      real               a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery
      integer            here, lwmin, nbf, nbl, nbnext
      end subroutine stgexc

      !! stgsen.f
      subroutine stgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,
     &                   alphar, alphai, beta, q, ldq, z, ldz, m, pl,
     &                   pr, dif, work, lwork, iwork, liwork, info )
      logical            wantq, wantz
      integer            ijob, info, lda, ldb, ldq, ldz, liwork, lwork,
     &                   m, n
      real               pl, pr
      logical            select( * )
      integer            iwork( * )
      real               a( lda, * ), alphai( * ), alphar( * ),
     &                   b( ldb, * ), beta( * ), dif( * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      integer            idifjb
      parameter          ( idifjb = 3 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, pair, swap, wantd, wantd1, wantd2,
     &                   wantp
      integer            i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin,
     &                   mn2, n1, n2
      real               dscale, dsum, eps, rdscal, smlnum
      integer            isave( 3 )
      real               slamch
      end subroutine stgsen

      !! stgsja.f
      subroutine stgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,
     &                   ldb, tola, tolb, alpha, beta, u, ldu, v, ldv,
     &                   q, ldq, work, ncycle, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n,
     &                   ncycle, p
      real               tola, tolb
      real               a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), q( ldq, * ), u( ldu, * ),
     &                   v( ldv, * ), work( * )
      integer            maxit
      parameter          ( maxit = 40 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            initq, initu, initv, upper, wantq, wantu, wantv
      integer            i, j, kcycle
      real               a1, a2, a3, b1, b2, b3, csq, csu, csv, error,
     &                   gamma, rwk, snq, snu, snv, ssmin
      logical            lsame
      end subroutine stgsja

      !! stgsna.f
      subroutine stgsna( job, howmny, select, n, a, lda, b, ldb, vl,
     &                   ldvl, vr, ldvr, s, dif, mm, m, work, lwork,
     &                   iwork, info )
      character          howmny, job
      integer            info, lda, ldb, ldvl, ldvr, lwork, m, mm, n
      logical            select( * )
      integer            iwork( * )
      real               a( lda, * ), b( ldb, * ), dif( * ), s( * ),
     &                   vl( ldvl, * ), vr( ldvr, * ), work( * )
      integer            difdri
      parameter          ( difdri = 3 )
      real               zero, one, two, four
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0,
     &                   four = 4.0e+0 )
      logical            lquery, pair, somcon, wantbh, wantdf, wants
      integer            i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
      real               alphai, alphar, alprqt, beta, c1, c2, cond,
     &                   eps, lnrm, rnrm, root1, root2, scale, smlnum,
     &                   tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv,
     &                   uhbvi
      real               dummy( 1 ), dummy1( 1 )
      logical            lsame
      real               sdot, slamch, slapy2, snrm2
      end subroutine stgsna

      !! stgsy2.f
      subroutine stgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, rdsum, rdscal,
     &                   iwork, pq, info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf, m, n,
     &                   pq
      real               rdscal, rdsum, scale
      integer            iwork( * )
      real               a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * )
      integer            ldz
      parameter          ( ldz = 8 )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            notran
      integer            i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1,
     &                   k, mb, nb, p, q, zdim
      real               alpha, scaloc
      integer            ipiv( ldz ), jpiv( ldz )
      real               rhs( ldz ), z( ldz, ldz )
      logical            lsame
      end subroutine stgsy2

      !! stgsyl.f
      subroutine stgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, dif, work, lwork,
     &                   iwork, info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf,
     &                   lwork, m, n
      real               dif, scale
      integer            iwork( * )
      real               a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, notran
      integer            i, ie, ifunc, iround, is, isolve, j, je, js, k,
     &                   linfo, lwmin, mb, nb, p, ppqq, pq, q
      real               dscale, dsum, scale2, scaloc
      logical            lsame
      integer            ilaenv
      end subroutine stgsyl

      !! stpcon.f
      subroutine stpcon( norm, uplo, diag, n, ap, rcond, work, iwork,
     &                   info )
      character          diag, norm, uplo
      integer            info, n
      real               rcond
      integer            iwork( * )
      real               ap( * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, anorm, scale, smlnum, xnorm
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch, slantp
      end subroutine stpcon

      !! stpmqrt.f
      subroutine stpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,
     &                    a, lda, b, ldb, work, info )
      character side, trans
      integer   info, k, ldv, lda, ldb, m, n, l, nb, ldt
      real   v( ldv, * ), a( lda, * ), b( ldb, * ), t( ldt, * ),
     &          work( * )
      logical            left, right, tran, notran
      integer            i, ib, mb, lb, kf, ldaq, ldvq
      logical            lsame
      end subroutine stpmqrt

      !! stpqrt2.f
      subroutine stpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
      integer   info, lda, ldb, ldt, n, m, l
      real   a( lda, * ), b( ldb, * ), t( ldt, * )
      real  one, zero
      parameter( one = 1.0, zero = 0.0 )
      integer   i, j, p, mp, np
      real   alpha
      end subroutine stpqrt2

      !! stpqrt.f
      subroutine stpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,
     &                   info )
      integer info, lda, ldb, ldt, n, m, l, nb
      real a( lda, * ), b( ldb, * ), t( ldt, * ), work( * )
      integer    i, ib, lb, mb, iinfo
      end subroutine stpqrt

      !! stprfb.f
      subroutine stprfb( side, trans, direct, storev, m, n, k, l,
     &                   v, ldv, t, ldt, a, lda, b, ldb, work, ldwork )
      character direct, side, storev, trans
      integer   k, l, lda, ldb, ldt, ldv, ldwork, m, n
      real   a( lda, * ), b( ldb, * ), t( ldt, * ),
     &          v( ldv, * ), work( ldwork, * )
      real   one, zero
      parameter ( one = 1.0, zero = 0.0 )
      integer   i, j, mp, np, kp
      logical   left, forward, column, right, backward, row
      logical   lsame
      end subroutine stprfb

      !! stprfs.f
      subroutine stprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,
     &                   ferr, berr, work, iwork, info )
      character          diag, trans, uplo
      integer            info, ldb, ldx, n, nrhs
      integer            iwork( * )
      real               ap( * ), b( ldb, * ), berr( * ), ferr( * ),
     &                   work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            notran, nounit, upper
      character          transt
      integer            i, j, k, kase, kc, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine stprfs

      !! stptri.f
      subroutine stptri( uplo, diag, n, ap, info )
      character          diag, uplo
      integer            info, n
      real               ap( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, upper
      integer            j, jc, jclast, jj
      real               ajj
      logical            lsame
      end subroutine stptri

      !! stptrs.f
      subroutine stptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
      character          diag, trans, uplo
      integer            info, ldb, n, nrhs
      real               ap( * ), b( ldb, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            nounit, upper
      integer            j, jc
      logical            lsame
      end subroutine stptrs

      !! stpttf.f
      subroutine stpttf( transr, uplo, n, ap, arf, info )
      character          transr, uplo
      integer            info, n
      real               ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine stpttf

      !! stpttr.f
      subroutine stpttr( uplo, n, ap, a, lda, info )
      character          uplo
      integer            info, n, lda
      real               a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine stpttr

      !! strcon.f
      subroutine strcon( norm, uplo, diag, n, a, lda, rcond, work,
     &                   iwork, info )
      character          diag, norm, uplo
      integer            info, lda, n
      real               rcond
      integer            iwork( * )
      real               a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      real               ainvnm, anorm, scale, smlnum, xnorm
      integer            isave( 3 )
      logical            lsame
      integer            isamax
      real               slamch, slantr
      end subroutine strcon

      !! strevc.f
      subroutine strevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, mm, m, work, info )
      character          howmny, side
      integer            info, ldt, ldvl, ldvr, m, mm, n
      logical            select( * )
      real               t( ldt, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            allv, bothv, leftv, over, pair, rightv, somev
      integer            i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
      real               beta, bignum, emax, ovfl, rec, remax, scale,
     &                   smin, smlnum, ulp, unfl, vcrit, vmax, wi, wr,
     &                   xnorm
      logical            lsame
      integer            isamax
      real               sdot, slamch
      real               x( 2, 2 )
      end subroutine strevc

      !! strexc.f
      subroutine strexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,
     &                   info )
      character          compq
      integer            ifst, ilst, info, ldq, ldt, n
      real               q( ldq, * ), t( ldt, * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            wantq
      integer            here, nbf, nbl, nbnext
      logical            lsame
      end subroutine strexc

      !! strrfs.f
      subroutine strrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,
     &                   ldx, ferr, berr, work, iwork, info )
      character          diag, trans, uplo
      integer            info, lda, ldb, ldx, n, nrhs
      integer            iwork( * )
      real               a( lda, * ), b( ldb, * ), berr( * ), ferr( * ),
     &                   work( * ), x( ldx, * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            notran, nounit, upper
      character          transt
      integer            i, j, k, kase, nz
      real               eps, lstres, s, safe1, safe2, safmin, xk
      integer            isave( 3 )
      logical            lsame
      real               slamch
      end subroutine strrfs

      !! strsen.f
      subroutine strsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,
     &                   m, s, sep, work, lwork, iwork, liwork, info )
      character          compq, job
      integer            info, ldq, ldt, liwork, lwork, m, n
      real               s, sep
      logical            select( * )
      integer            iwork( * )
      real               q( ldq, * ), t( ldt, * ), wi( * ), work( * ),
     &                   wr( * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            lquery, pair, swap, wantbh, wantq, wants,
     &                    wantsp
      integer            ierr, k, kase, kk, ks, liwmin, lwmin, n1, n2,
     &                   nn
      real               est, rnorm, scale
      integer            isave( 3 )
      logical            lsame
      real               slange
      end subroutine strsen

      !! strsna.f
      subroutine strsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, s, sep, mm, m, work, ldwork, iwork,
     &                   info )
      character          howmny, job
      integer            info, ldt, ldvl, ldvr, ldwork, m, mm, n
      logical            select( * )
      integer            iwork( * )
      real               s( * ), sep( * ), t( ldt, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( ldwork, * )
      real               zero, one, two
      parameter          ( zero = 0.0e+0, one = 1.0e+0, two = 2.0e+0 )
      logical            pair, somcon, wantbh, wants, wantsp
      integer            i, ierr, ifst, ilst, j, k, kase, ks, n2, nn
      real               bignum, cond, cs, delta, dumm, eps, est, lnrm,
     &                   mu, prod, prod1, prod2, rnrm, scale, smlnum, sn
      integer            isave( 3 )
      real               dummy( 1 )
      logical            lsame
      real               sdot, slamch, slapy2, snrm2
      end subroutine strsna

      !! strsyl.f
      subroutine strsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,
     &                   ldc, scale, info )
      character          trana, tranb
      integer            info, isgn, lda, ldb, ldc, m, n
      real               scale
      real               a( lda, * ), b( ldb, * ), c( ldc, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            notrna, notrnb
      integer            ierr, j, k, k1, k2, knext, l, l1, l2, lnext
      real               a11, bignum, da11, db, eps, scaloc, sgn, smin,
     &                   smlnum, suml, sumr, xnorm
      real               dum( 1 ), vec( 2, 2 ), x( 2, 2 )
      logical            lsame
      real               sdot, slamch, slange
      end subroutine strsyl

      !! strti2.f
      subroutine strti2( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      real               a( lda, * )
      real               one
      parameter          ( one = 1.0e+0 )
      logical            nounit, upper
      integer            j
      real               ajj
      logical            lsame
      end subroutine strti2

      !! strtri.f
      subroutine strtri( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      real               a( lda, * )
      real               one, zero
      parameter          ( one = 1.0e+0, zero = 0.0e+0 )
      logical            nounit, upper
      integer            j, jb, nb, nn
      logical            lsame
      integer            ilaenv
      end subroutine strtri

      !! strtrs.f
      subroutine strtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,
     &                   info )
      character          diag, trans, uplo
      integer            info, lda, ldb, n, nrhs
      real               a( lda, * ), b( ldb, * )
      real               zero, one
      parameter          ( zero = 0.0e+0, one = 1.0e+0 )
      logical            nounit
      logical            lsame
      end subroutine strtrs

      !! strttf.f
      subroutine strttf( transr, uplo, n, a, lda, arf, info )
      character          transr, uplo
      integer            info, n, lda
      real               a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            i, ij, j, k, l, n1, n2, nt, nx2, np1x2
      logical            lsame
      end subroutine strttf

      !! strttp.f
      subroutine strttp( uplo, n, a, lda, ap, info )
      character          uplo
      integer            info, n, lda
      real               a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine strttp

      !! stzrzf.f
      subroutine stzrzf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      real               a( lda, * ), tau( * ), work( * )
      real               zero
      parameter          ( zero = 0.0e+0 )
      logical            lquery
      integer            i, ib, iws, ki, kk, ldwork, lwkmin, lwkopt,
     &                   m1, mu, nb, nbmin, nx
      integer            ilaenv
      end subroutine stzrzf

      !! xerbla_array.f
      subroutine xerbla_array( srname_array, srname_len, info)
      integer srname_len, info
      character(1) srname_array(srname_len)
      integer i
      character(len=32) srname
      end subroutine xerbla_array

      !! xerbla.f
      subroutine xerbla( srname, info )
      character*(*)      srname
      integer            info
      end subroutine xerbla

      !! zbbcsd.f
      subroutine zbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,
     &                   theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t,
     &                   v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,
     &                   b22d, b22e, rwork, lrwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
      double precision   b11d( * ), b11e( * ), b12d( * ), b12e( * ),
     &                   b21d( * ), b21e( * ), b22d( * ), b22e( * ),
     &                   phi( * ), theta( * ), rwork( * )
      complex(kind=16)   u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * )
      integer            maxitr
      parameter          ( maxitr = 6 )
      double precision   hundred, meighth, one, piover2, ten, zero
      parameter          ( hundred = 100.0d0, meighth = -0.125d0,
     &                     one = 1.0d0, piover2 = 1.57079632679489662d0,
     &                     ten = 10.0d0, zero = 0.0d0 )
      complex(kind=16)   negonecomplex
      parameter          ( negonecomplex = (-1.0d0,0.0d0) )
      logical            colmajor, lquery, restart11, restart12,
     &                   restart21, restart22, wantu1, wantu2, wantv1t,
     &                   wantv2t
      integer            i, imin, imax, iter, iu1cs, iu1sn, iu2cs,
     &                   iu2sn, iv1tcs, iv1tsn, iv2tcs, iv2tsn, j,
     &                   lrworkmin, lrworkopt, maxit, mini
      double precision   b11bulge, b12bulge, b21bulge, b22bulge, dummy,
     &                   eps, mu, nu, r, sigma11, sigma21,
     &                   temp, thetamax, thetamin, thresh, tol, tolmul,
     &                   unfl, x1, x2, y1, y2
      double precision   dlamch
      logical            lsame
      end subroutine zbbcsd

      !! zbdsqr.f
      subroutine zbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,
     &                   ldu, c, ldc, rwork, info )
      character          uplo
      integer            info, ldc, ldu, ldvt, n, ncc, ncvt, nru
      double precision   d( * ), e( * ), rwork( * )
      complex(kind=16)   c( ldc, * ), u( ldu, * ), vt( ldvt, * )
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   negone
      parameter          ( negone = -1.0d0 )
      double precision   hndrth
      parameter          ( hndrth = 0.01d0 )
      double precision   ten
      parameter          ( ten = 10.0d0 )
      double precision   hndrd
      parameter          ( hndrd = 100.0d0 )
      double precision   meigth
      parameter          ( meigth = -0.125d0 )
      integer            maxitr
      parameter          ( maxitr = 6 )
      logical            lower, rotate
      integer            i, idir, isub, iter, j, ll, lll, m, maxit, nm1,
     &                   nm12, nm13, oldll, oldm
      double precision   abse, abss, cosl, cosr, cs, eps, f, g, h, mu,
     &                   oldcs, oldsn, r, shift, sigmn, sigmx, sinl,
     &                   sinr, sll, smax, smin, sminl, sminoa,
     &                   sn, thresh, tol, tolmul, unfl
      logical            lsame
      double precision   dlamch
      end subroutine zbdsqr

      !! zcgesv.f
      subroutine zcgesv( n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work,
     &                   swork, rwork, iter, info )
      integer            info, iter, lda, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   rwork( * )
      complex            swork( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( n, * ),
     &                   x( ldx, * )
      logical            doitref
      parameter          ( doitref = .true. )
      integer            itermax
      parameter          ( itermax = 30 )
      double precision   bwdmax
      parameter          ( bwdmax = 1.0e+00 )
      complex(kind=16)   negone, one
      parameter          ( negone = ( -1.0d+00, 0.0d+00 ),
     &                   one = ( 1.0d+00, 0.0d+00 ) )
      integer            i, iiter, ptsa, ptsx
      double precision   anrm, cte, eps, rnrm, xnrm
      complex(kind=16)   zdum
      integer            izamax
      double precision   dlamch, zlange
      double precision   cabs1
      end subroutine zcgesv

      !! zcposv.f
      subroutine zcposv( uplo, n, nrhs, a, lda, b, ldb, x, ldx, work,
     &                   swork, rwork, iter, info )
      character          uplo
      integer            info, iter, lda, ldb, ldx, n, nrhs
      double precision   rwork( * )
      complex            swork( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( n, * ),
     &                   x( ldx, * )
      logical            doitref
      parameter          ( doitref = .true. )
      integer            itermax
      parameter          ( itermax = 30 )
      double precision   bwdmax
      parameter          ( bwdmax = 1.0e+00 )
      complex(kind=16)   negone, one
      parameter          ( negone = ( -1.0d+00, 0.0d+00 ),
     &                   one = ( 1.0d+00, 0.0d+00 ) )
      integer            i, iiter, ptsa, ptsx
      double precision   anrm, cte, eps, rnrm, xnrm
      complex(kind=16)   zdum
      integer            izamax
      double precision   dlamch, zlanhe
      logical            lsame
      double precision   cabs1
      end subroutine zcposv

      !! zdrscl.f
      subroutine zdrscl( n, sa, sx, incx )
      integer            incx, n
      double precision   sa
      complex(kind=16)   sx( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            done
      double precision   bignum, cden, cden1, cnum, cnum1, mul, smlnum
      double precision   dlamch
      end subroutine zdrscl

      !! zgbbrd.f
      subroutine zgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,
     &                   ldq, pt, ldpt, c, ldc, work, rwork, info )
      character          vect
      integer            info, kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
      double precision   d( * ), e( * ), rwork( * )
      complex(kind=16)   ab( ldab, * ), c( ldc, * ), pt( ldpt, * ),
     &                   q( ldq, * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            wantb, wantc, wantpt, wantq
      integer            i, inca, j, j1, j2, kb, kb1, kk, klm, klu1,
     &                   kun, l, minmn, ml, ml0, mu, mu0, nr, nrt
      double precision   abst, rc
      complex(kind=16)   ra, rb, rs, t
      logical            lsame
      end subroutine zgbbrd

      !! zgbcon.f
      subroutine zgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,
     &                   work, rwork, info )
      character          norm
      integer            info, kl, ku, ldab, n
      double precision   anorm, rcond
      integer            ipiv( * )
      double precision   rwork( * )
      complex(kind=16)   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            lnoti, onenrm
      character          normin
      integer            ix, j, jp, kase, kase1, kd, lm
      double precision   ainvnm, scale, smlnum
      complex(kind=16)   t, zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch
      complex(kind=16)   zdotc
      double precision   cabs1
      end subroutine zgbcon

      !! zgbequb.f
      subroutine zgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                    amax, info )
      integer            info, kl, ku, ldab, m, n
      double precision   amax, colcnd, rowcnd
      double precision   c( * ), r( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, kd
      double precision   bignum, rcmax, rcmin, smlnum, radix,
     &                   logrdx
      complex(kind=16)   zdum
      double precision   dlamch
      double precision   cabs1
      end subroutine zgbequb

      !! zgbequ.f
      subroutine zgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, info )
      integer            info, kl, ku, ldab, m, n
      double precision   amax, colcnd, rowcnd
      double precision   c( * ), r( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, kd
      double precision   bignum, rcmax, rcmin, smlnum
      complex(kind=16)   zdum
      double precision   dlamch
      double precision   cabs1
      end subroutine zgbequ

      !! zgbrfs.f
      subroutine zgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, rwork,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, k, kase, kk, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zgbrfs

      !! zgbrfsx.f
      subroutine zgbrfsx( trans, equed, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, r, c, b, ldb, x, ldx, rcond,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, rwork,
     &                    info )
      character          trans, equed
      integer            info, ldab, ldafb, ldb, ldx, n, kl, ku, nrhs,
     &                   nparams, n_err_bnds
      double precision   rcond
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran, ignore_cwise
      integer            j, trans_type, prec_type, ref_type, n_norms,
     &                   ithresh
      double precision   anorm, rcond_tmp, illrcond_thresh, err_lbnd,
     &                   cwise_wrong, rthresh, unstable_thresh
      double precision   dlamch, zlangb, zla_gbrcond_x, zla_gbrcond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine zgbrfsx

      !! zgbsv.f
      subroutine zgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * ), b( ldb, * )
      end subroutine zgbsv

      !! zgbsvx.f
      subroutine zgbsvx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                   ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, rwork, info )
      character          equed, fact, trans
      integer            info, kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * )
      double precision   berr( * ), c( * ), ferr( * ), r( * ),
     &                   rwork( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j, j1, j2
      double precision   amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      double precision   dlamch, zlangb, zlantb
      end subroutine zgbsvx

      !! zgbsvxx.f
      subroutine zgbsvxx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,
     &                    ldafb, ipiv, equed, r, c, b, ldb, x, ldx,
     &                    rcond, rpvgrw, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          equed, fact, trans
      integer            info, ldab, ldafb, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, i, j, kl, ku
      double precision   amax, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, smlnum
      logical            lsame
      double precision   dlamch, zla_gbrpvgrw
      end subroutine zgbsvxx

      !! zgbtf2.f
      subroutine zgbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, j, jp, ju, km, kv
      integer            izamax
      end subroutine zgbtf2

      !! zgbtrf.f
      subroutine zgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
      integer            info, kl, ku, ldab, m, n
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      integer            nbmax, ldwork
      parameter          ( nbmax = 64, ldwork = nbmax+1 )
      integer            i, i2, i3, ii, ip, j, j2, j3, jb, jj, jm, jp,
     &                   ju, k2, km, kv, nb, nw
      complex(kind=16)   temp
      complex(kind=16)   work13( ldwork, nbmax ),
     &                   work31( ldwork, nbmax )
      integer            ilaenv, izamax
      end subroutine zgbtrf

      !! zgbtrs.f
      subroutine zgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, kl, ku, ldab, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            lnoti, notran
      integer            i, j, kd, l, lm
      logical            lsame
      end subroutine zgbtrs

      !! zgebak.f
      subroutine zgebak( job, side, n, ilo, ihi, scale, m, v, ldv,
     &                   info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      double precision   scale( * )
      complex(kind=16)   v( ldv, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            leftv, rightv
      integer            i, ii, k
      double precision   s
      logical            lsame
      end subroutine zgebak

      !! zgebal.f
      subroutine zgebal( job, n, a, lda, ilo, ihi, scale, info )
      character          job
      integer            ihi, ilo, info, lda, n
      double precision   scale( * )
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   sclfac
      parameter          ( sclfac = 2.0d+0 )
      double precision   factor
      parameter          ( factor = 0.95d+0 )
      logical            noconv
      integer            i, ica, iexc, ira, j, k, l, m
      double precision   c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1,
     &                   sfmin2
      complex(kind=16)   cdum
      logical            disnan, lsame
      integer            izamax
      double precision   dlamch, dznrm2
      end subroutine zgebal

      !! zgebd2.f
      subroutine zgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
      integer            info, lda, m, n
      double precision   d( * ), e( * )
      complex(kind=16)   a( lda, * ), taup( * ), tauq( * ), work( * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      integer            i
      complex(kind=16)   alpha
      end subroutine zgebd2

      !! zgebrd.f
      subroutine zgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,
     &                   info )
      integer            info, lda, lwork, m, n
      double precision   d( * ), e( * )
      complex(kind=16)   a( lda, * ), taup( * ), tauq( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, iinfo, j, ldwrkx, ldwrky, lwkopt, minmn, nb,
     &                   nbmin, nx
      double precision   ws
      integer            ilaenv
      end subroutine zgebrd

      !! zgecon.f
      subroutine zgecon( norm, n, a, lda, anorm, rcond, work, rwork,
     &                   info )
      character          norm
      integer            info, lda, n
      double precision   anorm, rcond
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            onenrm
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, scale, sl, smlnum, su
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zgecon

      !! zgeequb.f
      subroutine zgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                    info )
      integer            info, lda, m, n
      double precision   amax, colcnd, rowcnd
      double precision   c( * ), r( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   bignum, rcmax, rcmin, smlnum, radix, logrdx
      complex(kind=16)   zdum
      double precision   dlamch
      double precision   cabs1
      end subroutine zgeequb

      !! zgeequ.f
      subroutine zgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   info )
      integer            info, lda, m, n
      double precision   amax, colcnd, rowcnd
      double precision   c( * ), r( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   bignum, rcmax, rcmin, smlnum
      complex(kind=16)   zdum
      double precision   dlamch
      double precision   cabs1
      end subroutine zgeequ

      !! zgees.f
      subroutine zgees( jobvs, sort, select, n, a, lda, sdim, w, vs,
     &                  ldvs, work, lwork, rwork, bwork, info )
      character          jobvs, sort
      integer            info, lda, ldvs, lwork, n, sdim
      logical            bwork( * )
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), vs( ldvs, * ), w( * ), work( * )
      logical            select
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, scalea, wantst, wantvs
      integer            hswork, i, ibal, icond, ierr, ieval, ihi, ilo,
     &                   itau, iwrk, maxwrk, minwrk
      double precision   anrm, bignum, cscale, eps, s, sep, smlnum
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgees

      !! zgeesx.f
      subroutine zgeesx( jobvs, sort, select, sense, n, a, lda, sdim, w,
     &                   vs, ldvs, rconde, rcondv, work, lwork, rwork,
     &                   bwork, info )
      character          jobvs, sense, sort
      integer            info, lda, ldvs, lwork, n, sdim
      double precision   rconde, rcondv
      logical            bwork( * )
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), vs( ldvs, * ), w( * ), work( * )
      logical            select
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, scalea, wantsb, wantse, wantsn, wantst,
     &                   wantsv, wantvs
      integer            hswork, i, ibal, icond, ierr, ieval, ihi, ilo,
     &                   itau, iwrk, lwrk, maxwrk, minwrk
      double precision   anrm, bignum, cscale, eps, smlnum
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgeesx

      !! zgeev.f
      subroutine zgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,
     &                  work, lwork, rwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldvl, ldvr, lwork, n
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   w( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, scalea, wantvl, wantvr
      character          side
      integer            hswork, i, ibal, ierr, ihi, ilo, irwork, itau,
     &                   iwrk, k, maxwrk, minwrk, nout
      double precision   anrm, bignum, cscale, eps, scl, smlnum
      complex(kind=16)   tmp
      logical            select( 1 )
      double precision   dum( 1 )
      logical            lsame
      integer            idamax, ilaenv
      double precision   dlamch, dznrm2, zlange
      end subroutine zgeev

      !! zgeevx.f
      subroutine zgeevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,
     &                   ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde,
     &                   rcondv, work, lwork, rwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldvl, ldvr, lwork, n
      double precision   abnrm
      double precision   rconde( * ), rcondv( * ), rwork( * ),
     &                   scale( * )
      complex(kind=16)   a( lda, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   w( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, scalea, wantvl, wantvr, wntsnb, wntsne,
     &                   wntsnn, wntsnv
      character          job, side
      integer            hswork, i, icond, ierr, itau, iwrk, k, maxwrk,
     &                   minwrk, nout
      double precision   anrm, bignum, cscale, eps, scl, smlnum
      complex(kind=16)   tmp
      logical            select( 1 )
      double precision   dum( 1 )
      logical            lsame
      integer            idamax, ilaenv
      double precision   dlamch, dznrm2, zlange
      end subroutine zgeevx

      !! zgehd2.f
      subroutine zgehd2( n, ilo, ihi, a, lda, tau, work, info )
      integer            ihi, ilo, info, lda, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      integer            i
      complex(kind=16)   alpha
      end subroutine zgehd2

      !! zgehrd.f
      subroutine zgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      complex(kind=16)  a( lda, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      complex(kind=16)  zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                     one = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iwt, j, ldwork, lwkopt, nb,
     &                   nbmin, nh, nx
      complex(kind=16)  ei
      integer            ilaenv
      end subroutine zgehrd

      !! zgejsv.f
      subroutine zgejsv( joba, jobu, jobv, jobr, jobt, jobp,
     &                   m, n, a, lda, sva, u, ldu, v, ldv,
     &                   cwork, lwork, rwork, lrwork, iwork, info )
      integer     info, lda, ldu, ldv, lwork, lrwork, m, n
      double complex   a( lda, * ), u( ldu, * ), v( ldv, * ),
     &                 cwork( lwork )
      double precision sva( n ), rwork( * )
      integer          iwork( * )
      character(len=1) joba, jobp, jobr, jobt, jobu, jobv
      double precision zero,         one
      parameter ( zero = 0.0d0, one = 1.0d0 )
      double complex            czero,       cone
      parameter  ( czero = ( 0.0d0, 0.0d0 ), cone = ( 1.0d0, 0.0d0 ) )
      double complex   ctemp
      double precision aapp,    aaqq,   aatmax, aatmin, big,    big1,
     &                 cond_ok, condr1, condr2, entra,  entrat, epsln,
     &                 maxprj,  scalem, sconda, sfmin,  small,  temp1,
     &                 uscal1,  uscal2, xsc
      integer ierr,   n1,     nr,     numrank,        p, q,   warning
      logical almort, defr,   errest, goscal, jracc,  kill,   lsvec,
     &        l2aber, l2kill, l2pert, l2rank, l2tran,
     &        noscal, rowpiv, rsvec,  transp
      double precision      dlamch, dznrm2
      integer   idamax
      logical   lsame
      end subroutine zgejsv

      !! zgelq2.f
      subroutine zgelq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      integer            i, k
      complex(kind=16)   alpha
      end subroutine zgelq2

      !! zgelqf.f
      subroutine zgelqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine zgelqf

      !! zgelsd.f
      subroutine zgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,
     &                   work, lwork, rwork, iwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      double precision   rcond
      integer            iwork( * )
      double precision   rwork( * ), s( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      complex(kind=16)   czero
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            iascl, ibscl, ie, il, itau, itaup, itauq,
     &                   ldwork, liwork, lrwork, maxmn, maxwrk, minmn,
     &                   minwrk, mm, mnthr, nlvl, nrwork, nwork, smlsiz
      double precision   anrm, bignum, bnrm, eps, sfmin, smlnum
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgelsd

      !! zgels.f
      subroutine zgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,
     &                  info )
      character          trans
      integer            info, lda, ldb, lwork, m, n, nrhs
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery, tpsd
      integer            brow, i, iascl, ibscl, j, mn, nb, scllen, wsize
      double precision   anrm, bignum, bnrm, smlnum
      double precision   rwork( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgels

      !! zgelss.f
      subroutine zgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,
     &                   work, lwork, rwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      double precision   rcond
      double precision   rwork( * ), s( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            bl, chunk, i, iascl, ibscl, ie, il, irwork,
     &                   itau, itaup, itauq, iwork, ldwork, maxmn,
     &                   maxwrk, minmn, minwrk, mm, mnthr
      integer            lwork_zgeqrf, lwork_zunmqr, lwork_zgebrd,
     &                   lwork_zunmbr, lwork_zungbr, lwork_zunmlq,
     &                   lwork_zgelqf
      double precision   anrm, bignum, bnrm, eps, sfmin, smlnum, thr
      complex(kind=16)   dum( 1 )
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgelss

      !! zgelsy.f
      subroutine zgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,
     &                   work, lwork, rwork, info )
      integer            info, lda, ldb, lwork, m, n, nrhs, rank
      double precision   rcond
      integer            jpvt( * )
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      integer            imax, imin
      parameter          ( imax = 1, imin = 2 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, iascl, ibscl, ismax, ismin, j, lwkopt, mn,
     &                   nb, nb1, nb2, nb3, nb4
      double precision   anrm, bignum, bnrm, smax, smaxpr, smin, sminpr,
     &                   smlnum, wsize
      complex(kind=16)   c1, c2, s1, s2
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgelsy

      !! zgemqrt.f
      subroutine zgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,
     &                   c, ldc, work, info )
      character side, trans
      integer   info, k, ldv, ldc, m, n, nb, ldt
      complex(kind=16) v( ldv, * ), c( ldc, * ), t( ldt, * ), work( * )
      logical            left, right, tran, notran
      integer            i, ib, ldwork, kf, q
      logical            lsame
      end subroutine zgemqrt

      !! zgeql2.f
      subroutine zgeql2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      integer            i, k
      complex(kind=16)   alpha
      end subroutine zgeql2

      !! zgeqlf.f
      subroutine zgeqlf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine zgeqlf

      !! zgeqp3.f
      subroutine zgeqp3( m, n, a, lda, jpvt, tau, work, lwork, rwork,
     &                   info )
      integer            info, lda, lwork, m, n
      integer            jpvt( * )
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      integer            inb, inbmin, ixover
      parameter          ( inb = 1, inbmin = 2, ixover = 3 )
      logical            lquery
      integer            fjb, iws, j, jb, lwkopt, minmn, minws, na, nb,
     &                   nbmin, nfxd, nx, sm, sminmn, sn, topbmn
      integer            ilaenv
      double precision   dznrm2
      end subroutine zgeqp3

      !! zgeqr2.f
      subroutine zgeqr2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      integer            i, k
      complex(kind=16)   alpha
      end subroutine zgeqr2

      !! zgeqr2p.f
      subroutine zgeqr2p( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      integer            i, k
      complex(kind=16)   alpha
      end subroutine zgeqr2p

      !! zgeqrf.f
      subroutine zgeqrf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine zgeqrf

      !! zgeqrfp.f
      subroutine zgeqrfp( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ldwork, lwkopt, nb,
     &                   nbmin, nx
      integer            ilaenv
      end subroutine zgeqrfp

      !! zgeqrt2.f
      subroutine zgeqrt2( m, n, a, lda, t, ldt, info )
      integer   info, lda, ldt, m, n
      complex(kind=16) a( lda, * ), t( ldt, * )
      complex(kind=16) one, zero
      parameter( one = (1.0d+00,0.0d+00), zero = (0.0d+00,0.0d+00) )
      integer   i, k
      complex(kind=16) aii, alpha
      end subroutine zgeqrt2

      !! zgeqrt3.f
      recursive subroutine zgeqrt3( m, n, a, lda, t, ldt, info )
      integer   info, lda, m, n, ldt
      complex(kind=16) a( lda, * ), t( ldt, * )
      complex(kind=16) one
      parameter ( one = (1.0d+00,0.0d+00) )
      integer   i, i1, j, j1, n1, n2, iinfo
      end subroutine zgeqrt3

      !! zgeqrt.f
      subroutine zgeqrt( m, n, nb, a, lda, t, ldt, work, info )
      integer info, lda, ldt, m, n, nb
      complex(kind=16) a( lda, * ), t( ldt, * ), work( * )
      integer    i, ib, iinfo, k
      logical    use_recursive_qr
      parameter( use_recursive_qr=.true. )
      end subroutine zgeqrt

      !! zgerfs.f
      subroutine zgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, rwork, info )
      character          trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zgerfs

      !! zgerfsx.f
      subroutine zgerfsx( trans, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          trans, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ), work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rowequ, colequ, notran
      integer            j, trans_type, prec_type, ref_type
      integer            n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, zlange, zla_gercond_x, zla_gercond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine zgerfsx

      !! zgerq2.f
      subroutine zgerq2( m, n, a, lda, tau, work, info )
      integer            info, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      integer            i, k
      complex(kind=16)   alpha
      end subroutine zgerq2

      !! zgerqf.f
      subroutine zgerqf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      logical            lquery
      integer            i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt,
     &                   mu, nb, nbmin, nu, nx
      integer            ilaenv
      end subroutine zgerqf

      !! zgesc2.f
      subroutine zgesc2( n, a, lda, rhs, ipiv, jpiv, scale )
      integer            lda, n
      double precision   scale
      integer            ipiv( * ), jpiv( * )
      complex(kind=16)   a( lda, * ), rhs( * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      integer            i, j
      double precision   bignum, eps, smlnum
      complex(kind=16)   temp
      integer            izamax
      double precision   dlamch
      end subroutine zgesc2

      !! zgesdd.f
      subroutine zgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work,
     &                   lwork, rwork, iwork, info )
      character          jobz
      integer            info, lda, ldu, ldvt, lwork, m, n
      integer            iwork( * )
      double precision   rwork( * ), s( * )
      complex(kind=16)   a( lda, * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      integer            lquerv
      parameter          ( lquerv = -1 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            wntqa, wntqas, wntqn, wntqo, wntqs
      integer            blk, chunk, i, ie, ierr, il, ir, iru, irvt,
     &                   iscl, itau, itaup, itauq, iu, ivt, ldwkvt,
     &                   ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk,
     &                   mnthr1, mnthr2, nrwork, nwork, wrkbl
      double precision   anrm, bignum, eps, smlnum
      integer            idum( 1 )
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgesdd

      !! zgesvd.f
      subroutine zgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,
     &                   vt, ldvt, work, lwork, rwork, info )
      character          jobu, jobvt
      integer            info, lda, ldu, ldvt, lwork, m, n
      double precision   rwork( * ), s( * )
      complex(kind=16)   a( lda, * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lquery, wntua, wntuas, wntun, wntuo, wntus,
     &                   wntva, wntvas, wntvn, wntvo, wntvs
      integer            blk, chunk, i, ie, ierr, ir, irwork, iscl,
     &                   itau, itaup, itauq, iu, iwork, ldwrkr, ldwrku,
     &                   maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru,
     &                   nrvt, wrkbl
      integer            lwork_zgeqrf, lwork_zungqr_n, lwork_zungqr_m,
     &                   lwork_zgebrd, lwork_zungbr_p, lwork_zungbr_q,
     &                   lwork_zgelqf, lwork_zunglq_n, lwork_zunglq_m
      double precision   anrm, bignum, eps, smlnum
      double precision   dum( 1 )
      complex(kind=16)   cdum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgesvd

      !! zgesvdx.f
      subroutine zgesvdx( jobu, jobvt, range, m, n, a, lda, vl, vu,
     &                    il, iu, ns, s, u, ldu, vt, ldvt, work,
     &                    lwork, rwork, iwork, info )
      character          jobu, jobvt, range
      integer            il, info, iu, lda, ldu, ldvt, lwork, m, n, ns
      double precision   vl, vu
      integer            iwork( * )
      double precision   s( * ), rwork( * )
      complex(kind=16)   a( lda, * ), u( ldu, * ), vt( ldvt, * ),
     &                   work( * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      character          jobz, rngtgk
      logical            alls, inds, lquery, vals, wantu, wantvt
      integer            i, id, ie, ierr, ilqf, iltgk, iqrf, iscl,
     &                   itau, itaup, itauq, itemp, itgkz, iutgk,
     &                   j, k, maxwrk, minmn, minwrk, mnthr
      double precision   abstol, anrm, bignum, eps, smlnum
      double precision   dum( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgesvdx

      !! zgesv.f
      subroutine zgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * )
      end subroutine zgesv

      !! zgesvj.f
      subroutine zgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,
     &                   ldv, cwork, lwork, rwork, lrwork, info )
      integer            info, lda, ldv, lwork, lrwork, m, mv, n
      character(len=1)   joba, jobu, jobv
      complex(kind=16)   a( lda, * ),  v( ldv, * ), cwork( lwork )
      double precision   rwork( lrwork ), sva( n )
      double precision   zero,         half,         one
      parameter  ( zero = 0.0d0, half = 0.5d0, one = 1.0d0)
      complex(kind=16) czero,                  cone
      parameter  ( czero = (0.0d0, 0.0d0), cone = (1.0d0, 0.0d0) )
      integer      nsweep
      parameter  ( nsweep = 30 )
      complex(kind=16) aapq, ompq
      double precision    aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big,
     &        bigtheta, cs, ctol, epsln, large, mxaapq,
     &        mxsinj, rootbig, rooteps, rootsfmin, roottol,
     &        skl, sfmin, small, sn, t, temp1, theta, thsign, tol
      integer blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &        iswrot, jbc, jgl, kbl, lkahead, mvl, n2, n34,
     &        n4, nbl, notrot, p, pskipped, q, rowskip, swband
      logical applv, goscale, lower, lsvec, noscale, rotok,
     &        rsvec, uctol, upper
      double precision   dznrm2
      complex(kind=16)   zdotc
      integer            idamax
      double precision   dlamch
      logical            lsame
      end subroutine zgesvj

      !! zgesvx.f
      subroutine zgesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                   equed, r, c, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, rwork, info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * )
      double precision   berr( * ), c( * ), ferr( * ), r( * ),
     &                   rwork( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            colequ, equil, nofact, notran, rowequ
      character          norm
      integer            i, infequ, j
      double precision   amax, anorm, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, rpvgrw, smlnum
      logical            lsame
      double precision   dlamch, zlange, zlantr
      end subroutine zgesvx

      !! zgesvxx.f
      subroutine zgesvxx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, r, c, b, ldb, x, ldx, rcond, rpvgrw,
     &                    berr, n_err_bnds, err_bnds_norm,
     &                    err_bnds_comp, nparams, params, work, rwork,
     &                    info )
      character          equed, fact, trans
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx , * ),work( * )
      double precision   r( * ), c( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            colequ, equil, nofact, notran, rowequ
      integer            infequ, j
      double precision   amax, bignum, colcnd, rcmax, rcmin,
     &                   rowcnd, smlnum
      logical            lsame
      double precision   dlamch, zla_gerpvgrw
      end subroutine zgesvxx

      !! zgetc2.f
      subroutine zgetc2( n, a, lda, ipiv, jpiv, info )
      integer            info, lda, n
      integer            ipiv( * ), jpiv( * )
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i, ip, ipv, j, jp, jpv
      double precision   bignum, eps, smin, smlnum, xmax
      double precision   dlamch
      end subroutine zgetc2

      !! zgetf2.f
      subroutine zgetf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      double precision   sfmin
      integer            i, j, jp
      double precision   dlamch
      integer            izamax
      end subroutine zgetf2

      !! zgetrf2.f
      recursive subroutine zgetrf2( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                     zero = ( 0.0d+0, 0.0d+0 ) )
      double precision   sfmin
      complex(kind=16)   temp
      integer            i, iinfo, n1, n2
      double precision   dlamch
      integer            izamax
      end subroutine zgetrf2

      !! zgetrf.f
      subroutine zgetrf( m, n, a, lda, ipiv, info )
      integer            info, lda, m, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      integer            i, iinfo, j, jb, nb
      integer            ilaenv
      end subroutine zgetrf

      !! zgetri.f
      subroutine zgetri( n, a, lda, ipiv, work, lwork, info )
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, iws, j, jb, jj, jp, ldwork, lwkopt, nb,
     &                   nbmin, nn
      integer            ilaenv
      end subroutine zgetri

      !! zgetrs.f
      subroutine zgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          trans
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            notran
      logical            lsame
      end subroutine zgetrs

      !! zggbak.f
      subroutine zggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,
     &                   ldv, info )
      character          job, side
      integer            ihi, ilo, info, ldv, m, n
      double precision   lscale( * ), rscale( * )
      complex(kind=16)   v( ldv, * )
      logical            leftv, rightv
      integer            i, k
      logical            lsame
      end subroutine zggbak

      !! zggbal.f
      subroutine zggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,
     &                   rscale, work, info )
      character          job
      integer            ihi, ilo, info, lda, ldb, n
      double precision   lscale( * ), rscale( * ), work( * )
      complex(kind=16)   a( lda, * ), b( ldb, * )
      double precision   zero, half, one
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0 )
      double precision   three, sclfac
      parameter          ( three = 3.0d+0, sclfac = 1.0d+1 )
      complex(kind=16)   czero
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, icab, iflow, ip1, ir, irab, it, j, jc, jp1,
     &                   k, kount, l, lcab, lm1, lrab, lsfmax, lsfmin,
     &                   m, nr, nrp2
      double precision   alpha, basl, beta, cab, cmax, coef, coef2,
     &                   coef5, cor, ew, ewc, gamma, pgamma, rab, sfmax,
     &                   sfmin, sum, t, ta, tb, tc
      complex(kind=16)   cdum
      logical            lsame
      integer            izamax
      double precision   ddot, dlamch
      double precision   cabs1
      end subroutine zggbal

      !! zgges3.f
      subroutine zgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,
     &                   ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr,
     &                   work, lwork, rwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, iright, irows, irwrk, itau, iwrk, lwkopt
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, smlnum
      integer            idum( 1 )
      double precision   dif( 2 )
      logical            lsame
      double precision   dlamch, zlange
      end subroutine zgges3

      !! zgges.f
      subroutine zgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,
     &                  sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work,
     &                  lwork, rwork, bwork, info )
      character          jobvsl, jobvsr, sort
      integer            info, lda, ldb, ldvsl, ldvsr, lwork, n, sdim
      logical            bwork( * )
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, wantst
      integer            i, icols, ierr, ihi, ijobvl, ijobvr, ileft,
     &                   ilo, iright, irows, irwrk, itau, iwrk, lwkmin,
     &                   lwkopt
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl,
     &                   pvsr, smlnum
      integer            idum( 1 )
      double precision   dif( 2 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zgges

      !! zggesx.f
      subroutine zggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,
     &                   b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr,
     &                   ldvsr, rconde, rcondv, work, lwork, rwork,
     &                   iwork, liwork, bwork, info )
      character          jobvsl, jobvsr, sense, sort
      integer            info, lda, ldb, ldvsl, ldvsr, liwork, lwork, n,
     &                   sdim
      logical            bwork( * )
      integer            iwork( * )
      double precision   rconde( 2 ), rcondv( 2 ), rwork( * )
      complex(kind=16)   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vsl( ldvsl, * ), vsr( ldvsr, * ),
     &                   work( * )
      logical            selctg
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl,
     &                   lquery, wantsb, wantse, wantsn, wantst, wantsv
      integer            i, icols, ierr, ihi, ijob, ijobvl, ijobvr,
     &                   ileft, ilo, iright, irows, irwrk, itau, iwrk,
     &                   liwmin, lwrk, maxwrk, minwrk
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps, pl,
     &                   pr, smlnum
      double precision   dif( 2 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      end subroutine zggesx

      !! zggev3.f
      subroutine zggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,
     &                   vl, ldvl, vr, ldvr, work, lwork, rwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, irwrk, itau, iwrk, jc, jr,
     &                   lwkopt
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      complex(kind=16)   x
      logical            ldumma( 1 )
      logical            lsame
      double precision   dlamch, zlange
      double precision   abs1
      end subroutine zggev3

      !! zggev.f
      subroutine zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,
     &                  vl, ldvl, vr, ldvr, work, lwork, rwork, info )
      character          jobvl, jobvr
      integer            info, lda, ldb, ldvl, ldvr, lwork, n
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery
      character          chtemp
      integer            icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo,
     &                   in, iright, irows, irwrk, itau, iwrk, jc, jr,
     &                   lwkmin, lwkopt
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      complex(kind=16)   x
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      double precision   abs1
      end subroutine zggev

      !! zggevx.f
      subroutine zggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,
     &                   alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi,
     &                   lscale, rscale, abnrm, bbnrm, rconde, rcondv,
     &                   work, lwork, rwork, iwork, bwork, info )
      character          balanc, jobvl, jobvr, sense
      integer            ihi, ilo, info, lda, ldb, ldvl, ldvr, lwork, n
      double precision   abnrm, bbnrm
      logical            bwork( * )
      integer            iwork( * )
      double precision   lscale( * ), rconde( * ), rcondv( * ),
     &                   rscale( * ), rwork( * )
      complex(kind=16)   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl,
     &                   wantsb, wantse, wantsn, wantsv
      character          chtemp
      integer            i, icols, ierr, ijobvl, ijobvr, in, irows,
     &                   itau, iwrk, iwrk1, j, jc, jr, m, maxwrk, minwrk
      double precision   anrm, anrmto, bignum, bnrm, bnrmto, eps,
     &                   smlnum, temp
      complex(kind=16)   x
      logical            ldumma( 1 )
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlange
      double precision   abs1
      end subroutine zggevx

      !! zggglm.f
      subroutine zggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      complex(kind=16)   a( lda, * ), b( ldb, * ), d( * ), work( * ),
     &                   x( * ), y( * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3,
     &                   nb4, np
      integer            ilaenv
      end subroutine zggglm

      !! zgghd3.f
      subroutine zgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, work, lwork, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n, lwork
      complex(kind=16)   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * ), work( * )
      complex(kind=16)   cone, czero
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ),
     &                     czero = ( 0.0d+0, 0.0d+0 ) )
      logical            blk22, initq, initz, lquery, wantq, wantz
      character(len=1)   compq2, compz2
      integer            cola, i, ierr, j, j0, jcol, jj, jrow, k,
     &                   kacc22, len, lwkopt, n2nb, nb, nblst, nbmin,
     &                   nh, nnb, nx, ppw, ppwo, pw, top, topq
      double precision   c
      complex(kind=16)   c1, c2, ctemp, s, s1, s2, temp, temp1, temp2,
     &                   temp3
      logical            lsame
      integer            ilaenv
      end subroutine zgghd3

      !! zgghrd.f
      subroutine zgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,
     &                   ldq, z, ldz, info )
      character          compq, compz
      integer            ihi, ilo, info, lda, ldb, ldq, ldz, n
      complex(kind=16)   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      complex(kind=16)   cone, czero
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ),
     &                   czero = ( 0.0d+0, 0.0d+0 ) )
      logical            ilq, ilz
      integer            icompq, icompz, jcol, jrow
      double precision   c
      complex(kind=16)   ctemp, s
      logical            lsame
      end subroutine zgghrd

      !! zgglse.f
      subroutine zgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,
     &                   info )
      integer            info, lda, ldb, lwork, m, n, p
      complex(kind=16)   a( lda, * ), b( ldb, * ), c( * ), d( * ),
     &                   work( * ), x( * )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3,
     &                   nb4, nr
      integer            ilaenv
      end subroutine zgglse

      !! zggqrf.f
      subroutine zggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      complex(kind=16)   a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine zggqrf

      !! zggrqf.f
      subroutine zggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,
     &                   lwork, info )
      integer            info, lda, ldb, lwork, m, n, p
      complex(kind=16)   a( lda, * ), b( ldb, * ), taua( * ), taub( * ),
     &                   work( * )
      logical            lquery
      integer            lopt, lwkopt, nb, nb1, nb2, nb3
      integer            ilaenv
      end subroutine zggrqf

      !! zggsvd3.f
      subroutine zggsvd3( jobu, jobv, jobq, m, n, p, k, l, a, lda, b,
     &                    ldb, alpha, beta, u, ldu, v, ldv, q, ldq,
     &                    work, lwork, rwork, iwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      integer            iwork( * )
      double precision   alpha( * ), beta( * ), rwork( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   u( ldu, * ), v( ldv, * ), work( * )
      logical            wantq, wantu, wantv, lquery
      integer            i, ibnd, isub, j, ncycle, lwkopt
      double precision   anorm, bnorm, smax, temp, tola, tolb, ulp, unfl
      logical            lsame
      double precision   dlamch, zlange
      end subroutine zggsvd3

      !! zggsvp3.f
      subroutine zggsvp3( jobu, jobv, jobq, m, p, n, a, lda, b, ldb,
     &                    tola, tolb, k, l, u, ldu, v, ldv, q, ldq,
     &                    iwork, rwork, tau, work, lwork, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n, p,
     &                   lwork
      double precision   tola, tolb
      integer            iwork( * )
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   tau( * ), u( ldu, * ), v( ldv, * ), work( * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            forwrd, wantq, wantu, wantv, lquery
      integer            i, j, lwkopt
      complex(kind=16)   t
      logical            lsame
      end subroutine zggsvp3

      !! zgsvj0.f
      subroutine zgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,
     &                   sfmin, tol, nsweep, work, lwork, info )
      integer            info, lda, ldv, lwork, m, mv, n, nsweep
      double precision   eps, sfmin, tol
      character(len=1)   jobv
      complex(kind=16)   a( lda, * ), d( n ), v( ldv, * ), work( lwork )
      double precision   sva( n )
      double precision   zero, half, one
      parameter          ( zero = 0.0d0, half = 0.5d0, one = 1.0d0)
      complex(kind=16) czero,                  cone
      parameter  ( czero = (0.0d0, 0.0d0), cone = (1.0d0, 0.0d0) )
      complex(kind=16)   aapq, ompq
      double precision   aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, mxaapq, mxsinj, rootbig, rooteps,
     &                   rootsfmin, roottol, small, sn, t, temp1, theta,
     &                   thsign
      integer            blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1,
     &                   iswrot, jbc, jgl, kbl, lkahead, mvl, nbl,
     &                   notrot, p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      double precision   dznrm2
      complex(kind=16)   zdotc
      integer            idamax
      logical            lsame
      end subroutine zgsvj0

      !! zgsvj1.f
      subroutine zgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,
     &                   eps, sfmin, tol, nsweep, work, lwork, info )
      double precision   eps, sfmin, tol
      integer            info, lda, ldv, lwork, m, mv, n, n1, nsweep
      character(len=1)   jobv
      complex(kind=16)   a( lda, * ), d( n ), v( ldv, * ), work( lwork )
      double precision   sva( n )
      double precision   zero, half, one
      parameter          ( zero = 0.0d0, half = 0.5d0, one = 1.0d0)
      complex(kind=16)   aapq, ompq
      double precision   aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big,
     &                   bigtheta, cs, large, mxaapq, mxsinj, rootbig,
     &                   rooteps, rootsfmin, roottol, small, sn, t,
     &                   temp1, theta, thsign
      integer            blskip, emptsw, i, ibr, igl, ierr, ijblsk,
     &                   iswrot, jbc, jgl, kbl, mvl, notrot, nblc, nblr,
     &                   p, pskipped, q, rowskip, swband
      logical            applv, rotok, rsvec
      double precision   dznrm2
      complex(kind=16)   zdotc
      integer            idamax
      logical            lsame
      end subroutine zgsvj1

      !! zgtcon.f
      subroutine zgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,
     &                   work, info )
      character          norm
      integer            info, n
      double precision   anorm, rcond
      integer            ipiv( * )
      complex(kind=16)   d( * ), dl( * ), du( * ), du2( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            onenrm
      integer            i, kase, kase1
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine zgtcon

      !! zgtrfs.f
      subroutine zgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,
     &                   ipiv, b, ldb, x, ldx, ferr, berr, work, rwork,
     &                   info )
      character          trans
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   b( ldb, * ), d( * ), df( * ), dl( * ),
     &                   dlf( * ), du( * ), du2( * ), duf( * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            notran
      character          transn, transt
      integer            count, i, j, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zgtrfs

      !! zgtsv.f
      subroutine zgtsv( n, nrhs, dl, d, du, b, ldb, info )
      integer            info, ldb, n, nrhs
      complex(kind=16)   b( ldb, * ), d( * ), dl( * ), du( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      integer            j, k
      complex(kind=16)   mult, temp, zdum
      double precision   cabs1
      end subroutine zgtsv

      !! zgtsvx.f
      subroutine zgtsvx( fact, trans, n, nrhs, dl, d, du, dlf, df, duf,
     &                   du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, rwork, info )
      character          fact, trans
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   b( ldb, * ), d( * ), df( * ), dl( * ),
     &                   dlf( * ), du( * ), du2( * ), duf( * ),
     &                   work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nofact, notran
      character          norm
      double precision   anorm
      logical            lsame
      double precision   dlamch, zlangt
      end subroutine zgtsvx

      !! zgttrf.f
      subroutine zgttrf( n, dl, d, du, du2, ipiv, info )
      integer            info, n
      integer            ipiv( * )
      complex(kind=16)   d( * ), dl( * ), du( * ), du2( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            i
      complex(kind=16)   fact, temp, zdum
      double precision   cabs1
      end subroutine zgttrf

      !! zgttrs.f
      subroutine zgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,
     &                   info )
      character          trans
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      logical            notran
      integer            itrans, j, jb, nb
      integer            ilaenv
      end subroutine zgttrs

      !! zgtts2.f
      subroutine zgtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
      integer            itrans, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   b( ldb, * ), d( * ), dl( * ), du( * ), du2( * )
      integer            i, j
      complex(kind=16)   temp
      end subroutine zgtts2

      !! zhbevd.f
      subroutine zhbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                   lwork, rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ab( ldab, * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indwk2, indwrk, iscale,
     &                   liwmin, llrwk, llwk2, lrwmin, lwmin
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, zlanhb
      end subroutine zhbevd

      !! zhbev.f
      subroutine zhbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,
     &                  rwork, info )
      character          jobz, uplo
      integer            info, kd, ldab, ldz, n
      double precision   rwork( * ), w( * )
      complex(kind=16)   ab( ldab, * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            lower, wantz
      integer            iinfo, imax, inde, indrwk, iscale
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, zlanhb
      end subroutine zhbev

      !! zhbevx.f
      subroutine zhbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,
     &                   vu, il, iu, abstol, m, w, z, ldz, work, rwork,
     &                   iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, kd, ldab, ldq, ldz, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ab( ldab, * ), q( ldq, * ), work( * ),
     &                   z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      logical            alleig, indeig, lower, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwk, indrwk, indwrk, iscale, itmp1,
     &                   j, jj, nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      complex(kind=16)   ctmp1
      logical            lsame
      double precision   dlamch, zlanhb
      end subroutine zhbevx

      !! zhbgst.f
      subroutine zhbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,
     &                   ldx, work, rwork, info )
      character          uplo, vect
      integer            info, ka, kb, ldab, ldbb, ldx, n
      double precision   rwork( * )
      complex(kind=16)   ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   x( ldx, * )
      complex(kind=16)   czero, cone
      double precision   one
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ), one = 1.0d+0 )
      logical            update, upper, wantx
      integer            i, i0, i1, i2, inca, j, j1, j1t, j2, j2t, k,
     &                   ka1, kb1, kbt, l, m, nr, nrt, nx
      double precision   bii
      complex(kind=16)   ra, ra1, t
      logical            lsame
      end subroutine zhbgst

      !! zhbgvd.f
      subroutine zhbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,
     &                   z, ldz, work, lwork, rwork, lrwork, iwork,
     &                   liwork, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, liwork, lrwork,
     &                   lwork, n
      integer            iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   z( ldz, * )
      complex(kind=16)   cone, czero
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ),
     &                   czero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery, upper, wantz
      character          vect
      integer            iinfo, inde, indwk2, indwrk, liwmin, llrwk,
     &                   llwk2, lrwmin, lwmin
      logical            lsame
      end subroutine zhbgvd

      !! zhbgv.f
      subroutine zhbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,
     &                  ldz, work, rwork, info )
      character          jobz, uplo
      integer            info, ka, kb, ldab, ldbb, ldz, n
      double precision   rwork( * ), w( * )
      complex(kind=16)   ab( ldab, * ), bb( ldbb, * ), work( * ),
     &                   z( ldz, * )
      logical            upper, wantz
      character          vect
      integer            iinfo, inde, indwrk
      logical            lsame
      end subroutine zhbgv

      !! zhbgvx.f
      subroutine zhbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,
     &                   ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z,
     &                   ldz, work, rwork, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, ka, kb, ldab, ldbb, ldq, ldz, m,
     &                   n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ab( ldab, * ), bb( ldbb, * ), q( ldq, * ),
     &                   work( * ), z( ldz, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            alleig, indeig, test, upper, valeig, wantz
      character          order, vect
      integer            i, iinfo, indd, inde, indee, indibl, indisp,
     &                   indiwk, indrwk, indwrk, itmp1, j, jj, nsplit
      double precision   tmp1
      logical            lsame
      end subroutine zhbgvx

      !! zhbtrd.f
      subroutine zhbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,
     &                   work, info )
      character          uplo, vect
      integer            info, kd, ldab, ldq, n
      double precision   d( * ), e( * )
      complex(kind=16)   ab( ldab, * ), q( ldq, * ), work( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            initq, upper, wantq
      integer            i, i2, ibl, inca, incx, iqaend, iqb, iqend, j,
     &                   j1, j1end, j1inc, j2, jend, jin, jinc, k, kd1,
     &                   kdm1, kdn, l, last, lend, nq, nr, nrt
      double precision   abst
      complex(kind=16)   t, temp
      logical            lsame
      end subroutine zhbtrd

      !! zhecon.f
      subroutine zhecon( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine zhecon

      !! zhecon_rook.f
      subroutine zhecon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                        info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      real               one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine zhecon_rook

      !! zheequb.f
      subroutine zheequb( uplo, n, a, lda, s, scond, amax, work, info )
      integer            info, lda, n
      double precision   amax, scond
      character          uplo
      complex(kind=16)   a( lda, * ), work( * )
      double precision   s( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            max_iter
      parameter          ( max_iter = 100 )
      integer            i, j, iter
      double precision   avg, std, tol, c0, c1, c2, t, u, si, d,
     &                   base, smin, smax, smlnum, bignum, scale, sumsq
      logical            up
      complex(kind=16)   zdum
      double precision   dlamch
      logical            lsame
      double precision   cabs1
      end subroutine zheequb

      !! zheevd.f
      subroutine zheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,
     &                   lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, lda, liwork, lrwork, lwork, n
      integer            iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d0, 0.0d0 ) )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indrwk, indtau, indwk2,
     &                   indwrk, iscale, liopt, liwmin, llrwk, llwork,
     &                   llwrk2, lopt, lropt, lrwmin, lwmin
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlanhe
      end subroutine zheevd

      !! zheev.f
      subroutine zheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,
     &                  info )
      character          jobz, uplo
      integer            info, lda, lwork, n
      double precision   rwork( * ), w( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d0, 0.0d0 ) )
      logical            lower, lquery, wantz
      integer            iinfo, imax, inde, indtau, indwrk, iscale,
     &                   llwork, lwkopt, nb
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlanhe
      end subroutine zheev

      !! zheevr.f
      subroutine zheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, isuppz, work, lwork,
     &                   rwork, lrwork, iwork, liwork, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, liwork, lrwork, lwork,
     &                   m, n
      double precision   abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   a( lda, * ), work( * ), z( ldz, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      logical            alleig, indeig, lower, lquery, test, valeig,
     &                   wantz, tryrac
      character          order
      integer            i, ieeeok, iinfo, imax, indibl, indifl, indisp,
     &                   indiwo, indrd, indrdd, indre, indree, indrwk,
     &                   indtau, indwk, indwkn, iscale, itmp1, j, jj,
     &                   liwmin, llwork, llrwork, llwrkn, lrwmin,
     &                   lwkopt, lwmin, nb, nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlansy
      end subroutine zheevr

      !! zheevx.f
      subroutine zheevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, lwork, rwork,
     &                   iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, lda, ldz, lwork, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   a( lda, * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            alleig, indeig, lower, lquery, test, valeig,
     &                   wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwk, indrwk, indtau, indwrk, iscale,
     &                   itmp1, j, jj, llwork, lwkmin, lwkopt, nb,
     &                   nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlanhe
      end subroutine zheevx

      !! zhegs2.f
      subroutine zhegs2( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      complex(kind=16)   a( lda, * ), b( ldb, * )
      double precision   one, half
      parameter          ( one = 1.0d+0, half = 0.5d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            k
      double precision   akk, bkk
      complex(kind=16)   ct
      logical            lsame
      end subroutine zhegs2

      !! zhegst.f
      subroutine zhegst( itype, uplo, n, a, lda, b, ldb, info )
      character          uplo
      integer            info, itype, lda, ldb, n
      complex(kind=16)   a( lda, * ), b( ldb, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      complex(kind=16)   cone, half
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ),
     &                   half = ( 0.5d+0, 0.0d+0 ) )
      logical            upper
      integer            k, kb, nb
      logical            lsame
      integer            ilaenv
      end subroutine zhegst

      !! zhegvd.f
      subroutine zhegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                   lwork, rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, liwork, lrwork, lwork, n
      integer            iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery, upper, wantz
      character          trans
      integer            liopt, liwmin, lopt, lropt, lrwmin, lwmin
      logical            lsame
      end subroutine zhegvd

      !! zhegv.f
      subroutine zhegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,
     &                  lwork, rwork, info )
      character          jobz, uplo
      integer            info, itype, lda, ldb, lwork, n
      double precision   rwork( * ), w( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery, upper, wantz
      character          trans
      integer            lwkopt, nb, neig
      logical            lsame
      integer            ilaenv
      end subroutine zhegv

      !! zhegvx.f
      subroutine zhegvx( itype, jobz, range, uplo, n, a, lda, b, ldb,
     &                   vl, vu, il, iu, abstol, m, w, z, ldz, work,
     &                   lwork, rwork, iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, lda, ldb, ldz, lwork, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * ),
     &                   z( ldz, * )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            alleig, indeig, lquery, upper, valeig, wantz
      character          trans
      integer            lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine zhegvx

      !! zherfs.f
      subroutine zherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zherfs

      !! zherfsx.f
      subroutine zherfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    s, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, zlanhe, zla_hercond_x, zla_hercond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine zherfsx

      !! zhesv.f
      subroutine zhesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine zhesv

      !! zhesv_rook.f
      subroutine zhesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                       lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine zhesv_rook

      !! zhesvx.f
      subroutine zhesvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,
     &                   ldb, x, ldx, rcond, ferr, berr, work, lwork,
     &                   rwork, info )
      character          fact, uplo
      integer            info, lda, ldaf, ldb, ldx, lwork, n, nrhs
      double precision   rcond
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery, nofact
      integer            lwkopt, nb
      double precision   anorm
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlanhe
      end subroutine zhesvx

      !! zhesvxx.f
      subroutine zhesvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      double precision   amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      double precision   dlamch, zla_herpvgrw
      end subroutine zhesvxx

      !! zheswapr.f
      subroutine zheswapr( uplo, n, a, lda, i1, i2)
      character        uplo
      integer          i1, i2, lda, n
      complex(kind=16)    a( lda, n )
      logical            upper
      integer            i
      complex(kind=16)      tmp
      logical            lsame
      end subroutine zheswapr

      !! zhetd2.f
      subroutine zhetd2( uplo, n, a, lda, d, e, tau, info )
      character          uplo
      integer            info, lda, n
      double precision   d( * ), e( * )
      complex(kind=16)   a( lda, * ), tau( * )
      complex(kind=16)   one, zero, half
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ),
     &                   half = ( 0.5d+0, 0.0d+0 ) )
      logical            upper
      integer            i
      complex(kind=16)   alpha, taui
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zhetd2

      !! zhetf2.f
      subroutine zhetf2( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kk, kp, kstep
      double precision   absakk, alpha, colmax, d, d11, d22, r1, rowmax,
     &                   tt
      complex(kind=16)   d12, d21, t, wk, wkm1, wkp1, zdum
      logical            lsame, disnan
      integer            izamax
      double precision   dlapy2
      double precision   cabs1
      end subroutine zhetf2

      !! zhetf2_rook.f
      subroutine zhetf2_rook( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            done, upper
      integer            i, ii, imax, itemp, j, jmax, k, kk, kp, kstep,
     &                   p
      double precision   absakk, alpha, colmax, d, d11, d22, r1, dtemp,
     &                   rowmax, tt, sfmin
      complex(kind=16)   d12, d21, t, wk, wkm1, wkp1, z
      logical            lsame
      integer            izamax
      double precision   dlamch, dlapy2
      double precision   cabs1
      end subroutine zhetf2_rook

      !! zhetrd.f
      subroutine zhetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      double precision   d( * ), e( * )
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery, upper
      integer            i, iinfo, iws, j, kk, ldwork, lwkopt, nb,
     &                   nbmin, nx
      logical            lsame
      integer            ilaenv
      end subroutine zhetrd

      !! zhetrf.f
      subroutine zhetrf( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine zhetrf

      !! zhetrf_rook.f
      subroutine zhetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine zhetrf_rook

      !! zhetri2.f
      subroutine zhetri2( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      logical            upper, lquery
      integer            minsize, nbmax
      logical            lsame
      integer            ilaenv
      end subroutine zhetri2

      !! zhetri2x.f
      subroutine zhetri2x( uplo, n, a, lda, ipiv, work, nb, info )
      character          uplo
      integer            info, lda, n, nb
      integer            ipiv( * )
      complex(kind=16)      a( lda, * ), work( n+nb+1,* )
      real               one
      complex(kind=16)      cone, zero
      parameter          ( one = 1.0d+0,
     &                   cone = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i, iinfo, ip, k, cut, nnb
      integer            count
      integer            j, u11, invd
      complex(kind=16) ak, akkp1, akp1, d, t
      complex(kind=16) u01_i_j, u01_ip1_j
      complex(kind=16) u11_i_j, u11_ip1_j
      logical            lsame
      end subroutine zhetri2x

      !! zhetri.f
      subroutine zhetri( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one
      complex(kind=16)   cone, zero
      parameter          ( one = 1.0d+0, cone = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kp, kstep
      double precision   ak, akp1, d, t
      complex(kind=16)   akkp1, temp
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zhetri

      !! zhetri_rook.f
      subroutine zhetri_rook( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one
      complex(kind=16)   cone, czero
      parameter          ( one = 1.0d+0, cone = ( 1.0d+0, 0.0d+0 ),
     &                   czero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kp, kstep
      double precision   ak, akp1, d, t
      complex(kind=16)   akkp1, temp
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zhetri_rook

      !! zhetrs2.f
      subroutine zhetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                    work, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16) a( lda, * ), b( ldb, * ), work( * )
      complex(kind=16)   one
      parameter          ( one = (1.0d+0,0.0d+0) )
      logical            upper
      integer            i, iinfo, j, k, kp
      double precision   s
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zhetrs2

      !! zhetrs.f
      subroutine zhetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kp
      double precision   s
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zhetrs

      !! zhetrs_rook.f
      subroutine zhetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                        info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kp
      double precision   s
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zhetrs_rook

      !! zhfrk.f
      subroutine zhfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,
     &                  c )
      double precision   alpha, beta
      integer            k, lda, n
      character          trans, transr, uplo
      complex(kind=16)   a( lda, * ), c( * )
      double precision   one, zero
      complex(kind=16)   czero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ) )
      logical            lower, normaltransr, nisodd, notrans
      integer            info, nrowa, j, nk, n1, n2
      complex(kind=16)   calpha, cbeta
      logical            lsame
      end subroutine zhfrk

      !! zhgeqz.f
      subroutine zhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,
     &                   alpha, beta, q, ldq, z, ldz, work, lwork,
     &                   rwork, info )
      character          compq, compz, job
      integer            ihi, ilo, info, ldh, ldq, ldt, ldz, lwork, n
      double precision   rwork( * )
      complex(kind=16)   alpha( * ), beta( * ), h( ldh, * ),
     &                   q( ldq, * ), t( ldt, * ), work( * ),
     &                   z( ldz, * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   half
      parameter          ( half = 0.5d+0 )
      logical            ilazr2, ilazro, ilq, ilschr, ilz, lquery
      integer            icompq, icompz, ifirst, ifrstm, iiter, ilast,
     &                   ilastm, in, ischur, istart, j, jc, jch, jiter,
     &                   jr, maxit
      double precision   absb, anorm, ascale, atol, bnorm, bscale, btol,
     &                   c, safmin, temp, temp2, tempr, ulp
      complex(kind=16)   abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2,
     &                   ctemp3, eshift, rtdisc, s, shift, signbc, t1,
     &                   u12, x
      logical            lsame
      double precision   dlamch, zlanhs
      double precision   abs1
      end subroutine zhgeqz

      !! zhpcon.f
      subroutine zhpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
      character          uplo
      integer            info, n
      double precision   anorm, rcond
      integer            ipiv( * )
      complex(kind=16)   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, ip, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine zhpcon

      !! zhpevd.f
      subroutine zhpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,
     &                   rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ap( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery, wantz
      integer            iinfo, imax, inde, indrwk, indtau, indwrk,
     &                   iscale, liwmin, llrwk, llwrk, lrwmin, lwmin
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, zlanhp
      end subroutine zhpevd

      !! zhpev.f
      subroutine zhpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,
     &                  info )
      character          jobz, uplo
      integer            info, ldz, n
      double precision   rwork( * ), w( * )
      complex(kind=16)   ap( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            wantz
      integer            iinfo, imax, inde, indrwk, indtau, indwrk,
     &                   iscale
      double precision   anrm, bignum, eps, rmax, rmin, safmin, sigma,
     &                   smlnum
      logical            lsame
      double precision   dlamch, zlanhp
      end subroutine zhpev

      !! zhpevx.f
      subroutine zhpevx( jobz, range, uplo, n, ap, vl, vu, il, iu,
     &                   abstol, m, w, z, ldz, work, rwork, iwork,
     &                   ifail, info )
      character          jobz, range, uplo
      integer            il, info, iu, ldz, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ap( * ), work( * ), z( ldz, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d0, 0.0d0 ) )
      logical            alleig, indeig, test, valeig, wantz
      character          order
      integer            i, iinfo, imax, indd, inde, indee, indibl,
     &                   indisp, indiwk, indrwk, indtau, indwrk, iscale,
     &                   itmp1, j, jj, nsplit
      double precision   abstll, anrm, bignum, eps, rmax, rmin, safmin,
     &                   sigma, smlnum, tmp1, vll, vuu
      logical            lsame
      double precision   dlamch, zlanhp
      end subroutine zhpevx

      !! zhpgst.f
      subroutine zhpgst( itype, uplo, n, ap, bp, info )
      character          uplo
      integer            info, itype, n
      complex(kind=16)   ap( * ), bp( * )
      double precision   one, half
      parameter          ( one = 1.0d+0, half = 0.5d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, j1, j1j1, jj, k, k1, k1k1, kk
      double precision   ajj, akk, bjj, bkk
      complex(kind=16)   ct
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zhpgst

      !! zhpgvd.f
      subroutine zhpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                   lwork, rwork, lrwork, iwork, liwork, info )
      character          jobz, uplo
      integer            info, itype, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ap( * ), bp( * ), work( * ), z( ldz, * )
      logical            lquery, upper, wantz
      character          trans
      integer            j, liwmin, lrwmin, lwmin, neig
      logical            lsame
      end subroutine zhpgvd

      !! zhpgv.f
      subroutine zhpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,
     &                  rwork, info )
      character          jobz, uplo
      integer            info, itype, ldz, n
      double precision   rwork( * ), w( * )
      complex(kind=16)   ap( * ), bp( * ), work( * ), z( ldz, * )
      logical            upper, wantz
      character          trans
      integer            j, neig
      logical            lsame
      end subroutine zhpgv

      !! zhpgvx.f
      subroutine zhpgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,
     &                   il, iu, abstol, m, w, z, ldz, work, rwork,
     &                   iwork, ifail, info )
      character          jobz, range, uplo
      integer            il, info, itype, iu, ldz, m, n
      double precision   abstol, vl, vu
      integer            ifail( * ), iwork( * )
      double precision   rwork( * ), w( * )
      complex(kind=16)   ap( * ), bp( * ), work( * ), z( ldz, * )
      logical            alleig, indeig, upper, valeig, wantz
      character          trans
      integer            j
      logical            lsame
      end subroutine zhpgvx

      !! zhprfs.f
      subroutine zhprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zhprfs

      !! zhpsv.f
      subroutine zhpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   ap( * ), b( ldb, * )
      logical            lsame
      end subroutine zhpsv

      !! zhpsvx.f
      subroutine zhpsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,
     &                   ldx, rcond, ferr, berr, work, rwork, info )
      character          fact, uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nofact
      double precision   anorm
      logical            lsame
      double precision   dlamch, zlanhp
      end subroutine zhpsvx

      !! zhptrd.f
      subroutine zhptrd( uplo, n, ap, d, e, tau, info )
      character          uplo
      integer            info, n
      double precision   d( * ), e( * )
      complex(kind=16)   ap( * ), tau( * )
      complex(kind=16)   one, zero, half
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ),
     &                   half = ( 0.5d+0, 0.0d+0 ) )
      logical            upper
      integer            i, i1, i1i1, ii
      complex(kind=16)   alpha, taui
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zhptrd

      !! zhptrf.f
      subroutine zhptrf( uplo, n, ap, ipiv, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex(kind=16)   ap( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            upper
      integer            i, imax, j, jmax, k, kc, kk, knc, kp, kpc,
     &                   kstep, kx, npp
      double precision   absakk, alpha, colmax, d, d11, d22, r1, rowmax,
     &                   tt
      complex(kind=16)   d12, d21, t, wk, wkm1, wkp1, zdum
      logical            lsame
      integer            izamax
      double precision   dlapy2
      double precision   cabs1
      end subroutine zhptrf

      !! zhptri.f
      subroutine zhptri( uplo, n, ap, ipiv, work, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex(kind=16)   ap( * ), work( * )
      double precision   one
      complex(kind=16)   cone, zero
      parameter          ( one = 1.0d+0, cone = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kc, kcnext, kp, kpc, kstep, kx, npp
      double precision   ak, akp1, d, t
      complex(kind=16)   akkp1, temp
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zhptri

      !! zhptrs.f
      subroutine zhptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   ap( * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kc, kp
      double precision   s
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zhptrs

      !! zhsein.f
      subroutine zhsein( side, eigsrc, initv, select, n, h, ldh, w, vl,
     &                   ldvl, vr, ldvr, mm, m, work, rwork, ifaill,
     &                   ifailr, info )
      character          eigsrc, initv, side
      integer            info, ldh, ldvl, ldvr, m, mm, n
      logical            select( * )
      integer            ifaill( * ), ifailr( * )
      double precision   rwork( * )
      complex(kind=16)   h( ldh, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   w( * ), work( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      double precision   rzero
      parameter          ( rzero = 0.0d+0 )
      logical            bothv, fromqr, leftv, noinit, rightv
      integer            i, iinfo, k, kl, kln, kr, ks, ldwork
      double precision   eps3, hnorm, smlnum, ulp, unfl
      complex(kind=16)   cdum, wk
      logical            lsame, disnan
      double precision   dlamch, zlanhs
      double precision   cabs1
      end subroutine zhsein

      !! zhseqr.f
      subroutine zhseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,
     &                   work, lwork, info )
      integer            ihi, ilo, info, ldh, ldz, lwork, n
      character          compz, job
      complex(kind=16)   h( ldh, * ), w( * ), work( * ), z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            nl
      parameter          ( nl = 49 )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d0, 0.0d0 ),
     &                   one = ( 1.0d0, 0.0d0 ) )
      double precision   rzero
      parameter          ( rzero = 0.0d0 )
      complex(kind=16)   hl( nl, nl ), workl( nl )
      integer            kbot, nmin
      logical            initz, lquery, wantt, wantz
      integer            ilaenv
      logical            lsame
      end subroutine zhseqr

      !! zlabrd.f
      subroutine zlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,
     &                   ldy )
      integer            lda, ldx, ldy, m, n, nb
      double precision   d( * ), e( * )
      complex(kind=16)   a( lda, * ), taup( * ), tauq( * ), x( ldx, * ),
     &                   y( ldy, * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      integer            i
      complex(kind=16)   alpha
      end subroutine zlabrd

      !! zlacgv.f
      subroutine zlacgv( n, x, incx )
      integer            incx, n
      complex(kind=16)   x( * )
      integer            i, ioff
      end subroutine zlacgv

      !! zlacn2.f
      subroutine zlacn2( n, v, x, est, kase, isave )
      integer            kase, n
      double precision   est
      integer            isave( 3 )
      complex(kind=16)   v( * ), x( * )
      integer              itmax
      parameter          ( itmax = 5 )
      double precision     one,         two
      parameter          ( one = 1.0d0, two = 2.0d0 )
      complex(kind=16)     czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                            cone = ( 1.0d0, 0.0d0 ) )
      integer            i, jlast
      double precision   absxi, altsgn, estold, safmin, temp
      integer            izmax1
      double precision   dlamch, dzsum1
      end subroutine zlacn2

      !! zlacon.f
      subroutine zlacon( n, v, x, est, kase )
      integer            kase, n
      double precision   est
      complex(kind=16)   v( n ), x( n )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   one, two
      parameter          ( one = 1.0d0, two = 2.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      integer            i, iter, j, jlast, jump
      double precision   absxi, altsgn, estold, safmin, temp
      integer            izmax1
      double precision   dlamch, dzsum1
      end subroutine zlacon

      !! zlacp2.f
      subroutine zlacp2( uplo, m, n, a, lda, b, ldb )
      character          uplo
      integer            lda, ldb, m, n
      double precision   a( lda, * )
      complex(kind=16)   b( ldb, * )
      integer            i, j
      logical            lsame
      end subroutine zlacp2

      !! zlacpy.f
      subroutine zlacpy( uplo, m, n, a, lda, b, ldb )
      character          uplo
      integer            lda, ldb, m, n
      complex(kind=16)   a( lda, * ), b( ldb, * )
      integer            i, j
      logical            lsame
      end subroutine zlacpy

      !! zlacrm.f
      subroutine zlacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
      integer            lda, ldb, ldc, m, n
      double precision   b( ldb, * ), rwork( * )
      complex(kind=16)   a( lda, * ), c( ldc, * )
      double precision   one, zero
      parameter          ( one = 1.0d0, zero = 0.0d0 )
      integer            i, j, l
      end subroutine zlacrm

      !! zlacrt.f
      subroutine zlacrt( n, cx, incx, cy, incy, c, s )
      integer            incx, incy, n
      complex(kind=16)   c, s
      complex(kind=16)   cx( * ), cy( * )
      integer            i, ix, iy
      complex(kind=16)   ctemp
      end subroutine zlacrt

      !! zladiv.f
      complex(kind=16) function zladiv( x, y )
      complex(kind=16)   x, y
      double precision   zi, zr
      end function zladiv

      !! zlaed0.f
      subroutine zlaed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,
     &                   iwork, info )
      integer            info, ldq, ldqs, n, qsiz
      integer            iwork( * )
      double precision   d( * ), e( * ), rwork( * )
      complex(kind=16)   q( ldq, * ), qstore( ldqs, * )
      double precision   two
      parameter          ( two = 2.d+0 )
      integer            curlvl, curprb, curr, i, igivcl, igivnm,
     &                   igivpt, indxq, iperm, iprmpt, iq, iqptr, iwrem,
     &                   j, k, lgn, ll, matsiz, msd2, smlsiz, smm1,
     &                   spm1, spm2, submat, subpbs, tlvls
      double precision   temp
      integer            ilaenv
      end subroutine zlaed0

      !! zlaed7.f
      subroutine zlaed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,
     &                   ldq, rho, indxq, qstore, qptr, prmptr, perm,
     &                   givptr, givcol, givnum, work, rwork, iwork,
     &                   info )
      integer            curlvl, curpbm, cutpnt, info, ldq, n, qsiz,
     &                   tlvls
      double precision   rho
      integer            givcol( 2, * ), givptr( * ), indxq( * ),
     &                   iwork( * ), perm( * ), prmptr( * ), qptr( * )
      double precision   d( * ), givnum( 2, * ), qstore( * ), rwork( * )
      complex(kind=16)   q( ldq, * ), work( * )
      integer            coltyp, curr, i, idlmda, indx,
     &                   indxc, indxp, iq, iw, iz, k, n1, n2, ptr
      end subroutine zlaed7

      !! zlaed8.f
      subroutine zlaed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,
     &                   q2, ldq2, w, indxp, indx, indxq, perm, givptr,
     &                   givcol, givnum, info )
      integer            cutpnt, givptr, info, k, ldq, ldq2, n, qsiz
      double precision   rho
      integer            givcol( 2, * ), indx( * ), indxp( * ),
     &                   indxq( * ), perm( * )
      double precision   d( * ), dlamda( * ), givnum( 2, * ), w( * ),
     &                   z( * )
      complex(kind=16)   q( ldq, * ), q2( ldq2, * )
      double precision   mone, zero, one, two, eight
      parameter          ( mone = -1.0d0, zero = 0.0d0, one = 1.0d0,
     &                   two = 2.0d0, eight = 8.0d0 )
      integer            i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
      double precision   c, eps, s, t, tau, tol
      integer            idamax
      double precision   dlamch, dlapy2
      end subroutine zlaed8

      !! zlaein.f
      subroutine zlaein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,
     &                   eps3, smlnum, info )
      logical            noinit, rightv
      integer            info, ldb, ldh, n
      double precision   eps3, smlnum
      complex(kind=16)   w
      double precision   rwork( * )
      complex(kind=16)   b( ldb, * ), h( ldh, * ), v( * )
      double precision   one, tenth
      parameter          ( one = 1.0d+0, tenth = 1.0d-1 )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      character          normin, trans
      integer            i, ierr, its, j
      double precision   growto, nrmsml, rootn, rtemp, scale, vnorm
      complex(kind=16)   cdum, ei, ej, temp, x
      integer            izamax
      double precision   dzasum, dznrm2
      complex(kind=16)   zladiv
      double precision   cabs1
      end subroutine zlaein

      !! zlaesy.f
      subroutine zlaesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
      complex(kind=16)   a, b, c, cs1, evscal, rt1, rt2, sn1
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d0, 0.0d0 ) )
      double precision   half
      parameter          ( half = 0.5d0 )
      double precision   thresh
      parameter          ( thresh = 0.1d0 )
      double precision   babs, evnorm, tabs, z
      complex(kind=16)   s, t, tmp
      end subroutine zlaesy

      !! zlaev2.f
      subroutine zlaev2( a, b, c, rt1, rt2, cs1, sn1 )
      double precision   cs1, rt1, rt2
      complex(kind=16)   a, b, c, sn1
      double precision   zero
      parameter          ( zero = 0.0d0 )
      double precision   one
      parameter          ( one = 1.0d0 )
      double precision   t
      complex(kind=16)   w
      end subroutine zlaev2

      !! zlag2c.f
      subroutine zlag2c( m, n, a, lda, sa, ldsa, info )
      integer            info, lda, ldsa, m, n
      complex            sa( ldsa, * )
      complex(kind=16)   a( lda, * )
      integer            i, j
      double precision   rmax
      real               slamch
      end subroutine zlag2c

      !! zla_gbamv.f
      subroutine zla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,
     &                      incx, beta, y, incy )
      double precision   alpha, beta
      integer            incx, incy, ldab, m, n, kl, ku, trans
      complex(kind=16)   ab( ldab, * ), x( * )
      double precision   y( * )
      complex(kind=16)   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            symb_zero
      double precision   temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny, kd, ke
      complex(kind=16)   cdum
      double precision   dlamch
      integer            ilatrans
      double precision   cabs1
      end subroutine zla_gbamv

      !! zla_gbrcond_c.f
      double precision function zla_gbrcond_c( trans, n, kl, ku, ab,
     &                                         ldab, afb, ldafb, ipiv,
     &                                         c, capply, info, work,
     &                                         rwork )
      character          trans
      logical            capply
      integer            n, kl, ku, kd, ke, ldab, ldafb, info
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), work( * )
      double precision   c( * ), rwork( * )
      logical            notrans
      integer            kase, i, j
      double precision   ainvnm, anorm, tmp
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   cabs1
      end function zla_gbrcond_c

      !! zla_gbrcond_x.f
      double precision function zla_gbrcond_x( trans, n, kl, ku, ab,
     &                                         ldab, afb, ldafb, ipiv,
     &                                         x, info, work, rwork )
      character          trans
      integer            n, kl, ku, kd, ke, ldab, ldafb, info
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), work( * ),
     &                   x( * )
      double precision   rwork( * )
      logical            notrans
      integer            kase, i, j
      double precision   ainvnm, anorm, tmp
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   cabs1
      end function zla_gbrcond_x

      !! zla_gbrfsx_extended.f
      subroutine zla_gbrfsx_extended( prec_type, trans_type, n, kl, ku,
     &                                nrhs, ab, ldab, afb, ldafb, ipiv,
     &                                colequ, c, b, ldb, y, ldy,
     &                                berr_out, n_norms, err_bnds_norm,
     &                                err_bnds_comp, res, ayb, dy,
     &                                y_tail, rcond, ithresh, rthresh,
     &                                dz_ub, ignore_cwise, info )
      integer            info, ldab, ldafb, ldb, ldy, n, kl, ku, nrhs,
     &                   prec_type, trans_type, n_norms, ithresh
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      integer            ipiv( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb(*), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      character          trans
      integer            cnt, i, j, m, x_state, z_state, y_prec_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      complex(kind=16)   zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      double precision   dlamch
      character          chla_transtype
      double precision   cabs1
      end subroutine zla_gbrfsx_extended

      !! zla_gbrpvgrw.f
      double precision function zla_gbrpvgrw( n, kl, ku, ncols, ab,
     &                                        ldab, afb, ldafb )
      integer            n, kl, ku, ncols, ldab, ldafb
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * )
      integer            i, j, kd
      double precision   amax, umax, rpvgrw
      complex(kind=16)   zdum
      double precision   cabs1
      end function zla_gbrpvgrw

      !! zla_geamv.f
      subroutine zla_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,
     &                       y, incy )
      double precision   alpha, beta
      integer            incx, incy, lda, m, n
      integer            trans
      complex(kind=16)   a( lda, * ), x( * )
      double precision   y( * )
      complex(kind=16)   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            symb_zero
      double precision   temp, safe1
      integer            i, info, iy, j, jx, kx, ky, lenx, leny
      complex(kind=16)   cdum
      double precision   dlamch
      integer            ilatrans
      double precision   cabs1
      end subroutine zla_geamv

      !! zla_gercond_c.f
      double precision function zla_gercond_c( trans, n, a, lda, af,
     &                                         ldaf, ipiv, c, capply,
     &                                         info, work, rwork )
      character          trans
      logical            capply
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * )
      double precision   c( * ), rwork( * )
      logical            notrans
      integer            kase, i, j
      double precision   ainvnm, anorm, tmp
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   cabs1
      end function zla_gercond_c

      !! zla_gercond_x.f
      double precision function zla_gercond_x( trans, n, a, lda, af,
     &                                         ldaf, ipiv, x, info,
     &                                         work, rwork )
      character          trans
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * ), x( * )
      double precision   rwork( * )
      logical            notrans
      integer            kase
      double precision   ainvnm, anorm, tmp
      integer            i, j
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   cabs1
      end function zla_gercond_x

      !! zla_gerfsx_extended.f
      subroutine zla_gerfsx_extended( prec_type, trans_type, n, nrhs, a,
     &                                lda, af, ldaf, ipiv, colequ, c, b,
     &                                ldb, y, ldy, berr_out, n_norms,
     &                                errs_n, errs_c, res, ayb, dy,
     &                                y_tail, rcond, ithresh, rthresh,
     &                                dz_ub, ignore_cwise, info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   trans_type, n_norms
      logical            colequ, ignore_cwise
      integer            ithresh
      double precision   rthresh, dz_ub
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb( * ), rcond, berr_out( * ),
     &                   errs_n( nrhs, * ), errs_c( nrhs, * )
      character          trans
      integer            cnt, i, j,  x_state, z_state, y_prec_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      complex(kind=16)   zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2,
     &                   noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      double precision   dlamch
      character          chla_transtype
      double precision   cabs1
      end subroutine zla_gerfsx_extended

      !! zla_gerpvgrw.f
      double precision function zla_gerpvgrw( n, ncols, a, lda, af,
     &         ldaf )
      integer            n, ncols, lda, ldaf
      complex(kind=16)   a( lda, * ), af( ldaf, * )
      integer            i, j
      double precision   amax, umax, rpvgrw
      complex(kind=16)   zdum
      double precision   cabs1
      end function zla_gerpvgrw

      !! zlags2.f
      subroutine zlags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,
     &                   snv, csq, snq )
      logical            upper
      double precision   a1, a3, b1, b3, csq, csu, csv
      complex(kind=16)   a2, b2, snq, snu, snv
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   a, aua11, aua12, aua21, aua22, avb12, avb11,
     &                   avb21, avb22, csl, csr, d, fb, fc, s1, s2,
     &                   snl, snr, ua11r, ua22r, vb11r, vb22r
      complex(kind=16)   b, c, d1, r, t, ua11, ua12, ua21, ua22, vb11,
     &                   vb12, vb21, vb22
      double precision   abs1
      end subroutine zlags2

      !! zlagtm.f
      subroutine zlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,
     &                   b, ldb )
      character          trans
      integer            ldb, ldx, n, nrhs
      double precision   alpha, beta
      complex(kind=16)   b( ldb, * ), d( * ), dl( * ), du( * ),
     &                   x( ldx, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      logical            lsame
      end subroutine zlagtm

      !! zla_heamv.f
      subroutine zla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,
     &                      incy )
      double precision   alpha, beta
      integer            incx, incy, lda, n, uplo
      complex(kind=16)   a( lda, * ), x( * )
      double precision   y( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            symb_zero
      double precision   temp, safe1
      integer            i, info, iy, j, jx, kx, ky
      complex(kind=16)   zdum
      double precision   dlamch
      integer            ilauplo
      double precision   cabs1
      end subroutine zla_heamv

      !! zlahef.f
      subroutine zlahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), w( ldw, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      integer            imax, j, jb, jj, jmax, jp, k, kk, kkw, kp,
     &                   kstep, kw
      double precision   absakk, alpha, colmax, r1, rowmax, t
      complex(kind=16)   d11, d21, d22, z
      logical            lsame
      integer            izamax
      double precision   cabs1
      end subroutine zlahef

      !! zlahef_rook.f
      subroutine zlahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,
     &                        info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), w( ldw, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      logical            done
      integer            imax, itemp, ii, j, jb, jj, jmax, jp1, jp2, k,
     &                   kk, kkw, kp, kstep, kw, p
      double precision   absakk, alpha, colmax, dtemp, r1, rowmax, t,
     &                   sfmin
      complex(kind=16)   d11, d21, d22, z
      logical            lsame
      integer            izamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zlahef_rook

      !! zla_hercond_c.f
      double precision function zla_hercond_c( uplo, n, a, lda, af,
     &                                         ldaf, ipiv, c, capply,
     &                                         info, work, rwork )
      character          uplo
      logical            capply
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * )
      double precision   c ( * ), rwork( * )
      integer            kase, i, j
      double precision   ainvnm, anorm, tmp
      logical            up, upper
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   cabs1
      end function zla_hercond_c

      !! zla_hercond_x.f
      double precision function zla_hercond_x( uplo, n, a, lda, af,
     &                                         ldaf, ipiv, x, info,
     &                                         work, rwork )
      character          uplo
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * ), x( * )
      double precision   rwork( * )
      integer            kase, i, j
      double precision   ainvnm, anorm, tmp
      logical            up, upper
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision cabs1
      end function zla_hercond_x

      !! zla_herfsx_extended.f
      subroutine zla_herfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, ipiv, colequ, c, b, ldb,
     &                                y, ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state,
     &                   y_prec_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec, upper
      complex(kind=16)   zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      double precision   dlamch
      double precision   cabs1
      end subroutine zla_herfsx_extended

      !! zla_herpvgrw.f
      double precision function zla_herpvgrw( uplo, n, info, a, lda, af,
     &                                        ldaf, ipiv, work )
      character(len=1)   uplo
      integer            n, info, lda, ldaf
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * )
      double precision   work( * )
      integer            ncols, i, j, k, kp
      double precision   amax, umax, rpvgrw, tmp
      logical            upper, lsame
      complex(kind=16)   zdum
      double precision   cabs1
      end function zla_herpvgrw

      !! zlahqr.f
      subroutine zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,
     &                   ihiz, z, ldz, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, n
      logical            wantt, wantz
      complex(kind=16)   h( ldh, * ), w( * ), z( ldz, * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d0, 0.0d0 ),
     &                   one = ( 1.0d0, 0.0d0 ) )
      double precision   rzero, rone, half
      parameter          ( rzero = 0.0d0, rone = 1.0d0, half = 0.5d0 )
      double precision   dat1
      parameter          ( dat1 = 3.0d0 / 4.0d0 )
      complex(kind=16)   cdum, h11, h11s, h22, sc, sum, t, t1, temp, u,
     &                   v2, x, y
      double precision   aa, ab, ba, bb, h10, h21, rtemp, s, safmax,
     &                   safmin, smlnum, sx, t2, tst, ulp
      integer            i, i1, i2, its, itmax, j, jhi, jlo, k, l, m,
     &                   nh, nz
      complex(kind=16)   v( 2 )
      complex(kind=16)   zladiv
      double precision   dlamch
      double precision   cabs1
      end subroutine zlahqr

      !! zlahr2.f
      subroutine zlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
      integer            k, lda, ldt, ldy, n, nb
      complex(kind=16)  a( lda, * ), t( ldt, nb ), tau( nb ),
     &                   y( ldy, nb )
      complex(kind=16)  zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                     one = ( 1.0d+0, 0.0d+0 ) )
      integer            i
      complex(kind=16)  ei
      end subroutine zlahr2

      !! zlaic1.f
      subroutine zlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
      integer            j, job
      double precision   sest, sestpr
      complex(kind=16)   c, gamma, s
      complex(kind=16)   w( j ), x( j )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      double precision   half, four
      parameter          ( half = 0.5d0, four = 4.0d0 )
      double precision   absalp, absest, absgam, b, eps, norma, s1, s2,
     &                   scl, t, test, tmp, zeta1, zeta2
      complex(kind=16)   alpha, cosine, sine
      double precision   dlamch
      complex(kind=16)   zdotc
      end subroutine zlaic1

      !! zla_lin_berr.f
      subroutine zla_lin_berr ( n, nz, nrhs, res, ayb, berr )
      integer            n, nz, nrhs
      double precision   ayb( n, nrhs ), berr( nrhs )
      complex(kind=16)   res( n, nrhs )
      double precision   tmp
      integer            i, j
      complex(kind=16)   cdum
      double precision   dlamch
      double precision   safe1
      complex(kind=16)   cabs1
      end subroutine zla_lin_berr

      !! zlals0.f
      subroutine zlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,
     &                   perm, givptr, givcol, ldgcol, givnum, ldgnum,
     &                   poles, difl, difr, z, k, c, s, rwork, info )
      integer            givptr, icompq, info, k, ldb, ldbx, ldgcol,
     &                   ldgnum, nl, nr, nrhs, sqre
      double precision   c, s
      integer            givcol( ldgcol, * ), perm( * )
      double precision   difl( * ), difr( ldgnum, * ),
     &                   givnum( ldgnum, * ), poles( ldgnum, * ),
     &                   rwork( * ), z( * )
      complex(kind=16)   b( ldb, * ), bx( ldbx, * )
      double precision   one, zero, negone
      parameter          ( one = 1.0d0, zero = 0.0d0, negone = -1.0d0 )
      integer            i, j, jcol, jrow, m, n, nlp1
      double precision   diflj, difrj, dj, dsigj, dsigjp, temp
      double precision   dlamc3, dnrm2
      end subroutine zlals0

      !! zlalsa.f
      subroutine zlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,
     &                   ldu, vt, k, difl, difr, z, poles, givptr,
     &                   givcol, ldgcol, perm, givnum, c, s, rwork,
     &                   iwork, info )
      integer            icompq, info, ldb, ldbx, ldgcol, ldu, n, nrhs,
     &                   smlsiz
      integer            givcol( ldgcol, * ), givptr( * ), iwork( * ),
     &                   k( * ), perm( ldgcol, * )
      double precision   c( * ), difl( ldu, * ), difr( ldu, * ),
     &                   givnum( ldu, * ), poles( ldu, * ), rwork( * ),
     &                   s( * ), u( ldu, * ), vt( ldu, * ), z( ldu, * )
      complex(kind=16)   b( ldb, * ), bx( ldbx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      integer            i, i1, ic, im1, inode, j, jcol, jimag, jreal,
     &                   jrow, lf, ll, lvl, lvl2, nd, ndb1, ndiml,
     &                   ndimr, nl, nlf, nlp1, nlvl, nr, nrf, nrp1, sqre
      end subroutine zlalsa

      !! zlalsd.f
      subroutine zlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,
     &                   rank, work, rwork, iwork, info )
      character          uplo
      integer            info, ldb, n, nrhs, rank, smlsiz
      double precision   rcond
      integer            iwork( * )
      double precision   d( * ), e( * ), rwork( * )
      complex(kind=16)   b( ldb, * ), work( * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      complex(kind=16)   czero
      parameter          ( czero = ( 0.0d0, 0.0d0 ) )
      integer            bx, bxst, c, difl, difr, givcol, givnum,
     &                   givptr, i, icmpq1, icmpq2, irwb, irwib, irwrb,
     &                   irwu, irwvt, irwwrk, iwk, j, jcol, jimag,
     &                   jreal, jrow, k, nlvl, nm1, nrwork, nsize, nsub,
     &                   perm, poles, s, sizei, smlszp, sqre, st, st1,
     &                   u, vt, z
      double precision   cs, eps, orgnrm, rcnd, r, sn, tol
      integer            idamax
      double precision   dlamch, dlanst
      end subroutine zlalsd

      !! zlangb.f
      double precision function zlangb( norm, n, kl, ku, ab, ldab,
     &                 work )
      character          norm
      integer            kl, ku, ldab, n
      double precision   work( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, k, l
      double precision   scale, sum, value, temp
      logical            lsame, disnan
      end function zlangb

      !! zlange.f
      double precision function zlange( norm, m, n, a, lda, work )
      character          norm
      integer            lda, m, n
      double precision   work( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   scale, sum, value, temp
      logical            lsame, disnan
      end function zlange

      !! zlangt.f
      double precision function zlangt( norm, n, dl, d, du )
      character          norm
      integer            n
      complex(kind=16)   d( * ), dl( * ), du( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i
      double precision   anorm, scale, sum, temp
      logical            lsame, disnan
      end function zlangt

      !! zlanhb.f
      double precision function zlanhb( norm, uplo, n, k, ab, ldab,
     &                 work )
      character          norm, uplo
      integer            k, ldab, n
      double precision   work( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, l
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function zlanhb

      !! zlanhe.f
      double precision function zlanhe( norm, uplo, n, a, lda, work )
      character          norm, uplo
      integer            lda, n
      double precision   work( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function zlanhe

      !! zlanhf.f
      double precision function zlanhf( norm, transr, uplo, n, a, work )
      character          norm, transr, uplo
      integer            n
      double precision   work( 0: * )
      complex(kind=16)   a( 0: * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, ifm, ilu, noe, n1, k, l, lda
      double precision   scale, s, value, aa, temp
      logical            lsame, disnan
      end function zlanhf

      !! zlanhp.f
      double precision function zlanhp( norm, uplo, n, ap, work )
      character          norm, uplo
      integer            n
      double precision   work( * )
      complex(kind=16)   ap( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, k
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function zlanhp

      !! zlanhs.f
      double precision function zlanhs( norm, n, a, lda, work )
      character          norm
      integer            lda, n
      double precision   work( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   scale, sum, value
      logical            lsame, disnan
      end function zlanhs

      !! zlanht.f
      double precision function zlanht( norm, n, d, e )
      character          norm
      integer            n
      double precision   d( * )
      complex(kind=16)   e( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i
      double precision   anorm, scale, sum
      logical            lsame, disnan
      end function zlanht

      !! zlansb.f
      double precision function zlansb( norm, uplo, n, k, ab, ldab,
     &                 work )
      character          norm, uplo
      integer            k, ldab, n
      double precision   work( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, l
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function zlansb

      !! zlansp.f
      double precision function zlansp( norm, uplo, n, ap, work )
      character          norm, uplo
      integer            n
      double precision   work( * )
      complex(kind=16)   ap( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j, k
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function zlansp

      !! zlansy.f
      double precision function zlansy( norm, uplo, n, a, lda, work )
      character          norm, uplo
      integer            lda, n
      double precision   work( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, j
      double precision   absa, scale, sum, value
      logical            lsame, disnan
      end function zlansy

      !! zlantb.f
      double precision function zlantb( norm, uplo, diag, n, k, ab,
     &                 ldab, work )
      character          diag, norm, uplo
      integer            k, ldab, n
      double precision   work( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            udiag
      integer            i, j, l
      double precision   scale, sum, value
      logical            lsame, disnan
      end function zlantb

      !! zlantp.f
      double precision function zlantp( norm, uplo, diag, n, ap, work )
      character          diag, norm, uplo
      integer            n
      double precision   work( * )
      complex(kind=16)   ap( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            udiag
      integer            i, j, k
      double precision   scale, sum, value
      logical            lsame, disnan
      end function zlantp

      !! zlantr.f
      double precision function zlantr( norm, uplo, diag, m, n, a, lda,
     &                 work )
      character          diag, norm, uplo
      integer            lda, m, n
      double precision   work( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            udiag
      integer            i, j
      double precision   scale, sum, value
      logical            lsame, disnan
      end function zlantr

      !! zlapll.f
      subroutine zlapll( n, x, incx, y, incy, ssmin )
      integer            incx, incy, n
      double precision   ssmin
      complex(kind=16)   x( * ), y( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   ssmax
      complex(kind=16)   a11, a12, a22, c, tau
      complex(kind=16)   zdotc
      end subroutine zlapll

      !! zlapmr.f
      subroutine zlapmr( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      complex(kind=16)   x( ldx, * )
      integer            i, in, j, jj
      complex(kind=16)   temp
      end subroutine zlapmr

      !! zlapmt.f
      subroutine zlapmt( forwrd, m, n, x, ldx, k )
      logical            forwrd
      integer            ldx, m, n
      integer            k( * )
      complex(kind=16)   x( ldx, * )
      integer            i, ii, in, j
      complex(kind=16)   temp
      end subroutine zlapmt

      !! zla_porcond_c.f
      double precision function zla_porcond_c( uplo, n, a, lda, af,
     &                                         ldaf, c, capply, info,
     &                                         work, rwork )
      character          uplo
      logical            capply
      integer            n, lda, ldaf, info
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * )
      double precision   c( * ), rwork( * )
      integer            kase
      double precision   ainvnm, anorm, tmp
      integer            i, j
      logical            up, upper
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision cabs1
      end function zla_porcond_c

      !! zla_porcond_x.f
      double precision function zla_porcond_x( uplo, n, a, lda, af,
     &                                         ldaf, x, info, work,
     &                                         rwork )
      character          uplo
      integer            n, lda, ldaf, info
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * ), x( * )
      double precision   rwork( * )
      integer            kase, i, j
      double precision   ainvnm, anorm, tmp
      logical            up, upper
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision cabs1
      end function zla_porcond_x

      !! zla_porfsx_extended.f
      subroutine zla_porfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, colequ, c, b, ldb, y,
     &                                ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state,
     &                   y_prec_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec
      complex(kind=16)   zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      double precision   dlamch
      double precision   cabs1
      end subroutine zla_porfsx_extended

      !! zla_porpvgrw.f
      double precision function zla_porpvgrw( uplo, ncols, a, lda, af,
     &                                        ldaf, work )
      character(len=1)   uplo
      integer            ncols, lda, ldaf
      complex(kind=16)   a( lda, * ), af( ldaf, * )
      double precision   work( * )
      integer            i, j
      double precision   amax, umax, rpvgrw
      logical            upper
      complex(kind=16)   zdum
      logical            lsame
      double precision   cabs1
      end function zla_porpvgrw

      !! zlaqgb.f
      subroutine zlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,
     &                   amax, equed )
      character          equed
      integer            kl, ku, ldab, m, n
      double precision   amax, colcnd, rowcnd
      double precision   c( * ), r( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      double precision   dlamch
      end subroutine zlaqgb

      !! zlaqge.f
      subroutine zlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,
     &                   equed )
      character          equed
      integer            lda, m, n
      double precision   amax, colcnd, rowcnd
      double precision   c( * ), r( * )
      complex(kind=16)   a( lda, * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      double precision   dlamch
      end subroutine zlaqge

      !! zlaqhb.f
      subroutine zlaqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
      character          equed, uplo
      integer            kd, ldab, n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine zlaqhb

      !! zlaqhe.f
      subroutine zlaqhe( uplo, n, a, lda, s, scond, amax, equed )
      character          equed, uplo
      integer            lda, n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   a( lda, * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine zlaqhe

      !! zlaqhp.f
      subroutine zlaqhp( uplo, n, ap, s, scond, amax, equed )
      character          equed, uplo
      integer            n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   ap( * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j, jc
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine zlaqhp

      !! zlaqp2.f
      subroutine zlaqp2( m, n, offset, a, lda, jpvt, tau, vn1, vn2,
     &                   work )
      integer            lda, m, n, offset
      integer            jpvt( * )
      double precision   vn1( * ), vn2( * )
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      double precision   zero, one
      complex(kind=16)   cone
      parameter          ( zero = 0.0d+0, one = 1.0d+0,
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      integer            i, itemp, j, mn, offpi, pvt
      double precision   temp, temp2, tol3z
      complex(kind=16)   aii
      integer            idamax
      double precision   dlamch, dznrm2
      end subroutine zlaqp2

      !! zlaqps.f
      subroutine zlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,
     &                   vn2, auxv, f, ldf )
      integer            kb, lda, ldf, m, n, nb, offset
      integer            jpvt( * )
      double precision   vn1( * ), vn2( * )
      complex(kind=16)   a( lda, * ), auxv( * ), f( ldf, * ), tau( * )
      double precision   zero, one
      complex(kind=16)   czero, cone
      parameter          ( zero = 0.0d+0, one = 1.0d+0,
     &                   czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      integer            itemp, j, k, lastrk, lsticc, pvt, rk
      double precision   temp, temp2, tol3z
      complex(kind=16)   akk
      integer            idamax
      double precision   dlamch, dznrm2
      end subroutine zlaqps

      !! zlaqr0.f
      subroutine zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,
     &                   ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      complex(kind=16)   h( ldh, * ), w( * ), work( * ), z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      double precision   wilk1
      parameter          ( wilk1 = 0.75d0 )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d0, 0.0d0 ),
     &                   one = ( 1.0d0, 0.0d0 ) )
      double precision   two
      parameter          ( two = 2.0d0 )
      complex(kind=16)   aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
      double precision   s
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      complex(kind=16)   zdum( 1, 1 )
      double precision   cabs1
      end subroutine zlaqr0

      !! zlaqr1.f
      subroutine zlaqr1( n, h, ldh, s1, s2, v )
      complex(kind=16)   s1, s2
      integer            ldh, n
      complex(kind=16)   h( ldh, * ), v( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d0, 0.0d0 ) )
      double precision   rzero
      parameter          ( rzero = 0.0d0 )
      complex(kind=16)   cdum, h21s, h31s
      double precision   s
      double precision   cabs1
      end subroutine zlaqr1

      !! zlaqr2.f
      subroutine zlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt,
     &                   nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      complex(kind=16)   h( ldh, * ), sh( * ), t( ldt, * ), v( ldv, * ),
     &                   work( * ), wv( ldwv, * ), z( ldz, * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d0, 0.0d0 ),
     &                   one = ( 1.0d0, 0.0d0 ) )
      double precision   rzero, rone
      parameter          ( rzero = 0.0d0, rone = 1.0d0 )
      complex(kind=16)   beta, cdum, s, tau
      double precision   foo, safmax, safmin, smlnum, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, kcol, kln,
     &                   knt, krow, kwtop, ltop, lwk1, lwk2, lwkopt
      double precision   dlamch
      double precision   cabs1
      end subroutine zlaqr2

      !! zlaqr3.f
      subroutine zlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,
     &                   ihiz, z, ldz, ns, nd, sh, v, ldv, nh, t, ldt,
     &                   nv, wv, ldwv, work, lwork )
      integer            ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv,
     &                   ldz, lwork, n, nd, nh, ns, nv, nw
      logical            wantt, wantz
      complex(kind=16)   h( ldh, * ), sh( * ), t( ldt, * ), v( ldv, * ),
     &                   work( * ), wv( ldwv, * ), z( ldz, * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d0, 0.0d0 ),
     &                   one = ( 1.0d0, 0.0d0 ) )
      double precision   rzero, rone
      parameter          ( rzero = 0.0d0, rone = 1.0d0 )
      complex(kind=16)   beta, cdum, s, tau
      double precision   foo, safmax, safmin, smlnum, ulp
      integer            i, ifst, ilst, info, infqr, j, jw, kcol, kln,
     &                   knt, krow, kwtop, ltop, lwk1, lwk2, lwk3,
     &                   lwkopt, nmin
      double precision   dlamch
      integer            ilaenv
      double precision   cabs1
      end subroutine zlaqr3

      !! zlaqr4.f
      subroutine zlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,
     &                   ihiz, z, ldz, work, lwork, info )
      integer            ihi, ihiz, ilo, iloz, info, ldh, ldz, lwork, n
      logical            wantt, wantz
      complex(kind=16)   h( ldh, * ), w( * ), work( * ), z( ldz, * )
      integer            ntiny
      parameter          ( ntiny = 11 )
      integer            kexnw
      parameter          ( kexnw = 5 )
      integer            kexsh
      parameter          ( kexsh = 6 )
      double precision   wilk1
      parameter          ( wilk1 = 0.75d0 )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d0, 0.0d0 ),
     &                   one = ( 1.0d0, 0.0d0 ) )
      double precision   two
      parameter          ( two = 2.0d0 )
      complex(kind=16)   aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
      double precision   s
      integer            i, inf, it, itmax, k, kacc22, kbot, kdu, ks,
     &                   kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls,
     &                   lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns,
     &                   nsmax, nsr, nve, nw, nwmax, nwr, nwupbd
      logical            sorted
      character          jbcmpz*2
      integer            ilaenv
      complex(kind=16)   zdum( 1, 1 )
      double precision   cabs1
      end subroutine zlaqr4

      !! zlaqr5.f
      subroutine zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,
     &                   h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,
     &                   wv, ldwv, nh, wh, ldwh )
      integer            ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv,
     &                   ldwh, ldwv, ldz, n, nh, nshfts, nv
      logical            wantt, wantz
      complex(kind=16)   h( ldh, * ), s( * ), u( ldu, * ), v( ldv, * ),
     &                   wh( ldwh, * ), wv( ldwv, * ), z( ldz, * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d0, 0.0d0 ),
     &                   one = ( 1.0d0, 0.0d0 ) )
      double precision   rzero, rone
      parameter          ( rzero = 0.0d0, rone = 1.0d0 )
      complex(kind=16)   alpha, beta, cdum, refsum
      double precision   h11, h12, h21, h22, safmax, safmin, scl,
     &                   smlnum, tst1, tst2, ulp
      integer            i2, i4, incol, j, j2, j4, jbot, jcol, jlen,
     &                   jrow, jtop, k, k1, kdu, kms, knz, krcol, kzs,
     &                   m, m22, mbot, mend, mstart, mtop, nbmps, ndcol,
     &                   ns, nu
      logical            accum, blk22, bmp22
      double precision   dlamch
      complex(kind=16)   vt( 3 )
      double precision   cabs1
      end subroutine zlaqr5

      !! zlaqsb.f
      subroutine zlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
      character          equed, uplo
      integer            kd, ldab, n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   ab( ldab, * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine zlaqsb

      !! zlaqsp.f
      subroutine zlaqsp( uplo, n, ap, s, scond, amax, equed )
      character          equed, uplo
      integer            n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   ap( * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j, jc
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine zlaqsp

      !! zlaqsy.f
      subroutine zlaqsy( uplo, n, a, lda, s, scond, amax, equed )
      character          equed, uplo
      integer            lda, n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   a( lda, * )
      double precision   one, thresh
      parameter          ( one = 1.0d+0, thresh = 0.1d+0 )
      integer            i, j
      double precision   cj, large, small
      logical            lsame
      double precision   dlamch
      end subroutine zlaqsy

      !! zlar1v.f
      subroutine zlar1v( n, b1, bn, lambda, d, l, ld, lld,
     &           pivmin, gaptol, z, wantnc, negcnt, ztz, mingma,
     &           r, isuppz, nrminv, resid, rqcorr, work )
      logical            wantnc
      integer   b1, bn, n, negcnt, r
      double precision   gaptol, lambda, mingma, nrminv, pivmin, resid,
     &                   rqcorr, ztz
      integer            isuppz( * )
      double precision   d( * ), l( * ), ld( * ), lld( * ),
     &                  work( * )
      complex(kind=16) z( * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d0, 0.0d0 ) )
      logical            sawnan1, sawnan2
      integer            i, indlpl, indp, inds, indumn, neg1, neg2, r1,
     &                   r2
      double precision   dminus, dplus, eps, s, tmp
      logical disnan
      double precision   dlamch
      end subroutine zlar1v

      !! zlar2v.f
      subroutine zlar2v( n, x, y, z, incx, c, s, incc )
      integer            incc, incx, n
      double precision   c( * )
      complex(kind=16)   s( * ), x( * ), y( * ), z( * )
      integer            i, ic, ix
      double precision   ci, sii, sir, t1i, t1r, t5, t6, xi, yi, zii,
     &                   zir
      complex(kind=16)   si, t2, t3, t4, zi
      end subroutine zlar2v

      !! zlarcm.f
      subroutine zlarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
      integer            lda, ldb, ldc, m, n
      double precision   a( lda, * ), rwork( * )
      complex(kind=16)   b( ldb, * ), c( ldc, * )
      double precision   one, zero
      parameter          ( one = 1.0d0, zero = 0.0d0 )
      integer            i, j, l
      end subroutine zlarcm

      !! zlarfb.f
      subroutine zlarfb( side, trans, direct, storev, m, n, k, v, ldv,
     &                   t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, ldc, ldt, ldv, ldwork, m, n
      complex(kind=16)   c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      character          transt
      integer            i, j
      logical            lsame
      end subroutine zlarfb

      !! zlarf.f
      subroutine zlarf( side, m, n, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, ldc, m, n
      complex(kind=16)   tau
      complex(kind=16)   c( ldc, * ), v( * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            applyleft
      integer            i, lastv, lastc
      logical            lsame
      integer            ilazlr, ilazlc
      end subroutine zlarf

      !! zlarfg.f
      subroutine zlarfg( n, alpha, x, incx, tau )
      integer            incx, n
      complex(kind=16)   alpha, tau
      complex(kind=16)   x( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            j, knt
      double precision   alphi, alphr, beta, rsafmn, safmin, xnorm
      double precision   dlamch, dlapy3, dznrm2
      complex(kind=16)   zladiv
      end subroutine zlarfg

      !! zlarfgp.f
      subroutine zlarfgp( n, alpha, x, incx, tau )
      integer            incx, n
      complex(kind=16)   alpha, tau
      complex(kind=16)   x( * )
      double precision   two, one, zero
      parameter          ( two = 2.0d+0, one = 1.0d+0, zero = 0.0d+0 )
      integer            j, knt
      double precision   alphi, alphr, beta, bignum, smlnum, xnorm
      complex(kind=16)   savealpha
      double precision   dlamch, dlapy3, dlapy2, dznrm2
      complex(kind=16)   zladiv
      end subroutine zlarfgp

      !! zlarft.f
      subroutine zlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      complex(kind=16)   t( ldt, * ), tau( * ), v( ldv, * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, j, prevlastv, lastv
      logical            lsame
      end subroutine zlarft

      !! zlarfx.f
      subroutine zlarfx( side, m, n, v, tau, c, ldc, work )
      character          side
      integer            ldc, m, n
      complex(kind=16)   tau
      complex(kind=16)   c( ldc, * ), v( * ), work( * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      integer            j
      complex(kind=16)   sum, t1, t10, t2, t3, t4, t5, t6, t7, t8, t9,
     &                   v1, v10, v2, v3, v4, v5, v6, v7, v8, v9
      logical            lsame
      end subroutine zlarfx

      !! zlargv.f
      subroutine zlargv( n, x, incx, y, incy, c, incc )
      integer            incc, incx, incy, n
      double precision   c( * )
      complex(kind=16)   x( * ), y( * )
      double precision   two, one, zero
      parameter          ( two = 2.0d+0, one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)   czero
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ) )
      integer            count, i, ic, ix, iy, j
      double precision   cs, d, di, dr, eps, f2, f2s, g2, g2s, safmin,
     &                   safmn2, safmx2, scale
      complex(kind=16)   f, ff, fs, g, gs, r, sn
      double precision   dlamch, dlapy2
      double precision   abs1, abssq
      end subroutine zlargv

      !! zlarnv.f
      subroutine zlarnv( idist, iseed, n, x )
      integer            idist, n
      integer            iseed( 4 )
      complex(kind=16)   x( * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d+0, one = 1.0d+0, two = 2.0d+0 )
      integer            lv
      parameter          ( lv = 128 )
      double precision   twopi
      parameter          ( twopi = 6.2831853071795864769252867663d+0 )
      integer            i, il, iv
      double precision   u( lv )
      end subroutine zlarnv

      !! zlarrv.f
      subroutine zlarrv( n, vl, vu, d, l, pivmin,
     &                   isplit, m, dol, dou, minrgp,
     &                   rtol1, rtol2, w, werr, wgap,
     &                   iblock, indexw, gers, z, ldz, isuppz,
     &                   work, iwork, info )
      integer            dol, dou, info, ldz, m, n
      double precision   minrgp, pivmin, rtol1, rtol2, vl, vu
      integer            iblock( * ), indexw( * ), isplit( * ),
     &                   isuppz( * ), iwork( * )
      double precision   d( * ), gers( * ), l( * ), w( * ), werr( * ),
     &                   wgap( * ), work( * )
      complex(kind=16)  z( ldz, * )
      integer            maxitr
      parameter          ( maxitr = 10 )
      complex(kind=16)   czero
      parameter          ( czero = ( 0.0d0, 0.0d0 ) )
      double precision   zero, one, two, three, four, half
      parameter          ( zero = 0.0d0, one = 1.0d0,
     &                     two = 2.0d0, three = 3.0d0,
     &                     four = 4.0d0, half = 0.5d0)
      logical            eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
      integer            done, i, ibegin, idone, iend, ii, iindc1,
     &                   iindc2, iindr, iindwk, iinfo, im, in, indeig,
     &                   indld, indlld, indwrk, isupmn, isupmx, iter,
     &                   itmp1, j, jblk, k, miniwsize, minwsize, nclus,
     &                   ndepth, negcnt, newcls, newfst, newftt, newlst,
     &                   newsiz, offset, oldcls, oldfst, oldien, oldlst,
     &                   oldncl, p, parity, q, wbegin, wend, windex,
     &                   windmn, windpl, zfrom, zto, zusedl, zusedu,
     &                   zusedw
      integer            indin1, indin2
      double precision   bstres, bstw, eps, fudge, gap, gaptol, gl, gu,
     &                   lambda, left, lgap, mingma, nrminv, resid,
     &                   rgap, right, rqcorr, rqtol, savgap, sgndef,
     &                   sigma, spdiam, ssigma, tau, tmp, tol, ztz
      double precision   dlamch
      end subroutine zlarrv

      !! zlarscl2.f
      subroutine zlarscl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      complex(kind=16)   x( ldx, * )
      double precision   d( * )
      integer            i, j
      end subroutine zlarscl2

      !! zlartg.f
      subroutine zlartg( f, g, cs, sn, r )
      double precision   cs
      complex(kind=16)   f, g, r, sn
      double precision   two, one, zero
      parameter          ( two = 2.0d+0, one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)   czero
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ) )
      integer            count, i
      double precision   d, di, dr, eps, f2, f2s, g2, g2s, safmin,
     &                   safmn2, safmx2, scale
      complex(kind=16)   ff, fs, gs
      double precision   dlamch, dlapy2
      logical            disnan
      double precision   abs1, abssq
      end subroutine zlartg

      !! zlartv.f
      subroutine zlartv( n, x, incx, y, incy, c, s, incc )
      integer            incc, incx, incy, n
      double precision   c( * )
      complex(kind=16)   s( * ), x( * ), y( * )
      integer            i, ic, ix, iy
      complex(kind=16)   xi, yi
      end subroutine zlartv

      !! zlarzb.f
      subroutine zlarzb( side, trans, direct, storev, m, n, k, l, v,
     &                   ldv, t, ldt, c, ldc, work, ldwork )
      character          direct, side, storev, trans
      integer            k, l, ldc, ldt, ldv, ldwork, m, n
      complex(kind=16)   c( ldc, * ), t( ldt, * ), v( ldv, * ),
     &                   work( ldwork, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      character          transt
      integer            i, info, j
      logical            lsame
      end subroutine zlarzb

      !! zlarz.f
      subroutine zlarz( side, m, n, l, v, incv, tau, c, ldc, work )
      character          side
      integer            incv, l, ldc, m, n
      complex(kind=16)   tau
      complex(kind=16)   c( ldc, * ), v( * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            lsame
      end subroutine zlarz

      !! zlarzt.f
      subroutine zlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
      character          direct, storev
      integer            k, ldt, ldv, n
      complex(kind=16)   t( ldt, * ), tau( * ), v( ldv, * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, info, j
      logical            lsame
      end subroutine zlarzt

      !! zlascl2.f
      subroutine zlascl2 ( m, n, d, x, ldx )
      integer            m, n, ldx
      double precision   d( * )
      complex(kind=16)   x( ldx, * )
      integer            i, j
      end subroutine zlascl2

      !! zlascl.f
      subroutine zlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
      character          type
      integer            info, kl, ku, lda, m, n
      double precision   cfrom, cto
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d0, one = 1.0d0 )
      logical            done
      integer            i, itype, j, k1, k2, k3, k4
      double precision   bignum, cfrom1, cfromc, cto1, ctoc, mul, smlnum
      logical            lsame, disnan
      double precision   dlamch
      end subroutine zlascl

      !! zlaset.f
      subroutine zlaset( uplo, m, n, alpha, beta, a, lda )
      character          uplo
      integer            lda, m, n
      complex(kind=16)   alpha, beta
      complex(kind=16)   a( lda, * )
      integer            i, j
      logical            lsame
      end subroutine zlaset

      !! zlasr.f
      subroutine zlasr( side, pivot, direct, m, n, c, s, a, lda )
      character          direct, pivot, side
      integer            lda, m, n
      double precision   c( * ), s( * )
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, info, j
      double precision   ctemp, stemp
      complex(kind=16)   temp
      logical            lsame
      end subroutine zlasr

      !! zlassq.f
      subroutine zlassq( n, x, incx, scale, sumsq )
      integer            incx, n
      double precision   scale, sumsq
      complex(kind=16)   x( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            ix
      double precision   temp1
      logical            disnan
      end subroutine zlassq

      !! zlaswp.f
      subroutine zlaswp( n, a, lda, k1, k2, ipiv, incx )
      integer            incx, k1, k2, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      integer            i, i1, i2, inc, ip, ix, ix0, j, k, n32
      complex(kind=16)   temp
      end subroutine zlaswp

      !! zla_syamv.f
      subroutine zla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,
     &                      incy )
      double precision   alpha, beta
      integer            incx, incy, lda, n
      integer            uplo
      complex(kind=16)   a( lda, * ), x( * )
      double precision   y( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            symb_zero
      double precision   temp, safe1
      integer            i, info, iy, j, jx, kx, ky
      complex(kind=16)   zdum
      double precision   dlamch
      integer            ilauplo
      double precision   cabs1
      end subroutine zla_syamv

      !! zlasyf.f
      subroutine zlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), w( ldw, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      integer            imax, j, jb, jj, jmax, jp, k, kk, kkw, kp,
     &                   kstep, kw
      double precision   absakk, alpha, colmax, rowmax
      complex(kind=16)   d11, d21, d22, r1, t, z
      logical            lsame
      integer            izamax
      double precision   cabs1
      end subroutine zlasyf

      !! zlasyf_rook.f
      subroutine zlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,
     &                        info )
      character          uplo
      integer            info, kb, lda, ldw, n, nb
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), w( ldw, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      complex(kind=16)   cone, czero
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ),
     &                   czero = ( 0.0d+0, 0.0d+0 ) )
      logical            done
      integer            imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk,
     &                   kw, kkw, kp, kstep, p, ii
      double precision   absakk, alpha, colmax, rowmax, dtemp, sfmin
      complex(kind=16)   d11, d12, d21, d22, r1, t, z
      logical            lsame
      integer            izamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zlasyf_rook

      !! zla_syrcond_c.f
      double precision function zla_syrcond_c( uplo, n, a, lda, af,
     &                                         ldaf, ipiv, c, capply,
     &                                         info, work, rwork )
      character          uplo
      logical            capply
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * )
      double precision   c( * ), rwork( * )
      integer            kase
      double precision   ainvnm, anorm, tmp
      integer            i, j
      logical            up, upper
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision cabs1
      end function zla_syrcond_c

      !! zla_syrcond_x.f
      double precision function zla_syrcond_x( uplo, n, a, lda, af,
     &                                         ldaf, ipiv, x, info,
     &                                         work, rwork )
      character          uplo
      integer            n, lda, ldaf, info
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), work( * ), x( * )
      double precision   rwork( * )
      integer            kase
      double precision   ainvnm, anorm, tmp
      integer            i, j
      logical            up, upper
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   cabs1
      end function zla_syrcond_x

      !! zla_syrfsx_extended.f
      subroutine zla_syrfsx_extended( prec_type, uplo, n, nrhs, a, lda,
     &                                af, ldaf, ipiv, colequ, c, b, ldb,
     &                                y, ldy, berr_out, n_norms,
     &                                err_bnds_norm, err_bnds_comp, res,
     &                                ayb, dy, y_tail, rcond, ithresh,
     &                                rthresh, dz_ub, ignore_cwise,
     &                                info )
      integer            info, lda, ldaf, ldb, ldy, n, nrhs, prec_type,
     &                   n_norms, ithresh
      character          uplo
      logical            colequ, ignore_cwise
      double precision   rthresh, dz_ub
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   y( ldy, * ), res( * ), dy( * ), y_tail( * )
      double precision   c( * ), ayb( * ), rcond, berr_out( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      integer            uplo2, cnt, i, j, x_state, z_state,
     &                   y_prec_state
      double precision   yk, dyk, ymin, normy, normx, normdx, dxrat,
     &                   dzrat, prevnormdx, prev_dz_z, dxratmax,
     &                   dzratmax, dx_x, dz_z, final_dx_x, final_dz_z,
     &                   eps, hugeval, incr_thresh
      logical            incr_prec, upper
      complex(kind=16)   zdum
      integer            unstable_state, working_state, conv_state,
     &                   noprog_state, base_residual, extra_residual,
     &                   extra_y
      parameter          ( unstable_state = 0, working_state = 1,
     &                   conv_state = 2, noprog_state = 3 )
      parameter          ( base_residual = 0, extra_residual = 1,
     &                   extra_y = 2 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      logical            lsame
      integer            ilauplo
      double precision   dlamch
      double precision   cabs1
      end subroutine zla_syrfsx_extended

      !! zla_syrpvgrw.f
      double precision function zla_syrpvgrw( uplo, n, info, a, lda, af,
     &                                        ldaf, ipiv, work )
      character(len=1)   uplo
      integer            n, info, lda, ldaf
      complex(kind=16)   a( lda, * ), af( ldaf, * )
      double precision   work( * )
      integer            ipiv( * )
      integer            ncols, i, j, k, kp
      double precision   amax, umax, rpvgrw, tmp
      logical            upper
      complex(kind=16)   zdum
      logical            lsame
      double precision   cabs1
      end function zla_syrpvgrw

      !! zlat2c.f
      subroutine zlat2c( uplo, n, a, lda, sa, ldsa, info )
      character          uplo
      integer            info, lda, ldsa, n
      complex            sa( ldsa, * )
      complex(kind=16)   a( lda, * )
      integer            i, j
      double precision   rmax
      logical            upper
      real               slamch
      logical            lsame
      end subroutine zlat2c

      !! zlatbs.f
      subroutine zlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,
     &                   scale, cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, kd, ldab, n
      double precision   scale
      double precision   cnorm( * )
      complex(kind=16)   ab( ldab, * ), x( * )
      double precision   zero, half, one, two
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0,
     &                   two = 2.0d+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast, jlen, maind
      double precision   bignum, grow, rec, smlnum, tjj, tmax, tscal,
     &                   xbnd, xj, xmax
      complex(kind=16)   csumj, tjjs, uscal, zdum
      logical            lsame
      integer            idamax, izamax
      double precision   dlamch, dzasum
      complex(kind=16)   zdotc, zdotu, zladiv
      double precision   cabs1, cabs2
      end subroutine zlatbs

      !! zlatdf.f
      subroutine zlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,
     &                   jpiv )
      integer            ijob, ldz, n
      double precision   rdscal, rdsum
      integer            ipiv( * ), jpiv( * )
      complex(kind=16)   rhs( * ), z( ldz, * )
      integer            maxdim
      parameter          ( maxdim = 2 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      integer            i, info, j, k
      double precision   rtemp, scale, sminu, splus
      complex(kind=16)   bm, bp, pmone, temp
      double precision   rwork( maxdim )
      complex(kind=16)   work( 4*maxdim ), xm( maxdim ), xp( maxdim )
      double precision   dzasum
      complex(kind=16)   zdotc
      end subroutine zlatdf

      !! zlatps.f
      subroutine zlatps( uplo, trans, diag, normin, n, ap, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, n
      double precision   scale
      double precision   cnorm( * )
      complex(kind=16)   ap( * ), x( * )
      double precision   zero, half, one, two
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0,
     &                   two = 2.0d+0 )
      logical            notran, nounit, upper
      integer            i, imax, ip, j, jfirst, jinc, jlast, jlen
      double precision   bignum, grow, rec, smlnum, tjj, tmax, tscal,
     &                   xbnd, xj, xmax
      complex(kind=16)   csumj, tjjs, uscal, zdum
      logical            lsame
      integer            idamax, izamax
      double precision   dlamch, dzasum
      complex(kind=16)   zdotc, zdotu, zladiv
      double precision   cabs1, cabs2
      end subroutine zlatps

      !! zlatrd.f
      subroutine zlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
      character          uplo
      integer            lda, ldw, n, nb
      double precision   e( * )
      complex(kind=16)   a( lda, * ), tau( * ), w( ldw, * )
      complex(kind=16)   zero, one, half
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ),
     &                   half = ( 0.5d+0, 0.0d+0 ) )
      integer            i, iw
      complex(kind=16)   alpha
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zlatrd

      !! zlatrs.f
      subroutine zlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,
     &                   cnorm, info )
      character          diag, normin, trans, uplo
      integer            info, lda, n
      double precision   scale
      double precision   cnorm( * )
      complex(kind=16)   a( lda, * ), x( * )
      double precision   zero, half, one, two
      parameter          ( zero = 0.0d+0, half = 0.5d+0, one = 1.0d+0,
     &                   two = 2.0d+0 )
      logical            notran, nounit, upper
      integer            i, imax, j, jfirst, jinc, jlast
      double precision   bignum, grow, rec, smlnum, tjj, tmax, tscal,
     &                   xbnd, xj, xmax
      complex(kind=16)   csumj, tjjs, uscal, zdum
      logical            lsame
      integer            idamax, izamax
      double precision   dlamch, dzasum
      complex(kind=16)   zdotc, zdotu, zladiv
      double precision   cabs1, cabs2
      end subroutine zlatrs

      !! zlatrz.f
      subroutine zlatrz( m, n, l, a, lda, tau, work )
      integer            l, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i
      complex(kind=16)   alpha
      end subroutine zlatrz

      !! zlauu2.f
      subroutine zlauu2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i
      double precision   aii
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zlauu2

      !! zlauum.f
      subroutine zlauum( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i, ib, nb
      logical            lsame
      integer            ilaenv
      end subroutine zlauum

      !! zla_wwaddw.f
      subroutine zla_wwaddw( n, x, y, w )
      integer            n
      complex(kind=16)   x( * ), y( * ), w( * )
      complex(kind=16)   s
      integer            i
      end subroutine zla_wwaddw

      !! zpbcon.f
      subroutine zpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,
     &                   rwork, info )
      character          uplo
      integer            info, kd, ldab, n
      double precision   anorm, rcond
      double precision   rwork( * )
      complex(kind=16)   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      character          normin
      integer            ix, kase
      double precision   ainvnm, scale, scalel, scaleu, smlnum
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zpbcon

      !! zpbequ.f
      subroutine zpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
      character          uplo
      integer            info, kd, ldab, n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   ab( ldab, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            upper
      integer            i, j
      double precision   smin
      logical            lsame
      end subroutine zpbequ

      !! zpbrfs.f
      subroutine zpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,
     &                   ldb, x, ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, j, k, kase, l, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zpbrfs

      !! zpbstf.f
      subroutine zpbstf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            j, kld, km, m
      double precision   ajj
      logical            lsame
      end subroutine zpbstf

      !! zpbsv.f
      subroutine zpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      complex(kind=16)   ab( ldab, * ), b( ldb, * )
      logical            lsame
      end subroutine zpbsv

      !! zpbsvx.f
      subroutine zpbsvx( fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb,
     &                   equed, s, b, ldb, x, ldx, rcond, ferr, berr,
     &                   work, rwork, info )
      character          equed, fact, uplo
      integer            info, kd, ldab, ldafb, ldb, ldx, n, nrhs
      double precision   rcond
      double precision   berr( * ), ferr( * ), rwork( * ), s( * )
      complex(kind=16)   ab( ldab, * ), afb( ldafb, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            equil, nofact, rcequ, upper
      integer            i, infequ, j, j1, j2
      double precision   amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      double precision   dlamch, zlanhb
      end subroutine zpbsvx

      !! zpbtf2.f
      subroutine zpbtf2( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            j, kld, kn
      double precision   ajj
      logical            lsame
      end subroutine zpbtf2

      !! zpbtrf.f
      subroutine zpbtrf( uplo, n, kd, ab, ldab, info )
      character          uplo
      integer            info, kd, ldab, n
      complex(kind=16)   ab( ldab, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      integer            nbmax, ldwork
      parameter          ( nbmax = 32, ldwork = nbmax+1 )
      integer            i, i2, i3, ib, ii, j, jj, nb
      complex(kind=16)   work( ldwork, nbmax )
      logical            lsame
      integer            ilaenv
      end subroutine zpbtrf

      !! zpbtrs.f
      subroutine zpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
      character          uplo
      integer            info, kd, ldab, ldb, n, nrhs
      complex(kind=16)   ab( ldab, * ), b( ldb, * )
      logical            upper
      integer            j
      logical            lsame
      end subroutine zpbtrs

      !! zpftrf.f
      subroutine zpftrf( transr, uplo, n, a, info )
      character          transr, uplo
      integer            n, info
      complex(kind=16)   a( 0: * )
      double precision   one
      complex(kind=16)   cone
      parameter          ( one = 1.0d+0, cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine zpftrf

      !! zpftri.f
      subroutine zpftri( transr, uplo, n, a, info )
      character          transr, uplo
      integer            info, n
      complex(kind=16)   a( 0: * )
      double precision   one
      complex(kind=16)   cone
      parameter          ( one = 1.d0, cone = ( 1.d0, 0.d0 ) )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine zpftri

      !! zpftrs.f
      subroutine zpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
      character          transr, uplo
      integer            info, ldb, n, nrhs
      complex(kind=16)   a( 0: * ), b( ldb, * )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lower, normaltransr
      logical            lsame
      end subroutine zpftrs

      !! zpocon.f
      subroutine zpocon( uplo, n, a, lda, anorm, rcond, work, rwork,
     &                   info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      character          normin
      integer            ix, kase
      double precision   ainvnm, scale, scalel, scaleu, smlnum
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zpocon

      !! zpoequb.f
      subroutine zpoequb( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      double precision   amax, scond
      complex(kind=16)   a( lda, * )
      double precision   s( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i
      double precision   smin, base, tmp
      double precision   dlamch
      end subroutine zpoequb

      !! zpoequ.f
      subroutine zpoequ( n, a, lda, s, scond, amax, info )
      integer            info, lda, n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            i
      double precision   smin
      end subroutine zpoequ

      !! zporfs.f
      subroutine zporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,
     &                   ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zporfs

      !! zporfsx.f
      subroutine zporfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, s, b,
     &                    ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   rwork( * ), s( * ), params(*), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, zlanhe, zla_porcond_x, zla_porcond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine zporfsx

      !! zposv.f
      subroutine zposv( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      complex(kind=16)   a( lda, * ), b( ldb, * )
      logical            lsame
      end subroutine zposv

      !! zposvx.f
      subroutine zposvx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                   s, b, ldb, x, ldx, rcond, ferr, berr, work,
     &                   rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      double precision   rcond
      double precision   berr( * ), ferr( * ), rwork( * ), s( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      double precision   amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      double precision   dlamch, zlanhe
      end subroutine zposvx

      !! zposvxx.f
      subroutine zposvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,
     &                    s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      double precision   amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      double precision   dlamch, zla_porpvgrw
      end subroutine zposvxx

      !! zpotf2.f
      subroutine zpotf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j
      double precision   ajj
      logical            lsame, disnan
      complex(kind=16)   zdotc
      end subroutine zpotf2

      !! zpotrf2.f
      recursive subroutine zpotrf2( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = (1.0d+0, 0.0d+0) )
      logical            upper
      integer            n1, n2, iinfo
      double precision   ajj
      logical            lsame, disnan
      end subroutine zpotrf2

      !! zpotrf.f
      subroutine zpotrf( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      double precision   one
      complex(kind=16)   cone
      parameter          ( one = 1.0d+0, cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, jb, nb
      logical            lsame
      integer            ilaenv
      end subroutine zpotrf

      !! zpotri.f
      subroutine zpotri( uplo, n, a, lda, info )
      character          uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      logical            lsame
      end subroutine zpotri

      !! zpotrs.f
      subroutine zpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      complex(kind=16)   a( lda, * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      logical            lsame
      end subroutine zpotrs

      !! zppcon.f
      subroutine zppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
      character          uplo
      integer            info, n
      double precision   anorm, rcond
      double precision   rwork( * )
      complex(kind=16)   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      character          normin
      integer            ix, kase
      double precision   ainvnm, scale, scalel, scaleu, smlnum
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zppcon

      !! zppequ.f
      subroutine zppequ( uplo, n, ap, s, scond, amax, info )
      character          uplo
      integer            info, n
      double precision   amax, scond
      double precision   s( * )
      complex(kind=16)   ap( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, jj
      double precision   smin
      logical            lsame
      end subroutine zppequ

      !! zpprfs.f
      subroutine zpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,
     &                   berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zpprfs

      !! zppsv.f
      subroutine zppsv( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      complex(kind=16)   ap( * ), b( ldb, * )
      logical            lsame
      end subroutine zppsv

      !! zppsvx.f
      subroutine zppsvx( fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb,
     &                   x, ldx, rcond, ferr, berr, work, rwork, info )
      character          equed, fact, uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      double precision   berr( * ), ferr( * ), rwork( * ), s( * )
      complex(kind=16)   afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            equil, nofact, rcequ
      integer            i, infequ, j
      double precision   amax, anorm, bignum, scond, smax, smin, smlnum
      logical            lsame
      double precision   dlamch, zlanhp
      end subroutine zppsvx

      !! zpptrf.f
      subroutine zpptrf( uplo, n, ap, info )
      character          uplo
      integer            info, n
      complex(kind=16)   ap( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            upper
      integer            j, jc, jj
      double precision   ajj
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zpptrf

      !! zpptri.f
      subroutine zpptri( uplo, n, ap, info )
      character          uplo
      integer            info, n
      complex(kind=16)   ap( * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            upper
      integer            j, jc, jj, jjn
      double precision   ajj
      logical            lsame
      complex(kind=16)   zdotc
      end subroutine zpptri

      !! zpptrs.f
      subroutine zpptrs( uplo, n, nrhs, ap, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      complex(kind=16)   ap( * ), b( ldb, * )
      logical            upper
      integer            i
      logical            lsame
      end subroutine zpptrs

      !! zpstf2.f
      subroutine zpstf2( uplo, n, a, lda, piv, rank, tol, work, info )
      double precision   tol
      integer            info, lda, n, rank
      character          uplo
      complex(kind=16)   a( lda, * )
      double precision   work( 2*n )
      integer            piv( n )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      complex(kind=16)   ztemp
      double precision   ajj, dstop, dtemp
      integer            i, itemp, j, pvt
      logical            upper
      double precision   dlamch
      logical            lsame, disnan
      end subroutine zpstf2

      !! zpstrf.f
      subroutine zpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
      double precision   tol
      integer            info, lda, n, rank
      character          uplo
      complex(kind=16)   a( lda, * )
      double precision   work( 2*n )
      integer            piv( n )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      complex(kind=16)   ztemp
      double precision   ajj, dstop, dtemp
      integer            i, itemp, j, jb, k, nb, pvt
      logical            upper
      double precision   dlamch
      integer            ilaenv
      logical            lsame, disnan
      end subroutine zpstrf

      !! zptcon.f
      subroutine zptcon( n, d, e, anorm, rcond, rwork, info )
      integer            info, n
      double precision   anorm, rcond
      double precision   d( * ), rwork( * )
      complex(kind=16)   e( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      integer            i, ix
      double precision   ainvnm
      integer            idamax
      end subroutine zptcon

      !! zpteqr.f
      subroutine zpteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      double precision   d( * ), e( * ), work( * )
      complex(kind=16)   z( ldz, * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lsame
      complex(kind=16)   c( 1, 1 ), vt( 1, 1 )
      integer            i, icompz, nru
      end subroutine zpteqr

      !! zptrfs.f
      subroutine zptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   berr( * ), d( * ), df( * ), ferr( * ),
     &                   rwork( * )
      complex(kind=16)   b( ldb, * ), e( * ), ef( * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      double precision   one
      parameter          ( one = 1.0d+0 )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, ix, j, nz
      double precision   eps, lstres, s, safe1, safe2, safmin
      complex(kind=16)   bi, cx, dx, ex, zdum
      logical            lsame
      integer            idamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zptrfs

      !! zptsv.f
      subroutine zptsv( n, nrhs, d, e, b, ldb, info )
      integer            info, ldb, n, nrhs
      double precision   d( * )
      complex(kind=16)   b( ldb, * ), e( * )
      end subroutine zptsv

      !! zptsvx.f
      subroutine zptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,
     &                   rcond, ferr, berr, work, rwork, info )
      character          fact
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      double precision   berr( * ), d( * ), df( * ), ferr( * ),
     &                   rwork( * )
      complex(kind=16)   b( ldb, * ), e( * ), ef( * ), work( * ),
     &                   x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nofact
      double precision   anorm
      logical            lsame
      double precision   dlamch, zlanht
      end subroutine zptsvx

      !! zpttrf.f
      subroutine zpttrf( n, d, e, info )
      integer            info, n
      double precision   d( * )
      complex(kind=16)   e( * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      integer            i, i4
      double precision   eii, eir, f, g
      end subroutine zpttrf

      !! zpttrs.f
      subroutine zpttrs( uplo, n, nrhs, d, e, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      double precision   d( * )
      complex(kind=16)   b( ldb, * ), e( * )
      logical            upper
      integer            iuplo, j, jb, nb
      integer            ilaenv
      end subroutine zpttrs

      !! zptts2.f
      subroutine zptts2( iuplo, n, nrhs, d, e, b, ldb )
      integer            iuplo, ldb, n, nrhs
      double precision   d( * )
      complex(kind=16)   b( ldb, * ), e( * )
      integer            i, j
      end subroutine zptts2

      !! zrot.f
      subroutine zrot( n, cx, incx, cy, incy, c, s )
      integer            incx, incy, n
      double precision   c
      complex(kind=16)   s
      complex(kind=16)   cx( * ), cy( * )
      integer            i, ix, iy
      complex(kind=16)   stemp
      end subroutine zrot

      !! zspcon.f
      subroutine zspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
      character          uplo
      integer            info, n
      double precision   anorm, rcond
      integer            ipiv( * )
      complex(kind=16)   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, ip, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine zspcon

      !! zspmv.f
      subroutine zspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
      character          uplo
      integer            incx, incy, n
      complex(kind=16)   alpha, beta
      complex(kind=16)   ap( * ), x( * ), y( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, info, ix, iy, j, jx, jy, k, kk, kx, ky
      complex(kind=16)   temp1, temp2
      logical            lsame
      end subroutine zspmv

      !! zspr.f
      subroutine zspr( uplo, n, alpha, x, incx, ap )
      character          uplo
      integer            incx, n
      complex(kind=16)   alpha
      complex(kind=16)   ap( * ), x( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, info, ix, j, jx, k, kk, kx
      complex(kind=16)   temp
      logical            lsame
      end subroutine zspr

      !! zsprfs.f
      subroutine zsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          uplo
      integer            info, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, ik, j, k, kase, kk, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zsprfs

      !! zspsv.f
      subroutine zspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   ap( * ), b( ldb, * )
      logical            lsame
      end subroutine zspsv

      !! zspsvx.f
      subroutine zspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,
     &                   ldx, rcond, ferr, berr, work, rwork, info )
      character          fact, uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   rcond
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   afp( * ), ap( * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            nofact
      double precision   anorm
      logical            lsame
      double precision   dlamch, zlansp
      end subroutine zspsvx

      !! zsptrf.f
      subroutine zsptrf( uplo, n, ap, ipiv, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex(kind=16)   ap( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i, imax, j, jmax, k, kc, kk, knc, kp, kpc,
     &                   kstep, kx, npp
      double precision   absakk, alpha, colmax, rowmax
      complex(kind=16)   d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, zdum
      logical            lsame
      integer            izamax
      double precision   cabs1
      end subroutine zsptrf

      !! zsptri.f
      subroutine zsptri( uplo, n, ap, ipiv, work, info )
      character          uplo
      integer            info, n
      integer            ipiv( * )
      complex(kind=16)   ap( * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kc, kcnext, kp, kpc, kstep, kx, npp
      complex(kind=16)   ak, akkp1, akp1, d, t, temp
      logical            lsame
      complex(kind=16)   zdotu
      end subroutine zsptri

      !! zsptrs.f
      subroutine zsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
      character          uplo
      integer            info, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   ap( * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kc, kp
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zsptrs

      !! zstedc.f
      subroutine zstedc( compz, n, d, e, z, ldz, work, lwork, rwork,
     &                   lrwork, iwork, liwork, info )
      character          compz
      integer            info, ldz, liwork, lrwork, lwork, n
      integer            iwork( * )
      double precision   d( * ), e( * ), rwork( * )
      complex(kind=16)   work( * ), z( ldz, * )
      double precision   zero, one, two
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0 )
      logical            lquery
      integer            finish, i, icompz, ii, j, k, lgn, liwmin, ll,
     &                   lrwmin, lwmin, m, smlsiz, start
      double precision   eps, orgnrm, p, tiny
      logical            lsame
      integer            ilaenv
      double precision   dlamch, dlanst
      end subroutine zstedc

      !! zstegr.f
      subroutine zstegr( jobz, range, n, d, e, vl, vu, il, iu,
     &           abstol, m, w, z, ldz, isuppz, work, lwork, iwork,
     &           liwork, info )
      character          jobz, range
      integer            il, info, iu, ldz, liwork, lwork, m, n
      double precision abstol, vl, vu
      integer            isuppz( * ), iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * )
      complex(kind=16)   z( ldz, * )
      logical tryrac
      end subroutine zstegr

      !! zstein.f
      subroutine zstein( n, d, e, m, w, iblock, isplit, z, ldz, work,
     &                   iwork, ifail, info )
      integer            info, ldz, m, n
      integer            iblock( * ), ifail( * ), isplit( * ),
     &                   iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * )
      complex(kind=16)   z( ldz, * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   zero, one, ten, odm3, odm1
      parameter          ( zero = 0.0d+0, one = 1.0d+0, ten = 1.0d+1,
     &                   odm3 = 1.0d-3, odm1 = 1.0d-1 )
      integer            maxits, extra
      parameter          ( maxits = 5, extra = 2 )
      integer            b1, blksiz, bn, gpind, i, iinfo, indrv1,
     &                   indrv2, indrv3, indrv4, indrv5, its, j, j1,
     &                   jblk, jmax, jr, nblk, nrmchk
      double precision   dtpcrt, eps, eps1, nrm, onenrm, ortol, pertol,
     &                   scl, sep, tol, xj, xjm, ztr
      integer            iseed( 4 )
      integer            idamax
      double precision   dasum, dlamch, dnrm2
      end subroutine zstein

      !! zstemr.f
      subroutine zstemr( jobz, range, n, d, e, vl, vu, il, iu,
     &                   m, w, z, ldz, nzc, isuppz, tryrac, work, lwork,
     &                   iwork, liwork, info )
      character          jobz, range
      logical            tryrac
      integer            il, info, iu, ldz, nzc, liwork, lwork, m, n
      double precision vl, vu
      integer            isuppz( * ), iwork( * )
      double precision   d( * ), e( * ), w( * ), work( * )
      complex(kind=16)   z( ldz, * )
      double precision   zero, one, four, minrgp
      parameter          ( zero = 0.0d0, one = 1.0d0,
     &                     four = 4.0d0,
     &                     minrgp = 1.0d-3 )
      logical            alleig, indeig, lquery, valeig, wantz, zquery
      integer            i, ibegin, iend, ifirst, iil, iindbl, iindw,
     &                   iindwk, iinfo, iinspl, iiu, ilast, in, indd,
     &                   inde2, inderr, indgp, indgrs, indwrk, itmp,
     &                   itmp2, j, jblk, jj, liwmin, lwmin, nsplit,
     &                   nzcmin, offset, wbegin, wend
      double precision   bignum, cs, eps, pivmin, r1, r2, rmax, rmin,
     &                   rtol1, rtol2, safmin, scale, smlnum, sn,
     &                   thresh, tmp, tnrm, wl, wu
      logical            lsame
      double precision   dlamch, dlanst
      end subroutine zstemr

      !! zsteqr.f
      subroutine zsteqr( compz, n, d, e, z, ldz, work, info )
      character          compz
      integer            info, ldz, n
      double precision   d( * ), e( * ), work( * )
      complex(kind=16)   z( ldz, * )
      double precision   zero, one, two, three
      parameter          ( zero = 0.0d0, one = 1.0d0, two = 2.0d0,
     &                   three = 3.0d0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d0, 0.0d0 ),
     &                   cone = ( 1.0d0, 0.0d0 ) )
      integer            maxit
      parameter          ( maxit = 30 )
      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
     &                   nm1, nmaxit
      double precision   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
     &                   s, safmax, safmin, ssfmax, ssfmin, tst
      logical            lsame
      double precision   dlamch, dlanst, dlapy2
      end subroutine zsteqr

      !! zsycon.f
      subroutine zsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                   info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            upper
      integer            i, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine zsycon

      !! zsycon_rook.f
      subroutine zsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,
     &                        info )
      character          uplo
      integer            info, lda, n
      double precision   anorm, rcond
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      complex(kind=16)      czero
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i, kase
      double precision   ainvnm
      integer            isave( 3 )
      logical            lsame
      end subroutine zsycon_rook

      !! zsyconv.f
      subroutine zsyconv( uplo, way, n, a, lda, ipiv, e, info )
      character          uplo, way
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), e( * )
      complex(kind=16)   zero
      parameter          ( zero = (0.0d+0,0.0d+0) )
      logical            lsame
      logical            upper, convert
      integer            i, ip, j
      complex(kind=16)   temp
      end subroutine zsyconv

      !! zsyequb.f
      subroutine zsyequb( uplo, n, a, lda, s, scond, amax, work, info )
      integer            info, lda, n
      double precision   amax, scond
      character          uplo
      complex(kind=16)   a( lda, * ), work( * )
      double precision   s( * )
      double precision   one, zero
      parameter          ( one = 1.0d0, zero = 0.0d0 )
      integer            max_iter
      parameter          ( max_iter = 100 )
      integer            i, j, iter
      double precision   avg, std, tol, c0, c1, c2, t, u, si, d, base,
     &                   smin, smax, smlnum, bignum, scale, sumsq
      logical            up
      complex(kind=16)   zdum
      double precision   dlamch
      logical            lsame
      double precision   cabs1
      end subroutine zsyequb

      !! zsymv.f
      subroutine zsymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
      character          uplo
      integer            incx, incy, lda, n
      complex(kind=16)   alpha, beta
      complex(kind=16)   a( lda, * ), x( * ), y( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, info, ix, iy, j, jx, jy, kx, ky
      complex(kind=16)   temp1, temp2
      logical            lsame
      end subroutine zsymv

      !! zsyr.f
      subroutine zsyr( uplo, n, alpha, x, incx, a, lda )
      character          uplo
      integer            incx, lda, n
      complex(kind=16)   alpha
      complex(kind=16)   a( lda, * ), x( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, info, ix, j, jx, kx
      complex(kind=16)   temp
      logical            lsame
      end subroutine zsyr

      !! zsyrfs.f
      subroutine zsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     &                   x, ldx, ferr, berr, work, rwork, info )
      character          uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      integer            itmax
      parameter          ( itmax = 5 )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      double precision   two
      parameter          ( two = 2.0d+0 )
      double precision   three
      parameter          ( three = 3.0d+0 )
      logical            upper
      integer            count, i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine zsyrfs

      !! zsyrfsx.f
      subroutine zsyrfsx( uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    s, b, ldb, x, ldx, rcond, berr, n_err_bnds,
     &                    err_bnds_norm, err_bnds_comp, nparams, params,
     &                    work, rwork, info )
      character          uplo, equed
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   s( * ), params( * ), berr( * ), rwork( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   itref_default, ithresh_default
      double precision   componentwise_default, rthresh_default
      double precision   dzthresh_default
      parameter          ( itref_default = 1.0d+0 )
      parameter          ( ithresh_default = 10.0d+0 )
      parameter          ( componentwise_default = 1.0d+0 )
      parameter          ( rthresh_default = 0.5d+0 )
      parameter          ( dzthresh_default = 0.25d+0 )
      integer            la_linrx_itref_i, la_linrx_ithresh_i,
     &                   la_linrx_cwise_i
      parameter          ( la_linrx_itref_i = 1,
     &                   la_linrx_ithresh_i = 2 )
      parameter          ( la_linrx_cwise_i = 3 )
      integer            la_linrx_trust_i, la_linrx_err_i,
     &                   la_linrx_rcond_i
      parameter          ( la_linrx_trust_i = 1, la_linrx_err_i = 2 )
      parameter          ( la_linrx_rcond_i = 3 )
      character(1)       norm
      logical            rcequ
      integer            j, prec_type, ref_type
      integer            n_norms
      double precision   anorm, rcond_tmp
      double precision   illrcond_thresh, err_lbnd, cwise_wrong
      logical            ignore_cwise
      integer            ithresh
      double precision   rthresh, unstable_thresh
      double precision   dlamch, zlansy, zla_syrcond_x, zla_syrcond_c
      logical            lsame
      integer            blas_fpinfo_x
      integer            ilatrans, ilaprec
      end subroutine zsyrfsx

      !! zsysv.f
      subroutine zsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine zsysv

      !! zsysv_rook.f
      subroutine zsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,
     &                  lwork, info )
      character          uplo
      integer            info, lda, ldb, lwork, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * )
      logical            lquery
      integer            lwkopt
      logical            lsame
      end subroutine zsysv_rook

      !! zsysvx.f
      subroutine zsysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,
     &                   ldb, x, ldx, rcond, ferr, berr, work, lwork,
     &                   rwork, info )
      character          fact, uplo
      integer            info, lda, ldaf, ldb, ldx, lwork, n, nrhs
      double precision   rcond
      integer            ipiv( * )
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      logical            lquery, nofact
      integer            lwkopt, nb
      double precision   anorm
      logical            lsame
      integer            ilaenv
      double precision   dlamch, zlansy
      end subroutine zsysvx

      !! zsysvxx.f
      subroutine zsysvxx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv,
     &                    equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr,
     &                    n_err_bnds, err_bnds_norm, err_bnds_comp,
     &                    nparams, params, work, rwork, info )
      character          equed, fact, uplo
      integer            info, lda, ldaf, ldb, ldx, n, nrhs, nparams,
     &                   n_err_bnds
      double precision   rcond, rpvgrw
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), af( ldaf, * ), b( ldb, * ),
     &                   x( ldx, * ), work( * )
      double precision   s( * ), params( * ), berr( * ),
     &                   err_bnds_norm( nrhs, * ),
     &                   err_bnds_comp( nrhs, * ), rwork( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      integer            final_nrm_err_i, final_cmp_err_i, berr_i
      integer            rcond_i, nrm_rcond_i, nrm_err_i, cmp_rcond_i
      integer            cmp_err_i, piv_growth_i
      parameter          ( final_nrm_err_i = 1, final_cmp_err_i = 2,
     &                   berr_i = 3 )
      parameter          ( rcond_i = 4, nrm_rcond_i = 5, nrm_err_i = 6 )
      parameter          ( cmp_rcond_i = 7, cmp_err_i = 8,
     &                   piv_growth_i = 9 )
      logical            equil, nofact, rcequ
      integer            infequ, j
      double precision   amax, bignum, smin, smax, scond, smlnum
      logical            lsame
      double precision   dlamch, zla_syrpvgrw
      end subroutine zsysvxx

      !! zsyswapr.f
      subroutine zsyswapr( uplo, n, a, lda, i1, i2)
      character        uplo
      integer          i1, i2, lda, n
      complex(kind=16) a( lda, n )
      logical            upper
      integer            i
      complex(kind=16)   tmp
      logical            lsame
      end subroutine zsyswapr

      !! zsytf2.f
      subroutine zsytf2( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i, imax, j, jmax, k, kk, kp, kstep
      double precision   absakk, alpha, colmax, rowmax
      complex(kind=16)   d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, z
      logical            disnan, lsame
      integer            izamax
      double precision   cabs1
      end subroutine zsytf2

      !! zsytf2_rook.f
      subroutine zsytf2_rook( uplo, n, a, lda, ipiv, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      double precision   eight, sevten
      parameter          ( eight = 8.0d+0, sevten = 17.0d+0 )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper, done
      integer            i, imax, j, jmax, itemp, k, kk, kp, kstep,
     &                   p, ii
      double precision   absakk, alpha, colmax, rowmax, dtemp, sfmin
      complex(kind=16)   d11, d12, d21, d22, t, wk, wkm1, wkp1, z
      logical            lsame
      integer            izamax
      double precision   dlamch
      double precision   cabs1
      end subroutine zsytf2_rook

      !! zsytrf.f
      subroutine zsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine zsytrf

      !! zsytrf_rook.f
      subroutine zsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      logical            lquery, upper
      integer            iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
      logical            lsame
      integer            ilaenv
      end subroutine zsytrf_rook

      !! zsytri2.f
      subroutine zsytri2( uplo, n, a, lda, ipiv, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      logical            upper, lquery
      integer            minsize, nbmax
      logical            lsame
      integer            ilaenv
      end subroutine zsytri2

      !! zsytri2x.f
      subroutine zsytri2x( uplo, n, a, lda, ipiv, work, nb, info )
      character          uplo
      integer            info, lda, n, nb
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( n+nb+1,* )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i, iinfo, ip, k, cut, nnb
      integer            count
      integer            j, u11, invd
      complex(kind=16)   ak, akkp1, akp1, d, t
      complex(kind=16)   u01_i_j, u01_ip1_j
      complex(kind=16)   u11_i_j, u11_ip1_j
      logical            lsame
      end subroutine zsytri2x

      !! zsytri.f
      subroutine zsytri( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            k, kp, kstep
      complex(kind=16)   ak, akkp1, akp1, d, t, temp
      logical            lsame
      complex(kind=16)   zdotu
      end subroutine zsytri

      !! zsytri_rook.f
      subroutine zsytri_rook( uplo, n, a, lda, ipiv, work, info )
      character          uplo
      integer            info, lda, n
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), work( * )
      complex(kind=16)   cone, czero
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ),
     &                   czero = ( 0.0d+0, 0.0d+0 ) )
      logical            upper
      integer            k, kp, kstep
      complex(kind=16)   ak, akkp1, akp1, d, t, temp
      logical            lsame
      complex(kind=16)   zdotu
      end subroutine zsytri_rook

      !! zsytrs2.f
      subroutine zsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                    work, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16) a( lda, * ), b( ldb, * ), work( * )
      complex(kind=16)   one
      parameter          ( one = (1.0d+0,0.0d+0) )
      logical            upper
      integer            i, iinfo, j, k, kp
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zsytrs2

      !! zsytrs.f
      subroutine zsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kp
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zsytrs

      !! zsytrs_rook.f
      subroutine zsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,
     &                        info )
      character          uplo
      integer            info, lda, ldb, n, nrhs
      integer            ipiv( * )
      complex(kind=16)   a( lda, * ), b( ldb, * )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            j, k, kp
      complex(kind=16)   ak, akm1, akm1k, bk, bkm1, denom
      logical            lsame
      end subroutine zsytrs_rook

      !! ztbcon.f
      subroutine ztbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,
     &                   rwork, info )
      character          diag, norm, uplo
      integer            info, kd, ldab, n
      double precision   rcond
      double precision   rwork( * )
      complex(kind=16)   ab( ldab, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, anorm, scale, smlnum, xnorm
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch, zlantb
      double precision   cabs1
      end subroutine ztbcon

      !! ztbrfs.f
      subroutine ztbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, x, ldx, ferr, berr, work, rwork, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, ldx, n, nrhs
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   ab( ldab, * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            notran, nounit, upper
      character          transn, transt
      integer            i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine ztbrfs

      !! ztbtrs.f
      subroutine ztbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,
     &                   ldb, info )
      character          diag, trans, uplo
      integer            info, kd, ldab, ldb, n, nrhs
      complex(kind=16)   ab( ldab, * ), b( ldb, * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      logical            nounit, upper
      integer            j
      logical            lsame
      end subroutine ztbtrs

      !! ztfsm.f
      subroutine ztfsm( transr, side, uplo, trans, diag, m, n, alpha, a,
     &                  b, ldb )
      character          transr, diag, side, trans, uplo
      integer            ldb, m, n
      complex(kind=16)   alpha
      complex(kind=16)   a( 0: * ), b( 0: ldb-1, 0: * )
      complex(kind=16)   cone, czero
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ),
     &                   czero = ( 0.0d+0, 0.0d+0 ) )
      logical            lower, lside, misodd, nisodd, normaltransr,
     &                   notrans
      integer            m1, m2, n1, n2, k, info, i, j
      logical            lsame
      end subroutine ztfsm

      !! ztftri.f
      subroutine ztftri( transr, uplo, diag, n, a, info )
      character          transr, uplo, diag
      integer            info, n
      complex(kind=16)   a( 0: * )
      complex(kind=16)   cone
      parameter          ( cone = ( 1.0d+0, 0.0d+0 ) )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k
      logical            lsame
      end subroutine ztftri

      !! ztfttp.f
      subroutine ztfttp( transr, uplo, n, arf, ap, info )
      character          transr, uplo
      integer            info, n
      complex(kind=16)   ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine ztfttp

      !! ztfttr.f
      subroutine ztfttr( transr, uplo, n, arf, a, lda, info )
      character          transr, uplo
      integer            info, n, lda
      complex(kind=16)   a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt, nx2, np1x2
      integer            i, j, l, ij
      logical            lsame
      end subroutine ztfttr

      !! ztgevc.f
      subroutine ztgevc( side, howmny, select, n, s, lds, p, ldp, vl,
     &                   ldvl, vr, ldvr, mm, m, work, rwork, info )
      character          howmny, side
      integer            info, ldp, lds, ldvl, ldvr, m, mm, n
      logical            select( * )
      double precision   rwork( * )
      complex(kind=16)   p( ldp, * ), s( lds, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            compl, compr, ilall, ilback, ilbbad, ilcomp,
     &                   lsa, lsb
      integer            i, ibeg, ieig, iend, ihwmny, im, iside, isrc,
     &                   j, je, jr
      double precision   acoefa, acoeff, anorm, ascale, bcoefa, big,
     &                   bignum, bnorm, bscale, dmin, safmin, sbeta,
     &                   scale, small, temp, ulp, xmax
      complex(kind=16)   bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
      logical            lsame
      double precision   dlamch
      complex(kind=16)   zladiv
      double precision   abs1
      end subroutine ztgevc

      !! ztgex2.f
      subroutine ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, j1, info )
      logical            wantq, wantz
      integer            info, j1, lda, ldb, ldq, ldz, n
      complex(kind=16)   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      double precision   twenty
      parameter          ( twenty = 2.0d+1 )
      integer            ldst
      parameter          ( ldst = 2 )
      logical            wands
      parameter          ( wands = .true. )
      logical            dtrong, weak
      integer            i, m
      double precision   cq, cz, eps, sa, sb, scale, smlnum, ss, sum,
     &                   thresh, ws
      complex(kind=16)   cdum, f, g, sq, sz
      complex(kind=16)   s( ldst, ldst ), t( ldst, ldst ), work( 8 )
      double precision   dlamch
      end subroutine ztgex2

      !! ztgexc.f
      subroutine ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,
     &                   ldz, ifst, ilst, info )
      logical            wantq, wantz
      integer            ifst, ilst, info, lda, ldb, ldq, ldz, n
      complex(kind=16)   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   z( ldz, * )
      integer            here
      end subroutine ztgexc

      !! ztgsen.f
      subroutine ztgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,
     &                   alpha, beta, q, ldq, z, ldz, m, pl, pr, dif,
     &                   work, lwork, iwork, liwork, info )
      logical            wantq, wantz
      integer            ijob, info, lda, ldb, ldq, ldz, liwork, lwork,
     &                   m, n
      double precision   pl, pr
      logical            select( * )
      integer            iwork( * )
      double precision   dif( * )
      complex(kind=16)   a( lda, * ), alpha( * ), b( ldb, * ),
     &                   beta( * ), q( ldq, * ), work( * ), z( ldz, * )
      integer            idifjb
      parameter          ( idifjb = 3 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, swap, wantd, wantd1, wantd2, wantp
      integer            i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2,
     &                   n1, n2
      double precision   dscale, dsum, rdscal, safmin
      complex(kind=16)   temp1, temp2
      integer            isave( 3 )
      double precision   dlamch
      end subroutine ztgsen

      !! ztgsja.f
      subroutine ztgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,
     &                   ldb, tola, tolb, alpha, beta, u, ldu, v, ldv,
     &                   q, ldq, work, ncycle, info )
      character          jobq, jobu, jobv
      integer            info, k, l, lda, ldb, ldq, ldu, ldv, m, n,
     &                   ncycle, p
      double precision   tola, tolb
      double precision   alpha( * ), beta( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), q( ldq, * ),
     &                   u( ldu, * ), v( ldv, * ), work( * )
      integer            maxit
      parameter          ( maxit = 40 )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            initq, initu, initv, upper, wantq, wantu, wantv
      integer            i, j, kcycle
      double precision   a1, a3, b1, b3, csq, csu, csv, error, gamma,
     &                   rwk, ssmin
      complex(kind=16)   a2, b2, snq, snu, snv
      logical            lsame
      end subroutine ztgsja

      !! ztgsna.f
      subroutine ztgsna( job, howmny, select, n, a, lda, b, ldb, vl,
     &                   ldvl, vr, ldvr, s, dif, mm, m, work, lwork,
     &                   iwork, info )
      character          howmny, job
      integer            info, lda, ldb, ldvl, ldvr, lwork, m, mm, n
      logical            select( * )
      integer            iwork( * )
      double precision   dif( * ), s( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), vl( ldvl, * ),
     &                   vr( ldvr, * ), work( * )
      double precision   zero, one
      integer            idifjb
      parameter          ( zero = 0.0d+0, one = 1.0d+0, idifjb = 3 )
      logical            lquery, somcon, wantbh, wantdf, wants
      integer            i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
      double precision   bignum, cond, eps, lnrm, rnrm, scale, smlnum
      complex(kind=16)   yhax, yhbx
      complex(kind=16)   dummy( 1 ), dummy1( 1 )
      logical            lsame
      double precision   dlamch, dlapy2, dznrm2
      complex(kind=16)   zdotc
      end subroutine ztgsna

      !! ztgsy2.f
      subroutine ztgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, rdsum, rdscal,
     &                   info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf, m, n
      double precision   rdscal, rdsum, scale
      complex(kind=16)   a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * )
      double precision   zero, one
      integer            ldz
      parameter          ( zero = 0.0d+0, one = 1.0d+0, ldz = 2 )
      logical            notran
      integer            i, ierr, j, k
      double precision   scaloc
      complex(kind=16)   alpha
      integer            ipiv( ldz ), jpiv( ldz )
      complex(kind=16)   rhs( ldz ), z( ldz, ldz )
      logical            lsame
      end subroutine ztgsy2

      !! ztgsyl.f
      subroutine ztgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,
     &                   ldd, e, lde, f, ldf, scale, dif, work, lwork,
     &                   iwork, info )
      character          trans
      integer            ijob, info, lda, ldb, ldc, ldd, lde, ldf,
     &                   lwork, m, n
      double precision   dif, scale
      integer            iwork( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), c( ldc, * ),
     &                   d( ldd, * ), e( lde, * ), f( ldf, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   czero
      parameter          ( czero = (0.0d+0, 0.0d+0) )
      logical            lquery, notran
      integer            i, ie, ifunc, iround, is, isolve, j, je, js, k,
     &                   linfo, lwmin, mb, nb, p, pq, q
      double precision   dscale, dsum, scale2, scaloc
      logical            lsame
      integer            ilaenv
      end subroutine ztgsyl

      !! ztpcon.f
      subroutine ztpcon( norm, uplo, diag, n, ap, rcond, work, rwork,
     &                   info )
      character          diag, norm, uplo
      integer            info, n
      double precision   rcond
      double precision   rwork( * )
      complex(kind=16)   ap( * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, anorm, scale, smlnum, xnorm
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch, zlantp
      double precision   cabs1
      end subroutine ztpcon

      !! ztpmqrt.f
      subroutine ztpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,
     &                    a, lda, b, ldb, work, info )
      character side, trans
      integer   info, k, ldv, lda, ldb, m, n, l, nb, ldt
      complex(kind=16) v( ldv, * ), a( lda, * ), b( ldb, * ),
     &          t( ldt, * ), work( * )
      logical            left, right, tran, notran
      integer            i, ib, mb, lb, kf, ldaq, ldvq
      logical            lsame
      end subroutine ztpmqrt

      !! ztpqrt2.f
      subroutine ztpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
      integer   info, lda, ldb, ldt, n, m, l
      complex(kind=16) a( lda, * ), b( ldb, * ), t( ldt, * )
      complex(kind=16) one, zero
      parameter( one = (1.0,0.0), zero = (0.0,0.0) )
      integer   i, j, p, mp, np
      complex(kind=16) alpha
      end subroutine ztpqrt2

      !! ztpqrt.f
      subroutine ztpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,
     &                   info )
      integer info, lda, ldb, ldt, n, m, l, nb
      complex(kind=16) a( lda, * ), b( ldb, * ), t( ldt, * ), work( * )
      integer    i, ib, lb, mb, iinfo
      end subroutine ztpqrt

      !! ztprfb.f
      subroutine ztprfb( side, trans, direct, storev, m, n, k, l,
     &                   v, ldv, t, ldt, a, lda, b, ldb, work, ldwork )
      character direct, side, storev, trans
      integer   k, l, lda, ldb, ldt, ldv, ldwork, m, n
      complex(kind=16) a( lda, * ), b( ldb, * ), t( ldt, * ),
     &          v( ldv, * ), work( ldwork, * )
      complex(kind=16) one, zero
      parameter ( one = (1.0,0.0), zero = (0.0,0.0) )
      integer   i, j, mp, np, kp
      logical   left, forward, column, right, backward, row
      logical   lsame
      end subroutine ztprfb

      !! ztprfs.f
      subroutine ztprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,
     &                   ferr, berr, work, rwork, info )
      character          diag, trans, uplo
      integer            info, ldb, ldx, n, nrhs
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   ap( * ), b( ldb, * ), work( * ), x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            notran, nounit, upper
      character          transn, transt
      integer            i, j, k, kase, kc, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine ztprfs

      !! ztptri.f
      subroutine ztptri( uplo, diag, n, ap, info )
      character          diag, uplo
      integer            info, n
      complex(kind=16)   ap( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            nounit, upper
      integer            j, jc, jclast, jj
      complex(kind=16)   ajj
      logical            lsame
      end subroutine ztptri

      !! ztptrs.f
      subroutine ztptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
      character          diag, trans, uplo
      integer            info, ldb, n, nrhs
      complex(kind=16)   ap( * ), b( ldb, * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      logical            nounit, upper
      integer            j, jc
      logical            lsame
      end subroutine ztptrs

      !! ztpttf.f
      subroutine ztpttf( transr, uplo, n, ap, arf, info )
      character          transr, uplo
      integer            info, n
      complex(kind=16)   ap( 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            n1, n2, k, nt
      integer            i, j, ij
      integer            ijp, jp, lda, js
      logical            lsame
      end subroutine ztpttf

      !! ztpttr.f
      subroutine ztpttr( uplo, n, ap, a, lda, info )
      character          uplo
      integer            info, n, lda
      complex(kind=16)   a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine ztpttr

      !! ztrcon.f
      subroutine ztrcon( norm, uplo, diag, n, a, lda, rcond, work,
     &                   rwork, info )
      character          diag, norm, uplo
      integer            info, lda, n
      double precision   rcond
      double precision   rwork( * )
      complex(kind=16)   a( lda, * ), work( * )
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
      logical            nounit, onenrm, upper
      character          normin
      integer            ix, kase, kase1
      double precision   ainvnm, anorm, scale, smlnum, xnorm
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      integer            izamax
      double precision   dlamch, zlantr
      double precision   cabs1
      end subroutine ztrcon

      !! ztrevc.f
      subroutine ztrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, mm, m, work, rwork, info )
      character          howmny, side
      integer            info, ldt, ldvl, ldvr, m, mm, n
      logical            select( * )
      double precision   rwork( * )
      complex(kind=16)   t( ldt, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      complex(kind=16)   cmzero, cmone
      parameter          ( cmzero = ( 0.0d+0, 0.0d+0 ),
     &                   cmone = ( 1.0d+0, 0.0d+0 ) )
      logical            allv, bothv, leftv, over, rightv, somev
      integer            i, ii, is, j, k, ki
      double precision   ovfl, remax, scale, smin, smlnum, ulp, unfl
      complex(kind=16)   cdum
      logical            lsame
      integer            izamax
      double precision   dlamch, dzasum
      double precision   cabs1
      end subroutine ztrevc

      !! ztrexc.f
      subroutine ztrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
      character          compq
      integer            ifst, ilst, info, ldq, ldt, n
      complex(kind=16)   q( ldq, * ), t( ldt, * )
      logical            wantq
      integer            k, m1, m2, m3
      double precision   cs
      complex(kind=16)   sn, t11, t22, temp
      logical            lsame
      end subroutine ztrexc

      !! ztrrfs.f
      subroutine ztrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,
     &                   ldx, ferr, berr, work, rwork, info )
      character          diag, trans, uplo
      integer            info, lda, ldb, ldx, n, nrhs
      double precision   berr( * ), ferr( * ), rwork( * )
      complex(kind=16)   a( lda, * ), b( ldb, * ), work( * ),
     &                   x( ldx, * )
      double precision   zero
      parameter          ( zero = 0.0d+0 )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            notran, nounit, upper
      character          transn, transt
      integer            i, j, k, kase, nz
      double precision   eps, lstres, s, safe1, safe2, safmin, xk
      complex(kind=16)   zdum
      integer            isave( 3 )
      logical            lsame
      double precision   dlamch
      double precision   cabs1
      end subroutine ztrrfs

      !! ztrsen.f
      subroutine ztrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,
     &                   sep, work, lwork, info )
      character          compq, job
      integer            info, ldq, ldt, lwork, m, n
      double precision   s, sep
      logical            select( * )
      complex(kind=16)   q( ldq, * ), t( ldt, * ), w( * ), work( * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
      logical            lquery, wantbh, wantq, wants, wantsp
      integer            ierr, k, kase, ks, lwmin, n1, n2, nn
      double precision   est, rnorm, scale
      integer            isave( 3 )
      double precision   rwork( 1 )
      logical            lsame
      double precision   zlange
      end subroutine ztrsen

      !! ztrsna.f
      subroutine ztrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,
     &                   ldvr, s, sep, mm, m, work, ldwork, rwork,
     &                   info )
      character          howmny, job
      integer            info, ldt, ldvl, ldvr, ldwork, m, mm, n
      logical            select( * )
      double precision   rwork( * ), s( * ), sep( * )
      complex(kind=16)   t( ldt, * ), vl( ldvl, * ), vr( ldvr, * ),
     &                   work( ldwork, * )
      double precision   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d0+0 )
      logical            somcon, wantbh, wants, wantsp
      character          normin
      integer            i, ierr, ix, j, k, kase, ks
      double precision   bignum, eps, est, lnrm, rnrm, scale, smlnum,
     &                   xnorm
      complex(kind=16)   cdum, prod
      integer            isave( 3 )
      complex(kind=16)   dummy( 1 )
      logical            lsame
      integer            izamax
      double precision   dlamch, dznrm2
      complex(kind=16)   zdotc
      double precision   cabs1
      end subroutine ztrsna

      !! ztrsyl.f
      subroutine ztrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,
     &                   ldc, scale, info )
      character          trana, tranb
      integer            info, isgn, lda, ldb, ldc, m, n
      double precision   scale
      complex(kind=16)   a( lda, * ), b( ldb, * ), c( ldc, * )
      double precision   one
      parameter          ( one = 1.0d+0 )
      logical            notrna, notrnb
      integer            j, k, l
      double precision   bignum, da11, db, eps, scaloc, sgn, smin,
     &                   smlnum
      complex(kind=16)   a11, suml, sumr, vec, x11
      double precision   dum( 1 )
      logical            lsame
      double precision   dlamch, zlange
      complex(kind=16)   zdotc, zdotu, zladiv
      end subroutine ztrsyl

      !! ztrti2.f
      subroutine ztrti2( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            nounit, upper
      integer            j
      complex(kind=16)   ajj
      logical            lsame
      end subroutine ztrti2

      !! ztrtri.f
      subroutine ztrtri( uplo, diag, n, a, lda, info )
      character          diag, uplo
      integer            info, lda, n
      complex(kind=16)   a( lda, * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      logical            nounit, upper
      integer            j, jb, nb, nn
      logical            lsame
      integer            ilaenv
      end subroutine ztrtri

      !! ztrtrs.f
      subroutine ztrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,
     &                   info )
      character          diag, trans, uplo
      integer            info, lda, ldb, n, nrhs
      complex(kind=16)   a( lda, * ), b( ldb, * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      logical            nounit
      logical            lsame
      end subroutine ztrtrs

      !! ztrttf.f
      subroutine ztrttf( transr, uplo, n, a, lda, arf, info )
      character          transr, uplo
      integer            info, n, lda
      complex(kind=16)   a( 0: lda-1, 0: * ), arf( 0: * )
      logical            lower, nisodd, normaltransr
      integer            i, ij, j, k, l, n1, n2, nt, nx2, np1x2
      logical            lsame
      end subroutine ztrttf

      !! ztrttp.f
      subroutine ztrttp( uplo, n, a, lda, ap, info )
      character          uplo
      integer            info, n, lda
      complex(kind=16)   a( lda, * ), ap( * )
      logical            lower
      integer            i, j, k
      logical            lsame
      end subroutine ztrttp

      !! ztzrzf.f
      subroutine ztzrzf( m, n, a, lda, tau, work, lwork, info )
      integer            info, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, ib, iws, ki, kk, ldwork, lwkmin, lwkopt,
     &                   m1, mu, nb, nbmin, nx
      integer            ilaenv
      end subroutine ztzrzf

      !! zunbdb1.f
      subroutine zunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      complex(kind=16)   taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      complex(kind=16)   one
      parameter          ( one = (1.0d0,0.0d0) )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      double precision   dznrm2
      end subroutine zunbdb1

      !! zunbdb2.f
      subroutine zunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      complex(kind=16)   taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      complex(kind=16)   negone, one
      parameter          ( negone = (-1.0d0,0.0d0),
     &                     one = (1.0d0,0.0d0) )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      double precision   dznrm2
      end subroutine zunbdb2

      !! zunbdb3.f
      subroutine zunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, work, lwork, info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      complex(kind=16)   taup1(*), taup2(*), tauq1(*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      complex(kind=16)   one
      parameter          ( one = (1.0d0,0.0d0) )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, llarf, lorbdb5,
     &                   lworkmin, lworkopt
      logical            lquery
      double precision   dznrm2
      end subroutine zunbdb3

      !! zunbdb4.f
      subroutine zunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,
     &                    taup1, taup2, tauq1, phantom, work, lwork,
     &                    info )
      integer            info, lwork, m, p, q, ldx11, ldx21
      double precision   phi(*), theta(*)
      complex(kind=16)   phantom(*), taup1(*), taup2(*), tauq1(*),
     &                   work(*), x11(ldx11,*), x21(ldx21,*)
      complex(kind=16)   negone, one, zero
      parameter          ( negone = (-1.0d0,0.0d0), one = (1.0d0,0.0d0),
     &                     zero = (0.0d0,0.0d0) )
      double precision   c, s
      integer            childinfo, i, ilarf, iorbdb5, j, llarf,
     &                   lorbdb5, lworkmin, lworkopt
      logical            lquery
      double precision   dznrm2
      end subroutine zunbdb4

      !! zunbdb5.f
      subroutine zunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      complex(kind=16)   q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      complex(kind=16)   one, zero
      parameter          ( one = (1.0d0,0.0d0), zero = (0.0d0,0.0d0) )
      integer            childinfo, i, j
      double precision   dznrm2
      end subroutine zunbdb5

      !! zunbdb6.f
      subroutine zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,
     &                    ldq2, work, lwork, info )
      integer            incx1, incx2, info, ldq1, ldq2, lwork, m1, m2,
     &                   n
      complex(kind=16)   q1(ldq1,*), q2(ldq2,*), work(*), x1(*), x2(*)
      double precision   alphasq, realone, realzero
      parameter          ( alphasq = 0.01d0, realone = 1.0d0,
     &                     realzero = 0.0d0 )
      complex(kind=16)   negone, one, zero
      parameter          ( negone = (-1.0d0,0.0d0), one = (1.0d0,0.0d0),
     &                     zero = (0.0d0,0.0d0) )
      integer            i
      double precision   normsq1, normsq2, scl1, scl2, ssq1, ssq2
      end subroutine zunbdb6

      !! zunbdb.f
      subroutine zunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,
     &                   x21, ldx21, x22, ldx22, theta, phi, taup1,
     &                   taup2, tauq1, tauq2, work, lwork, info )
      character          signs, trans
      integer            info, ldx11, ldx12, ldx21, ldx22, lwork, m, p,
     &                   q
      double precision   phi( * ), theta( * )
      complex(kind=16)   taup1( * ), taup2( * ), tauq1( * ), tauq2( * ),
     &                   work( * ), x11( ldx11, * ), x12( ldx12, * ),
     &                   x21( ldx21, * ), x22( ldx22, * )
      double precision   realone
      parameter          ( realone = 1.0d0 )
      complex(kind=16)   one
      parameter          ( one = (1.0d0,0.0d0) )
      logical            colmajor, lquery
      integer            i, lworkmin, lworkopt, pi1, qi1
      double precision   z1, z2, z3, z4
      double precision   dznrm2
      logical            lsame
      end subroutine zunbdb

      !! zuncsd2by1.f
      subroutine zuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,
     &                       x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t,
     &                       ldv1t, work, lwork, rwork, lrwork, iwork,
     &                       info )
      character          jobu1, jobu2, jobv1t
      integer            info, ldu1, ldu2, ldv1t, lwork, ldx11, ldx21,
     &                   m, p, q
      integer            lrwork, lrworkmin, lrworkopt
      double precision   rwork(*)
      double precision   theta(*)
      complex(kind=16)   u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*),
     &                   x11(ldx11,*), x21(ldx21,*)
      integer            iwork(*)
      complex(kind=16)   one, zero
      parameter          ( one = (1.0d0,0.0d0), zero = (0.0d0,0.0d0) )
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   j, lbbcsd, lorbdb, lorglq, lorglqmin,
     &                   lorglqopt, lorgqr, lorgqrmin, lorgqropt,
     &                   lworkmin, lworkopt, r
      logical            lquery, wantu1, wantu2, wantv1t
      logical            lsame
      end subroutine zuncsd2by1

      !! zuncsd.f
      recursive subroutine zuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,
     &                             signs, m, p, q, x11, ldx11, x12,
     &                             ldx12, x21, ldx21, x22, ldx22, theta,
     &                             u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,
     &                             ldv2t, work, lwork, rwork, lrwork,
     &                             iwork, info )
      character          jobu1, jobu2, jobv1t, jobv2t, signs, trans
      integer            info, ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12,
     &                   ldx21, ldx22, lrwork, lwork, m, p, q
      integer            iwork( * )
      double precision   theta( * )
      double precision   rwork( * )
      complex(kind=16)   u1( ldu1, * ), u2( ldu2, * ), v1t( ldv1t, * ),
     &                   v2t( ldv2t, * ), work( * ), x11( ldx11, * ),
     &                   x12( ldx12, * ), x21( ldx21, * ), x22( ldx22,
     &                   * )
      complex(kind=16)   one, zero
      parameter          ( one = (1.0d0,0.0d0),
     &                     zero = (0.0d0,0.0d0) )
      character          transt, signst
      integer            childinfo, i, ib11d, ib11e, ib12d, ib12e,
     &                   ib21d, ib21e, ib22d, ib22e, ibbcsd, iorbdb,
     &                   iorglq, iorgqr, iphi, itaup1, itaup2, itauq1,
     &                   itauq2, j, lbbcsdwork, lbbcsdworkmin,
     &                   lbbcsdworkopt, lorbdbwork, lorbdbworkmin,
     &                   lorbdbworkopt, lorglqwork, lorglqworkmin,
     &                   lorglqworkopt, lorgqrwork, lorgqrworkmin,
     &                   lorgqrworkopt, lworkmin, lworkopt, p1, q1
      logical            colmajor, defaultsigns, lquery, wantu1, wantu2,
     &                   wantv1t, wantv2t
      integer            lrworkmin, lrworkopt
      logical            lrquery
      logical            lsame
      end subroutine zuncsd

      !! zung2l.f
      subroutine zung2l( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, ii, j, l
      end subroutine zung2l

      !! zung2r.f
      subroutine zung2r( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, j, l
      end subroutine zung2r

      !! zungbr.f
      subroutine zungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
      character          vect
      integer            info, k, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery, wantq
      integer            i, iinfo, j, lwkopt, mn
      logical            lsame
      integer            ilaenv
      end subroutine zungbr

      !! zunghr.f
      subroutine zunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
      integer            ihi, ilo, info, lda, lwork, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, iinfo, j, lwkopt, nb, nh
      integer            ilaenv
      end subroutine zunghr

      !! zungl2.f
      subroutine zungl2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, j, l
      end subroutine zungl2

      !! zunglq.f
      subroutine zunglq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine zunglq

      !! zungql.f
      subroutine zungql( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iws, j, kk, l, ldwork, lwkopt,
     &                   nb, nbmin, nx
      integer            ilaenv
      end subroutine zungql

      !! zungqr.f
      subroutine zungqr( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, ib, iinfo, iws, j, ki, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine zungqr

      !! zungr2.f
      subroutine zungr2( m, n, k, a, lda, tau, work, info )
      integer            info, k, lda, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   one, zero
      parameter          ( one = ( 1.0d+0, 0.0d+0 ),
     &                   zero = ( 0.0d+0, 0.0d+0 ) )
      integer            i, ii, j, l
      end subroutine zungr2

      !! zungrq.f
      subroutine zungrq( m, n, k, a, lda, tau, work, lwork, info )
      integer            info, k, lda, lwork, m, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ) )
      logical            lquery
      integer            i, ib, ii, iinfo, iws, j, kk, l, ldwork,
     &                   lwkopt, nb, nbmin, nx
      integer            ilaenv
      end subroutine zungrq

      !! zungtr.f
      subroutine zungtr( uplo, n, a, lda, tau, work, lwork, info )
      character          uplo
      integer            info, lda, lwork, n
      complex(kind=16)   a( lda, * ), tau( * ), work( * )
      complex(kind=16)   zero, one
      parameter          ( zero = ( 0.0d+0, 0.0d+0 ),
     &                   one = ( 1.0d+0, 0.0d+0 ) )
      logical            lquery, upper
      integer            i, iinfo, j, lwkopt, nb
      logical            lsame
      integer            ilaenv
      end subroutine zungtr

      !! zunm22.f
      subroutine zunm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            m, n, n1, n2, ldq, ldc, lwork, info
      complex(kind=16)   q( ldq, * ), c( ldc, * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            left, lquery, notran
      integer            i, ldwork, len, lwkopt, nb, nq, nw
      logical            lsame
      end subroutine zunm22

      !! zunm2l.f
      subroutine zunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      complex(kind=16)   aii, taui
      logical            lsame
      end subroutine zunm2l

      !! zunm2r.f
      subroutine zunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      complex(kind=16)   aii, taui
      logical            lsame
      end subroutine zunm2r

      !! zunmbr.f
      subroutine zunmbr( vect, side, trans, m, n, k, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans, vect
      integer            info, k, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            applyq, left, lquery, notran
      character          transt
      integer            i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmbr

      !! zunmhr.f
      subroutine zunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,
     &                   ldc, work, lwork, info )
      character          side, trans
      integer            ihi, ilo, info, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, lquery
      integer            i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmhr

      !! zunml2.f
      subroutine zunml2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, ic, jc, mi, ni, nq
      complex(kind=16)   aii, taui
      logical            lsame
      end subroutine zunml2

      !! zunmlq.f
      subroutine zunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmlq

      !! zunmql.f
      subroutine zunmql( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmql

      !! zunmqr.f
      subroutine zunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork,
     &                   lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmqr

      !! zunmr2.f
      subroutine zunmr2( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, lda, ldc, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            left, notran
      integer            i, i1, i2, i3, mi, ni, nq
      complex(kind=16)   aii, taui
      logical            lsame
      end subroutine zunmr2

      !! zunmr3.f
      subroutine zunmr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, info )
      character          side, trans
      integer            info, k, l, lda, ldc, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, notran
      integer            i, i1, i2, i3, ic, ja, jc, mi, ni, nq
      complex(kind=16)   taui
      logical            lsame
      end subroutine zunmr3

      !! zunmrq.f
      subroutine zunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt,
     &                   mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmrq

      !! zunmrz.f
      subroutine zunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans
      integer            info, k, l, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      integer            nbmax, ldt, tsize
      parameter          ( nbmax = 64, ldt = nbmax+1,
     &                     tsize = ldt*nbmax )
      logical            left, lquery, notran
      character          transt
      integer            i, i1, i2, i3, ib, ic, iinfo, iwt, ja, jc,
     &                   ldwork, lwkopt, mi, nb, nbmin, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmrz

      !! zunmtr.f
      subroutine zunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,
     &                   work, lwork, info )
      character          side, trans, uplo
      integer            info, lda, ldc, lwork, m, n
      complex(kind=16)   a( lda, * ), c( ldc, * ), tau( * ), work( * )
      logical            left, lquery, upper
      integer            i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
      logical            lsame
      integer            ilaenv
      end subroutine zunmtr

      !! zupgtr.f
      subroutine zupgtr( uplo, n, ap, tau, q, ldq, work, info )
      character          uplo
      integer            info, ldq, n
      complex(kind=16)   ap( * ), q( ldq, * ), tau( * ), work( * )
      complex(kind=16)   czero, cone
      parameter          ( czero = ( 0.0d+0, 0.0d+0 ),
     &                   cone = ( 1.0d+0, 0.0d+0 ) )
      logical            upper
      integer            i, iinfo, ij, j
      logical            lsame
      end subroutine zupgtr

      !! zupmtr.f
      subroutine zupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,
     &                   info )
      character          side, trans, uplo
      integer            info, ldc, m, n
      complex(kind=16)   ap( * ), c( ldc, * ), tau( * ), work( * )
      complex(kind=16)   one
      parameter          ( one = ( 1.0d+0, 0.0d+0 ) )
      logical            forwrd, left, notran, upper
      integer            i, i1, i2, i3, ic, ii, jc, mi, ni, nq
      complex(kind=16)   aii, taui
      logical            lsame
      end subroutine zupmtr

      end interface

      end module lapack
